<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>The Canvas v3</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Geist+Mono:wght@300;400;500;600&family=Lora:ital,wght@0,400;0,500;1,400&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0
    }

    /* ── LIGHT MODE (default) ── */
    :root {
      --bg: #f5f4f0;
      --bg2: #eeede9;
      --bg3: #e8e6e1;
      --paper: #fffffe;
      --paper2: #faf9f7;
      --border: rgba(0, 0, 0, .08);
      --border2: rgba(0, 0, 0, .14);
      --text: #1a1916;
      --text2: #3d3b35;
      --muted: #8a8880;
      --faint: rgba(0, 0, 0, .03);
      --faint2: rgba(0, 0, 0, .055);
      --accent: #d4580a;
      --accent2: #b84a08;
      --accentbg: rgba(212, 88, 10, .08);
      --blue: #2563eb;
      --green: #16a34a;
      --red: #dc2626;
      --purple: #7c3aed;
      --yellow: #ca8a04;
      --canvas-paper: #fffffe;
      --canvas-grid: rgba(0, 0, 0, 0.055);
      --canvas-lines: rgba(0, 0, 0, 0.07);
      --canvas-dots: rgba(0, 0, 0, 0.12);
      --canvas-margin: rgba(212, 88, 10, 0.15);
      --topbar-bg: rgba(245, 244, 240, .94);
      --hud-bg: rgba(245, 244, 240, .85);
      --font-serif: 'Instrument Serif', Georgia, serif;
      --font-body: 'Lora', Georgia, serif;
      --font-mono: 'Geist Mono', monospace;
      --sidebar-w: 260px;
      --topbar-h: 52px;
      --tool-w: 56px;
      --radius: 12px;
      --shadow: 0 2px 12px rgba(0, 0, 0, .08), 0 0 1px rgba(0, 0, 0, .06);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, .12), 0 0 1px rgba(0, 0, 0, .08);
    }

    /* ── DARK MODE ── */
    :root.dark {
      --bg: #0d0d0b;
      --bg2: #111110;
      --bg3: #161614;
      --paper: #13130f;
      --paper2: #0f0f0d;
      --border: rgba(255, 248, 230, .06);
      --border2: rgba(255, 248, 230, .11);
      --text: #f0ead8;
      --text2: #c8bfa8;
      --muted: rgba(240, 234, 216, .38);
      --faint: rgba(240, 234, 216, .04);
      --faint2: rgba(240, 234, 216, .07);
      --accent: #e8a87c;
      --accent2: #c47a45;
      --accentbg: rgba(232, 168, 124, .08);
      --blue: #7aafd4;
      --green: #7fba84;
      --red: #e07070;
      --purple: #a78bfa;
      --yellow: #f5d76e;
      --canvas-paper: #13130f;
      --canvas-grid: rgba(255, 248, 230, .04);
      --canvas-lines: rgba(255, 248, 230, .06);
      --canvas-dots: rgba(255, 248, 230, .18);
      --canvas-margin: rgba(232, 168, 124, .15);
      --topbar-bg: rgba(13, 13, 11, .96);
      --hud-bg: rgba(13, 13, 11, .88);
      --shadow: 0 2px 12px rgba(0, 0, 0, .35), 0 0 1px rgba(0, 0, 0, .5);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, .55), 0 0 1px rgba(0, 0, 0, .6);
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
    }

    body {
      font-family: var(--font-body);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
    }

    /* ── TOPBAR ── */
    .topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--topbar-h);
      z-index: 200;
      display: flex;
      align-items: center;
      gap: 0;
      background: var(--topbar-bg);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-bottom: 1px solid var(--border);
    }

    .tb-section {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 14px;
      height: 100%;
    }

    .tb-section.center {
      flex: 1;
      justify-content: center;
    }

    .tb-section.right {
      justify-content: flex-end;
      margin-left: auto;
    }

    .tb-divider {
      width: 1px;
      height: 24px;
      background: var(--border2);
      flex-shrink: 0;
    }

    .app-logo {
      font-family: var(--font-serif);
      font-size: 17px;
      color: var(--text);
      letter-spacing: -.01em;
    }

    .app-logo span {
      color: var(--accent);
    }

    .tb-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border-radius: 8px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      letter-spacing: .02em;
      border: 1px solid var(--border);
      background: var(--paper);
      color: var(--text2);
      cursor: pointer;
      transition: all .12s;
      white-space: nowrap;
      height: 32px;
    }

    .tb-btn:hover {
      background: var(--bg2);
      border-color: var(--border2);
    }

    .tb-btn.active,
    .tb-btn.accent {
      background: var(--accent);
      border-color: var(--accent2);
      color: #fff;
    }

    .tb-btn.active:hover {
      background: var(--accent2);
    }

    .tb-btn.ghost {
      border-color: transparent;
      background: transparent;
    }

    .tb-btn.ghost:hover {
      background: var(--faint2);
      border-color: var(--border);
    }

    .mode-group {
      display: flex;
      background: var(--bg3);
      border: 1px solid var(--border);
      border-radius: 9px;
      overflow: hidden;
    }

    .mode-btn {
      padding: 5px 12px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      color: var(--muted);
      border: none;
      background: transparent;
      cursor: pointer;
      transition: all .12s;
      height: 30px;
    }

    .mode-btn:hover {
      color: var(--text2);
    }

    .mode-btn.active {
      background: var(--paper);
      color: var(--text);
      box-shadow: 0 1px 4px rgba(0, 0, 0, .1);
    }

    .breadcrumb-title {
      font-family: var(--font-serif);
      font-size: 15px;
      color: var(--text2);
      font-style: italic;
      max-width: 280px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .note-count-badge {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
      padding: 2px 7px;
      background: var(--bg3);
      border: 1px solid var(--border);
      border-radius: 20px;
    }

    /* ── LAYOUT ── */
    .layout {
      position: fixed;
      top: var(--topbar-h);
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      overflow: hidden;
    }

    /* ── SIDEBAR ── */
    .sidebar {
      width: var(--sidebar-w);
      flex-shrink: 0;
      background: var(--paper);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: transform .22s cubic-bezier(.4, 0, .2, 1);
      box-shadow: 2px 0 8px rgba(0, 0, 0, .04);
    }

    .sidebar.hidden {
      transform: translateX(-100%);
    }

    @media(max-width:800px) {
      .sidebar {
        position: fixed;
        top: var(--topbar-h);
        bottom: 0;
        z-index: 150;
        transform: translateX(-100%);
      }

      .sidebar.open {
        transform: translateX(0);
      }
    }

    .sb-header {
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
    }

    .sb-new-btn {
      width: 100%;
      padding: 9px 14px;
      border-radius: var(--radius);
      background: var(--accent);
      border: none;
      color: #fff;
      font-family: var(--font-mono);
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
      transition: background .15s;
    }

    .sb-new-btn:hover {
      background: var(--accent2);
    }

    .sb-search {
      width: 100%;
      margin-top: 10px;
      padding: 8px 12px 8px 32px;
      border-radius: 8px;
      background: var(--bg2);
      border: 1px solid var(--border);
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text);
      outline: none;
      position: relative;
    }

    .sb-search-wrap {
      position: relative;
    }

    .sb-search-wrap::before {
      content: '⌕';
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      color: var(--muted);
      pointer-events: none;
      z-index: 1;
    }

    .sb-search::placeholder {
      color: var(--muted);
    }

    .sb-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 10px 8px;
    }

    .sb-scroll::-webkit-scrollbar {
      width: 3px;
    }

    .sb-scroll::-webkit-scrollbar-thumb {
      background: var(--border2);
      border-radius: 3px;
    }

    .sb-section-label {
      font-family: var(--font-mono);
      font-size: 9px;
      font-weight: 600;
      letter-spacing: .14em;
      text-transform: uppercase;
      color: var(--muted);
      padding: 8px 8px 4px;
    }

    .sb-note {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 9px 10px;
      border-radius: 10px;
      cursor: pointer;
      transition: all .12s;
      margin-bottom: 2px;
      border: 1px solid transparent;
    }

    .sb-note:hover {
      background: var(--bg2);
    }

    .sb-note.active {
      background: var(--accentbg);
      border-color: rgba(212, 88, 10, .18);
    }

    .sb-note-icon {
      font-size: 16px;
      flex-shrink: 0;
      margin-top: 1px;
      line-height: 1;
    }

    .sb-note-body {
      flex: 1;
      min-width: 0;
    }

    .sb-note-title {
      font-family: var(--font-body);
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      line-height: 1.4;
    }

    .sb-note-meta {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
      margin-top: 2px;
    }

    .sb-note-del {
      opacity: 0;
      font-size: 11px;
      color: var(--muted);
      padding: 2px 5px;
      border-radius: 4px;
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all .12s;
      flex-shrink: 0;
    }

    .sb-note:hover .sb-note-del {
      opacity: 1;
    }

    .sb-note-del:hover {
      background: rgba(220, 38, 38, .1);
      color: var(--red);
    }

    .sb-footer {
      padding: 10px 12px;
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .sb-footer-stats {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
    }

    /* ── MAIN ── */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      min-width: 0;
    }

    /* ── EMPTY STATE ── */
    .empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      pointer-events: none;
      background: var(--paper);
    }

    .empty-icon {
      font-family: var(--font-serif);
      font-size: 80px;
      font-style: italic;
      color: rgba(0, 0, 0, .06);
    }

    .empty-title {
      font-family: var(--font-serif);
      font-size: 22px;
      font-style: italic;
      color: var(--muted);
    }

    .empty-hint {
      font-family: var(--font-mono);
      font-size: 11px;
      color: rgba(0, 0, 0, .2);
      letter-spacing: .04em;
    }

    .empty-cta {
      pointer-events: all;
      display: flex;
      gap: 10px;
    }

    /* ── EDITOR VIEW ── */
    #editor-view {
      display: none;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
      background: var(--paper);
    }

    /* ══ WRITE MODE ══ */
    #write-pane {
      display: none;
      flex: 1;
      overflow: hidden;
      flex-direction: column;
    }

    #write-pane.active {
      display: flex;
    }

    .write-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      background: var(--paper);
    }

    .write-scroll::-webkit-scrollbar {
      width: 5px;
    }

    .write-scroll::-webkit-scrollbar-thumb {
      background: var(--border2);
      border-radius: 3px;
    }

    .write-inner {
      max-width: 760px;
      margin: 0 auto;
      padding: 40px 52px 120px;
    }

    .note-title-input {
      width: 100%;
      background: transparent;
      border: none;
      outline: none;
      font-family: var(--font-serif);
      font-size: 38px;
      font-style: italic;
      color: var(--text);
      caret-color: var(--accent);
      line-height: 1.2;
      padding: 0 0 8px;
      margin-bottom: 4px;
    }

    .note-title-input::placeholder {
      color: rgba(0, 0, 0, .2);
    }

    .note-meta-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0 16px;
      border-bottom: 2px solid var(--bg3);
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .note-meta-item {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--muted);
    }

    .note-tag {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 8px;
      border-radius: 20px;
      font-family: var(--font-mono);
      font-size: 9px;
      background: var(--accentbg);
      color: var(--accent);
      border: 1px solid rgba(212, 88, 10, .2);
      cursor: pointer;
    }

    .add-tag-btn {
      padding: 2px 8px;
      border-radius: 20px;
      font-family: var(--font-mono);
      font-size: 9px;
      border: 1px dashed var(--border2);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: all .12s;
    }

    .add-tag-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    #editor {
      min-height: 60vh;
      font-family: var(--font-body);
      font-size: 16px;
      line-height: 1.85;
      color: var(--text2);
      outline: none;
      caret-color: var(--accent);
    }

    #editor:empty::before {
      content: attr(data-placeholder);
      color: rgba(0, 0, 0, .2);
      font-style: italic;
      pointer-events: none;
    }

    #editor h1 {
      font-family: var(--font-serif);
      font-size: 32px;
      font-style: italic;
      color: var(--text);
      margin: 32px 0 12px;
      line-height: 1.2;
    }

    #editor h2 {
      font-family: var(--font-serif);
      font-size: 24px;
      font-style: italic;
      color: var(--text);
      margin: 24px 0 8px;
    }

    #editor h3 {
      font-family: var(--font-serif);
      font-size: 18px;
      color: var(--text);
      margin: 18px 0 6px;
    }

    #editor strong {
      color: var(--text);
      font-weight: 700;
    }

    #editor em {
      font-style: italic;
      color: var(--text2);
    }

    #editor a {
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    #editor blockquote {
      margin: 16px 0;
      padding: 12px 20px;
      border-left: 3px solid var(--accent);
      background: var(--accentbg);
      border-radius: 0 8px 8px 0;
      font-style: italic;
      color: var(--text2);
    }

    #editor ul,
    #editor ol {
      padding-left: 24px;
      margin: 8px 0;
    }

    #editor li {
      margin: 5px 0;
    }

    #editor hr {
      border: none;
      border-top: 2px solid var(--bg3);
      margin: 28px 0;
    }

    #editor p {
      margin-bottom: 8px;
    }

    .wikilink {
      color: var(--blue);
      border-bottom: 1px dotted var(--blue);
      cursor: pointer;
    }

    .wikilink:hover {
      background: rgba(37, 99, 235, .07);
    }

    /* ── INLINE CODE ── */
    #editor code.inline-code {
      font-family: var(--font-mono);
      font-size: 13px;
      background: var(--bg3);
      border: 1px solid var(--border2);
      padding: 1px 6px;
      border-radius: 5px;
      color: var(--accent2);
    }

    /* ══ FUNCTIONAL CODE BLOCK ══ */
    .code-block-wrap {
      margin: 18px 0;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border2);
      box-shadow: var(--shadow);
      background: #1e1e2e;
      position: relative;
    }

    .code-block-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: #181825;
      border-bottom: 1px solid rgba(255, 255, 255, .06);
    }

    .code-lang-select {
      font-family: var(--font-mono);
      font-size: 11px;
      font-weight: 500;
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .12);
      color: #cdd6f4;
      border-radius: 6px;
      padding: 3px 8px;
      cursor: pointer;
      outline: none;
    }

    .code-lang-select option {
      background: #1e1e2e;
      color: #cdd6f4;
    }

    .code-spacer {
      flex: 1;
    }

    .code-run-btn {
      padding: 4px 12px;
      border-radius: 6px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 600;
      border: none;
      background: rgba(166, 227, 161, .15);
      color: #a6e3a1;
      cursor: pointer;
      transition: all .12s;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .code-run-btn:hover {
      background: rgba(166, 227, 161, .25);
    }

    .code-copy-btn {
      padding: 4px 10px;
      border-radius: 6px;
      font-family: var(--font-mono);
      font-size: 10px;
      border: 1px solid rgba(255, 255, 255, .1);
      background: transparent;
      color: rgba(255, 255, 255, .4);
      cursor: pointer;
      transition: all .12s;
    }

    .code-copy-btn:hover {
      background: rgba(255, 255, 255, .08);
      color: rgba(255, 255, 255, .7);
    }

    .code-editor-area {
      font-family: var(--font-mono);
      font-size: 13px;
      line-height: 1.7;
      color: #cdd6f4;
      background: #1e1e2e;
      padding: 16px 18px;
      min-height: 80px;
      outline: none;
      white-space: pre;
      overflow-x: auto;
      tab-size: 2;
    }

    .code-editor-area:focus {
      outline: none;
    }

    .code-editor-area::placeholder {
      color: rgba(205, 214, 244, .25);
    }

    /* Highlighted view (non-editable) */
    .code-highlighted {
      font-family: var(--font-mono);
      font-size: 13px;
      line-height: 1.7;
      background: #1e1e2e;
      padding: 16px 18px;
      overflow-x: auto;
      cursor: text;
    }

    .code-highlighted .hljs {
      background: transparent;
      padding: 0;
    }

    .code-output {
      border-top: 1px solid rgba(255, 255, 255, .06);
      background: #11111b;
      padding: 10px 16px;
      font-family: var(--font-mono);
      font-size: 12px;
      line-height: 1.65;
      color: #a6e3a1;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }

    .code-output.show {
      display: block;
    }

    .code-output.error {
      color: #f38ba8;
    }

    .code-output-label {
      font-size: 9px;
      letter-spacing: .1em;
      color: rgba(255, 255, 255, .25);
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    /* ══ FUNCTIONAL KANBAN ══ */
    .kanban-wrap {
      margin: 18px 0;
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    .kanban-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: var(--paper);
      border-bottom: 1px solid var(--border);
    }

    .kanban-board-title {
      font-family: var(--font-serif);
      font-size: 15px;
      font-style: italic;
      color: var(--text);
      flex: 1;
      outline: none;
      background: transparent;
      border: none;
    }

    .kanban-board-title:focus {
      outline: 1px solid var(--accent);
      outline-offset: 3px;
      border-radius: 3px;
    }

    .kanban-add-col-btn {
      padding: 4px 10px;
      border-radius: 7px;
      font-family: var(--font-mono);
      font-size: 10px;
      border: 1px dashed var(--border2);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
    }

    .kanban-add-col-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .kanban-cols {
      display: flex;
      gap: 12px;
      padding: 14px;
      overflow-x: auto;
      min-height: 280px;
      align-items: flex-start;
    }

    .kanban-cols::-webkit-scrollbar {
      height: 4px;
    }

    .kanban-cols::-webkit-scrollbar-thumb {
      background: var(--border2);
      border-radius: 2px;
    }

    .kanban-col {
      min-width: 220px;
      flex-shrink: 0;
      background: var(--bg3);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      transition: border-color .15s;
      max-width: 260px;
    }

    .kanban-col.drag-over {
      border-color: var(--accent);
      background: var(--accentbg);
    }

    .kanban-col-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px 8px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .kanban-col-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .kanban-col-name {
      flex: 1;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--text2);
      background: transparent;
      border: none;
      outline: none;
    }

    .kanban-col-name:focus {
      outline: 1px solid var(--accent);
      outline-offset: 2px;
      border-radius: 2px;
    }

    .kanban-col-count {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
      margin-left: auto;
    }

    .kanban-col-del {
      font-size: 10px;
      color: var(--muted);
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 3px;
      opacity: 0;
      transition: all .1s;
    }

    .kanban-col-header:hover .kanban-col-del {
      opacity: 1;
    }

    .kanban-col-del:hover {
      background: rgba(220, 38, 38, .1);
      color: var(--red);
    }

    .kanban-cards {
      flex: 1;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 60px;
    }

    .kanban-card {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      cursor: grab;
      transition: all .15s;
      user-select: none;
      box-shadow: 0 1px 3px rgba(0, 0, 0, .05);
    }

    .kanban-card:hover {
      box-shadow: var(--shadow);
      border-color: var(--border2);
    }

    .kanban-card.dragging {
      opacity: .4;
      cursor: grabbing;
    }

    .kanban-card-title {
      font-size: 13px;
      color: var(--text);
      font-weight: 500;
      line-height: 1.4;
      word-break: break-word;
    }

    .kanban-card-desc {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--muted);
      margin-top: 4px;
      line-height: 1.5;
    }

    .kanban-card-meta {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 7px;
    }

    .kanban-card-tag {
      font-family: var(--font-mono);
      font-size: 9px;
      padding: 1px 7px;
      border-radius: 20px;
      font-weight: 500;
    }

    .kanban-card-actions {
      display: none;
      gap: 4px;
      margin-left: auto;
    }

    .kanban-card:hover .kanban-card-actions {
      display: flex;
    }

    .kca-btn {
      font-size: 10px;
      padding: 1px 5px;
      border-radius: 3px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--muted);
      cursor: pointer;
      transition: all .1s;
    }

    .kca-btn:hover {
      background: var(--bg3);
      color: var(--text);
    }

    .kca-btn.del:hover {
      background: rgba(220, 38, 38, .1);
      color: var(--red);
      border-color: rgba(220, 38, 38, .2);
    }

    .kanban-add-card {
      margin: 6px 8px 8px;
      padding: 7px 10px;
      border-radius: 7px;
      font-family: var(--font-mono);
      font-size: 10px;
      border: 1px dashed var(--border2);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      text-align: left;
      transition: all .12s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .kanban-add-card:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accentbg);
    }

    .kanban-card-ghost {
      height: 50px;
      background: var(--accentbg);
      border: 2px dashed rgba(212, 88, 10, .3);
      border-radius: 8px;
    }

    /* Card edit modal */
    .card-modal {
      position: fixed;
      inset: 0;
      z-index: 800;
      background: rgba(0, 0, 0, .35);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .card-modal.open {
      display: flex;
    }

    .card-modal-body {
      background: var(--paper);
      border-radius: 16px;
      padding: 24px;
      width: 100%;
      max-width: 460px;
      box-shadow: var(--shadow-lg);
      animation: modal-in .18s cubic-bezier(.34, 1.56, .64, 1);
    }

    .cm-title {
      font-family: var(--font-serif);
      font-size: 20px;
      font-style: italic;
      margin-bottom: 16px;
      color: var(--text);
    }

    .cm-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      background: var(--bg2);
      border: 1px solid var(--border2);
      font-family: var(--font-body);
      font-size: 14px;
      color: var(--text);
      outline: none;
      margin-bottom: 10px;
    }

    .cm-input:focus {
      border-color: var(--accent);
    }

    .cm-textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      background: var(--bg2);
      border: 1px solid var(--border2);
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text2);
      outline: none;
      resize: vertical;
      min-height: 80px;
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .cm-textarea:focus {
      border-color: var(--accent);
    }

    .cm-label {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 5px;
      display: block;
      letter-spacing: .04em;
    }

    .cm-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .cm-color-btn {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform .12s;
    }

    .cm-color-btn.sel {
      border-color: var(--text);
      transform: scale(1.2);
    }

    .cm-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .cm-btn {
      padding: 8px 18px;
      border-radius: 8px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      cursor: pointer;
      transition: all .15s;
    }

    .cm-btn.cancel {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
    }

    .cm-btn.cancel:hover {
      background: var(--bg2);
    }

    .cm-btn.save {
      border: none;
      background: var(--accent);
      color: #fff;
    }

    .cm-btn.save:hover {
      background: var(--accent2);
    }

    /* ═══ GOODNOTES-STYLE DRAW PANE ═══ */
    #draw-pane {
      display: none;
      flex: 1;
      overflow: hidden;
      flex-direction: column;
    }

    #draw-pane.active {
      display: flex;
    }

    /* Left tool sidebar - GoodNotes style */
    .draw-layout {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .tool-sidebar {
      width: var(--tool-w);
      flex-shrink: 0;
      background: var(--paper);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 0;
      gap: 4px;
      overflow-y: auto;
      box-shadow: 2px 0 8px rgba(0, 0, 0, .04);
      z-index: 10;
    }

    .tool-sidebar::-webkit-scrollbar {
      display: none;
    }

    .tool-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      width: 100%;
      padding: 6px 0;
    }

    .tool-group+.tool-group {
      border-top: 1px solid var(--border);
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all .12s;
      position: relative;
      flex-shrink: 0;
    }

    .tool-btn:hover {
      background: var(--bg2);
      border-color: var(--border);
    }

    .tool-btn.active {
      background: var(--accentbg);
      border-color: rgba(212, 88, 10, .25);
    }

    .tool-btn .tool-label {
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--font-mono);
      font-size: 8px;
      color: var(--muted);
      white-space: nowrap;
      pointer-events: none;
    }

    .tool-color-dot {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all .12s;
      flex-shrink: 0;
    }

    .tool-color-dot.active {
      border-color: var(--text);
      box-shadow: 0 0 0 2px var(--paper), 0 0 0 4px var(--text);
    }

    .tool-size-wrap {
      padding: 6px 8px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .tool-size-label {
      font-family: var(--font-mono);
      font-size: 8px;
      color: var(--muted);
    }

    .tool-size-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 36px;
      height: 80px;
      writing-mode: vertical-rl;
      direction: rtl;
      background: transparent;
      cursor: pointer;
      outline: none;
    }

    .tool-size-slider::-webkit-slider-runnable-track {
      width: 3px;
      background: var(--border2);
      border-radius: 2px;
    }

    .tool-size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid var(--paper);
      box-shadow: 0 1px 4px rgba(0, 0, 0, .2);
      margin-left: -5px;
    }

    .tool-undo-redo {
      display: flex;
      flex-direction: column;
      gap: 3px;
      padding: 4px 8px;
    }

    .tur-btn {
      width: 36px;
      height: 28px;
      border-radius: 7px;
      border: 1px solid var(--border);
      background: var(--paper2);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .12s;
    }

    .tur-btn:hover {
      background: var(--bg2);
      border-color: var(--border2);
    }

    .tur-btn:active {
      background: var(--bg3);
    }

    /* Canvas area */
    #canvas-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: var(--paper2);
      cursor: crosshair;
      touch-action: none;
    }

    #canvas-area.tool-pan {
      cursor: grab;
    }

    #canvas-area.tool-pan.panning {
      cursor: grabbing;
    }

    #canvas-area.tool-eraser {
      cursor: none;
    }

    #canvas-area.tool-scribble {
      cursor: none;
    }

    #canvas-area.tool-lasso {
      cursor: crosshair;
    }

    #bg-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #draw-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #overlay-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Custom cursors */
    .eraser-cursor,
    .scribble-cursor,
    .lasso-cursor {
      position: absolute;
      pointer-events: none;
      z-index: 20;
      display: none;
      transform: translate(-50%, -50%);
    }

    .eraser-cursor-inner {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, .5);
      background: rgba(255, 255, 255, .6);
    }

    .scribble-cursor-inner {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px dashed rgba(220, 38, 38, .6);
      background: rgba(220, 38, 38, .08);
    }

    /* HUD bottom bar */
    .canvas-hud {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30px;
      background: var(--hud-bg);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0;
      z-index: 10;
      font-family: var(--font-mono);
      font-size: 10px;
    }

    .hud-item {
      padding: 0 14px;
      color: var(--muted);
      border-right: 1px solid var(--border);
      height: 100%;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    .hud-item:last-child {
      border-right: none;
    }

    .hud-val {
      color: var(--text2);
      font-weight: 500;
    }

    .hud-spacer {
      flex: 1;
    }

    .hud-zoom-btn {
      padding: 0 8px;
      height: 100%;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      font-family: var(--font-mono);
      font-size: 11px;
      font-weight: 500;
      transition: all .1s;
    }

    .hud-zoom-btn:hover {
      color: var(--text);
      background: var(--faint2);
    }

    .hud-zoom-val {
      padding: 0 10px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 600;
      color: var(--text2);
      border-left: 1px solid var(--border);
      border-right: 1px solid var(--border);
      height: 100%;
      display: flex;
      align-items: center;
      cursor: default;
    }

    /* Top bar for draw mode */
    .draw-topbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--paper);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .draw-topbar::-webkit-scrollbar {
      display: none;
    }

    .draw-tb-btn {
      padding: 5px 11px;
      border-radius: 8px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--paper2);
      color: var(--text2);
      cursor: pointer;
      transition: all .12s;
      white-space: nowrap;
      height: 30px;
      display: flex;
      align-items: center;
      gap: 5px;
      flex-shrink: 0;
    }

    .draw-tb-btn:hover {
      background: var(--bg2);
      border-color: var(--border2);
    }

    .draw-tb-btn.active-bg {
      border-color: var(--accent);
      background: var(--accentbg);
      color: var(--accent);
    }

    .draw-tb-sep {
      width: 1px;
      height: 20px;
      background: var(--border);
      flex-shrink: 0;
    }

    .pdf-progress {
      display: none;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .pdf-progress.show {
      display: flex;
    }

    .pdf-progress-bar {
      width: 120px;
      height: 4px;
      background: var(--bg3);
      border-radius: 2px;
      overflow: hidden;
    }

    .pdf-progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width .25s;
    }

    .pdf-progress-text {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
    }

    /* Page thumbnails strip */
    .pages-strip {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 6px;
      background: var(--bg2);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      width: 80px;
      flex-shrink: 0;
      align-items: center;
    }

    .pages-strip::-webkit-scrollbar {
      display: none;
    }

    .page-thumb {
      width: 60px;
      height: 80px;
      border-radius: 6px;
      border: 2px solid var(--border);
      background: var(--paper);
      cursor: pointer;
      transition: all .15s;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      position: relative;
    }

    .page-thumb.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accentbg);
    }

    .page-thumb:hover:not(.active) {
      border-color: var(--border2);
    }

    .page-thumb-num {
      position: absolute;
      bottom: 3px;
      left: 0;
      right: 0;
      text-align: center;
      font-family: var(--font-mono);
      font-size: 7px;
      color: var(--muted);
    }

    .page-add-btn {
      width: 60px;
      height: 34px;
      border-radius: 6px;
      border: 1.5px dashed var(--border2);
      background: transparent;
      cursor: pointer;
      font-size: 16px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .12s;
      flex-shrink: 0;
    }

    .page-add-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accentbg);
    }

    /* ═══ MIXED PANE ═══ */
    #mixed-pane {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    #mixed-pane.active {
      display: flex;
    }

    .mixed-write {
      width: 50%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border-right: 1px solid var(--border);
    }

    .mixed-draw-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .mixed-hd {
      padding: 7px 14px;
      font-family: var(--font-mono);
      font-size: 9px;
      font-weight: 600;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      background: var(--paper);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #mixed-canvas-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: var(--paper2);
      touch-action: none;
    }

    #mixed-canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    #mixed-bg-canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    /* ═══ FLOAT FORMAT BAR ═══ */
    .fmt-bar {
      position: fixed;
      z-index: 300;
      background: var(--text);
      border-radius: 10px;
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 1px;
      box-shadow: var(--shadow-lg);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s, transform .15s;
      transform: translateY(5px);
    }

    .fmt-bar.visible {
      opacity: 1;
      pointer-events: all;
      transform: translateY(0);
    }

    .fb-btn {
      padding: 5px 8px;
      border-radius: 6px;
      font-family: var(--font-mono);
      font-size: 11px;
      border: none;
      background: transparent;
      color: rgba(255, 255, 255, .6);
      cursor: pointer;
      transition: all .1s;
      min-width: 28px;
      text-align: center;
    }

    .fb-btn:hover {
      background: rgba(255, 255, 255, .12);
      color: #fff;
    }

    .fb-sep {
      width: 1px;
      height: 16px;
      background: rgba(255, 255, 255, .15);
      margin: 0 2px;
    }

    /* ═══ SLASH MENU ═══ */
    .slash-menu {
      position: fixed;
      z-index: 400;
      background: var(--paper);
      border: 1px solid var(--border2);
      border-radius: var(--radius);
      padding: 6px;
      width: 270px;
      box-shadow: var(--shadow-lg);
      display: none;
    }

    .slash-menu.open {
      display: block;
    }

    .slash-search {
      width: 100%;
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 8px;
      outline: none;
      padding: 7px 10px;
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text);
      margin-bottom: 6px;
    }

    .slash-search::placeholder {
      color: var(--muted);
    }

    .slash-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 7px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: all .1s;
    }

    .slash-item:hover,
    .slash-item.focus {
      background: var(--accentbg);
    }

    .slash-icon {
      font-size: 16px;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .slash-label {
      font-size: 12px;
      font-weight: 500;
      color: var(--text2);
    }

    .slash-desc {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
    }

    /* ═══ GRAPH OVERLAY ═══ */
    .graph-overlay {
      position: fixed;
      inset: 0;
      z-index: 600;
      background: var(--bg);
      opacity-filter: blur(0);
      display: none;
      flex-direction: column;
    }

    .graph-overlay.open {
      display: flex;
    }

    .graph-hd {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
    }

    .graph-title {
      font-family: var(--font-serif);
      font-size: 18px;
      font-style: italic;
      color: var(--text);
      flex: 1;
    }

    #graph-canvas {
      flex: 1;
      display: block;
    }

    /* ═══ MODAL ═══ */
    .modal-overlay {
      position: fixed;
      inset: 0;
      z-index: 500;
      background: rgba(0, 0, 0, .3);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: var(--paper);
      border: 1px solid var(--border2);
      border-radius: 16px;
      padding: 26px;
      width: 100%;
      max-width: 420px;
      box-shadow: var(--shadow-lg);
      animation: modal-in .18s cubic-bezier(.34, 1.56, .64, 1);
    }

    @keyframes modal-in {
      from {
        opacity: 0;
        transform: scale(.93) translateY(12px)
      }

      to {
        opacity: 1;
        transform: scale(1) translateY(0)
      }
    }

    .modal-title {
      font-family: var(--font-serif);
      font-size: 20px;
      font-style: italic;
      margin-bottom: 16px;
      color: var(--text);
    }

    .modal-input {
      width: 100%;
      background: var(--bg2);
      border: 1px solid var(--border2);
      border-radius: 9px;
      padding: 11px 13px;
      font-family: var(--font-body);
      font-size: 14px;
      color: var(--text);
      outline: none;
      margin-bottom: 12px;
    }

    .modal-input:focus {
      border-color: var(--accent);
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 9px 20px;
      border-radius: 9px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all .15s;
    }

    .modal-btn.cancel {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
    }

    .modal-btn.cancel:hover {
      background: var(--bg2);
    }

    .modal-btn.confirm {
      border: none;
      background: var(--accent);
      color: #fff;
    }

    .modal-btn.confirm:hover {
      background: var(--accent2);
    }

    /* ═══ TOAST ═══ */
    .toast {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%) translateY(8px);
      z-index: 9000;
      background: var(--text);
      border-radius: 10px;
      padding: 8px 18px;
      font-family: var(--font-mono);
      font-size: 10px;
      color: #fff;
      opacity: 0;
      pointer-events: none;
      transition: all .25s cubic-bezier(.34, 1.56, .64, 1);
      white-space: nowrap;
      box-shadow: var(--shadow-lg);
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast.accent {
      background: var(--accent);
    }

    .toast.green {
      background: var(--green);
    }

    /* Sidebar overlay mobile */
    .sb-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .3);
      z-index: 140;
    }

    @media(max-width:800px) {
      .sb-overlay.show {
        display: block;
      }
    }

    /* Word count bar */
    .wc-bar {
      position: absolute;
      bottom: 0;
      left: var(--sidebar-w);
      right: 0;
      height: 26px;
      z-index: 50;
      display: flex;
      align-items: center;
      gap: 0;
      background: var(--hud-bg);
      backdrop-filter: blur(10px);
    }

    .wc-bar.no-sb {
      left: 0;
    }

    .wc-item {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 12px;
      color: var(--muted);
      border-right: 1px solid var(--border);
      height: 100%;
    }

    .wc-val {
      color: var(--text2);
      font-weight: 500;
    }

    .wc-hint {
      color: rgba(0, 0, 0, .2);
      font-size: 9px;
    }

    /* ═══ BACK BUTTON ═══ */
    .back-btn {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border-radius: 8px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      color: var(--text2);
      background: var(--paper);
      border: 1px solid var(--border);
      text-decoration: none;
      cursor: pointer;
      transition: all .12s;
      height: 32px;
    }

    .back-btn:hover {
      background: var(--bg2);
      border-color: var(--border2);
    }

    /* ═══ BLITZ AI PANEL ═══ */
    .blitz-panel {
      width: 340px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border);
      background: var(--paper);
      overflow: hidden;
      transition: width .22s cubic-bezier(.4, 0, .2, 1);
      box-shadow: -2px 0 8px rgba(0, 0, 0, .04);
    }

    .blitz-panel.collapsed {
      width: 0;
    }

    .blitz-hdr {
      padding: 12px 14px 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .blitz-logo {
      font-family: var(--font-mono);
      font-size: 12px;
      font-weight: 600;
      flex: 1;
      color: var(--text2);
      letter-spacing: .06em;
    }

    .blitz-logo b {
      color: var(--accent);
    }

    .blitz-badge {
      padding: 2px 7px;
      border-radius: 20px;
      font-family: var(--font-mono);
      font-size: 8px;
      background: var(--accentbg);
      color: var(--accent);
      border: 1px solid rgba(212, 88, 10, .2);
    }

    .blitz-quick {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .bq-btn {
      padding: 4px 9px;
      border-radius: 7px;
      font-family: var(--font-mono);
      font-size: 9px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--paper);
      color: var(--text2);
      cursor: pointer;
      transition: all .12s;
      white-space: nowrap;
    }

    .bq-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accentbg);
    }

    .send-note-btn {
      margin: 0 12px;
      padding: 8px;
      flex-shrink: 0;
      border-bottom: 1px solid var(--border);
    }

    .stb-btn {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 500;
      background: var(--accentbg);
      border: 1px solid rgba(212, 88, 10, .2);
      color: var(--accent);
      cursor: pointer;
      transition: all .15s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .stb-btn:hover {
      background: rgba(212, 88, 10, .15);
      border-color: rgba(212, 88, 10, .35);
    }

    .blitz-feed {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .blitz-feed::-webkit-scrollbar {
      width: 3px;
    }

    .blitz-feed::-webkit-scrollbar-thumb {
      background: var(--border2);
      border-radius: 3px;
    }

    .b-msg {
      display: flex;
      flex-direction: column;
      gap: 2px;
      max-width: 97%;
    }

    .b-msg.u {
      align-self: flex-end;
      align-items: flex-end;
    }

    .b-msg.b {
      align-self: flex-start;
    }

    .b-who {
      font-family: var(--font-mono);
      font-size: 8px;
      color: var(--muted);
      letter-spacing: .06em;
    }

    .b-bubble {
      padding: 9px 12px;
      border-radius: 10px;
      font-family: var(--font-body);
      font-size: 12px;
      line-height: 1.65;
      user-select: text;
    }

    .b-msg.u .b-bubble {
      background: var(--accentbg);
      border: 1px solid rgba(212, 88, 10, .18);
    }

    .b-msg.b .b-bubble {
      background: var(--bg2);
      border: 1px solid var(--border);
    }

    .b-bubble code {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--accent);
    }

    .b-ts {
      font-family: var(--font-mono);
      font-size: 7px;
      color: var(--muted);
    }

    .b-typing {
      align-self: flex-start;
      padding: 9px 14px;
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 10px;
      display: flex;
      gap: 4px;
    }

    .tdot {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: var(--muted);
      animation: tdot 1.2s ease-in-out infinite;
    }

    .tdot:nth-child(2) {
      animation-delay: .2s;
    }

    .tdot:nth-child(3) {
      animation-delay: .4s;
    }

    @keyframes tdot {

      0%,
      80%,
      100% {
        transform: translateY(0);
        opacity: .4;
      }

      40% {
        transform: translateY(-4px);
        opacity: 1;
      }
    }

    .blitz-inp-area {
      padding: 8px 12px 10px;
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .b-inp-row {
      display: flex;
      gap: 5px;
      align-items: flex-end;
    }

    .b-inp {
      flex: 1;
      background: var(--bg2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      font-family: var(--font-body);
      font-size: 12px;
      color: var(--text);
      outline: none;
      resize: none;
      line-height: 1.5;
      min-height: 36px;
      max-height: 120px;
    }

    .b-inp:focus {
      border-color: var(--accent);
    }

    .b-send {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      flex-shrink: 0;
      cursor: pointer;
      border: 1px solid rgba(212, 88, 10, .25);
      background: var(--accentbg);
      color: var(--accent);
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .15s;
    }

    .b-send:hover {
      background: rgba(212, 88, 10, .2);
    }

    /* ═══ READ MODE ═══ */
    .read-overlay {
      position: fixed;
      inset: 0;
      z-index: 700;
      background: var(--paper);
      display: none;
      flex-direction: column;
      overflow-y: auto;
    }

    .read-overlay.open {
      display: flex;
    }

    .read-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 48px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      position: sticky;
      top: 0;
      background: var(--topbar-bg);
      backdrop-filter: blur(16px);
      z-index: 2;
    }

    .read-title {
      font-family: var(--font-serif);
      font-size: 15px;
      font-style: italic;
      color: var(--text2);
      flex: 1;
    }

    .read-body {
      max-width: 680px;
      margin: 48px auto 80px;
      padding: 0 32px;
      font-family: var(--font-body);
      font-size: 16px;
      line-height: 1.95;
      color: var(--text2);
    }

    .read-body h1 {
      font-family: var(--font-serif);
      font-size: 30px;
      font-style: italic;
      color: var(--text);
      margin: 32px 0 12px;
    }

    .read-body h2 {
      font-family: var(--font-serif);
      font-size: 22px;
      font-style: italic;
      color: var(--text);
      margin: 24px 0 8px;
    }

    .read-body h3 {
      font-family: var(--font-serif);
      font-size: 17px;
      color: var(--text);
      margin: 18px 0 6px;
    }

    .read-body strong {
      color: var(--text);
    }

    .read-body blockquote {
      margin: 14px 0;
      padding: 12px 20px;
      border-left: 3px solid var(--accent);
      background: var(--accentbg);
      border-radius: 0 8px 8px 0;
      font-style: italic;
    }

    .read-body code {
      font-family: var(--font-mono);
      font-size: 12px;
      background: var(--bg3);
      border: 1px solid var(--border2);
      padding: 1px 5px;
      border-radius: 4px;
      color: var(--accent2);
    }

    .read-body p {
      margin-bottom: 10px;
    }

    /* ═══ GRAMMAR PANEL ═══ */
    .grammar-overlay {
      position: fixed;
      inset: 0;
      z-index: 650;
      background: rgba(0, 0, 0, .3);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .grammar-overlay.open {
      display: flex;
    }

    .grammar-box {
      background: var(--paper);
      border: 1px solid var(--border2);
      border-radius: 16px;
      width: 580px;
      max-width: 93vw;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg);
      animation: modal-in .18s cubic-bezier(.34, 1.56, .64, 1);
    }

    .grammar-hd {
      padding: 16px 20px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .grammar-title {
      font-family: var(--font-serif);
      font-size: 18px;
      font-style: italic;
      color: var(--text);
      flex: 1;
    }

    .grammar-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    .grammar-body::-webkit-scrollbar {
      width: 3px;
    }

    .grammar-body::-webkit-scrollbar-thumb {
      background: var(--border2);
      border-radius: 3px;
    }

    .grammar-issue {
      display: flex;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      margin-bottom: 8px;
      background: var(--bg2);
      transition: border-color .14s;
      cursor: pointer;
    }

    .grammar-issue:hover {
      border-color: var(--accent);
    }

    .grammar-issue-icon {
      font-size: 17px;
      flex-shrink: 0;
      margin-top: 1px;
    }

    .grammar-issue-body {
      flex: 1;
    }

    .grammar-issue-type {
      font-family: var(--font-mono);
      font-size: 8px;
      letter-spacing: .1em;
      text-transform: uppercase;
      margin-bottom: 3px;
      font-weight: 600;
    }

    .grammar-issue-type.spelling {
      color: var(--red);
    }

    .grammar-issue-type.grammar {
      color: var(--yellow);
    }

    .grammar-issue-type.style {
      color: var(--blue);
    }

    .grammar-issue-text {
      font-size: 12.5px;
      color: var(--text2);
      line-height: 1.6;
    }

    .grammar-issue-fix {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--accent);
      margin-top: 4px;
    }

    .grammar-empty {
      text-align: center;
      padding: 32px 16px;
      font-family: var(--font-serif);
      font-style: italic;
      color: var(--muted);
      font-size: 14px;
    }

    .grammar-ft {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      flex-shrink: 0;
    }

    .grammar-loading {
      text-align: center;
      padding: 40px;
      color: var(--muted);
      font-family: var(--font-mono);
      font-size: 11px;
    }

    /* ═══ ORGANISE PANEL ═══ */
    .organise-overlay {
      position: fixed;
      inset: 0;
      z-index: 640;
      background: rgba(0, 0, 0, .3);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .organise-overlay.open {
      display: flex;
    }

    .organise-box {
      background: var(--paper);
      border: 1px solid var(--border2);
      border-radius: 16px;
      width: 700px;
      max-width: 95vw;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg);
      animation: modal-in .18s cubic-bezier(.34, 1.56, .64, 1);
    }

    .organise-hd {
      padding: 16px 20px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .organise-title {
      font-family: var(--font-serif);
      font-size: 18px;
      font-style: italic;
      color: var(--text);
      flex: 1;
    }

    .organise-body {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .organise-folders {
      width: 200px;
      flex-shrink: 0;
      border-right: 1px solid var(--border);
      padding: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .organise-notes-col {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .org-folder-btn {
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 11.5px;
      color: var(--text2);
      cursor: pointer;
      border: 1px solid transparent;
      transition: all .12s;
      display: flex;
      align-items: center;
      gap: 7px;
      background: transparent;
      width: 100%;
      text-align: left;
    }

    .org-folder-btn:hover {
      background: var(--bg2);
      border-color: var(--border);
    }

    .org-folder-btn.active {
      background: var(--accentbg);
      border-color: rgba(212, 88, 10, .2);
      color: var(--accent);
    }

    .org-note-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg2);
      cursor: grab;
      transition: all .12s;
      user-select: none;
    }

    .org-note-row:hover {
      border-color: var(--border2);
    }

    .org-note-row.dragging {
      opacity: .4;
      cursor: grabbing;
    }

    .org-note-name {
      flex: 1;
      font-size: 11.5px;
      color: var(--text2);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .org-note-folder {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--muted);
    }

    .org-move-btn {
      padding: 3px 8px;
      border-radius: 6px;
      font-family: var(--font-mono);
      font-size: 9px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: all .12s;
    }

    .org-move-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .org-label {
      font-family: var(--font-mono);
      font-size: 9px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
      font-weight: 600;
    }

    .org-new-folder {
      padding: 7px 10px;
      border-radius: 8px;
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      border: 1px dashed var(--border2);
      text-align: center;
      transition: all .12s;
      background: transparent;
      width: 100%;
    }

    .org-new-folder:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
  </style>
</head>

<body>

  <!-- ═══ TOPBAR ═══ -->
  <div class="topbar">
    <div class="tb-section">
      <a class="back-btn" href="index.html" title="Back to B.L.I.T.Z.">← Back</a>
      <button class="tb-btn ghost" onclick="toggleSidebar()" style="padding:5px 9px;font-size:14px;">☰</button>
      <div class="app-logo">Canvas<span>.</span></div>
      <div class="tb-divider"></div>
      <div class="mode-group">
        <button class="mode-btn active" id="mt-write" onclick="setMode('write')">Write</button>
        <button class="mode-btn" id="mt-draw" onclick="setMode('draw')">Draw</button>
        <button class="mode-btn" id="mt-mixed" onclick="setMode('mixed')">Both</button>
      </div>
    </div>

    <div class="tb-section center">
      <div class="breadcrumb-title" id="breadcrumb-title">Select a note</div>
    </div>

    <div class="tb-section right">
      <span class="note-count-badge" id="note-count-badge">0 notes</span>
      <button class="tb-btn" onclick="openReadMode()" title="Distraction-free reading">📖 Read</button>
      <button class="tb-btn" onclick="openGrammarCheck()" title="Grammar & spelling check">✓ Grammar</button>
      <button class="tb-btn" onclick="openOrganise()" title="Organise notes & folders">📂 Organise</button>
      <button class="tb-btn" onclick="showGraph()" title="Note graph">◉ Graph</button>
      <button class="tb-btn" onclick="toggleTheme()" id="theme-btn" title="Toggle dark/light mode">☾ Dark</button>
      <button class="tb-btn" onclick="toggleBlitz()" id="blitz-toggle-btn" title="Toggle BLITZ AI panel">⚡
        Blitz</button>
      <button class="tb-btn active" onclick="newNote()">+ New Note</button>
    </div>
  </div>

  <!-- Mobile overlay -->
  <div class="sb-overlay" id="sb-overlay" onclick="closeSidebar()"></div>

  <!-- ═══ LAYOUT ═══ -->
  <div class="layout">

    <!-- SIDEBAR -->
    <div class="sidebar" id="sidebar">
      <div class="sb-header">
        <button class="sb-new-btn" onclick="newNote()">✦ New Note</button>
        <div class="sb-search-wrap" style="margin-top:10px;">
          <input type="text" class="sb-search" id="sb-search" placeholder="Search notes…"
            oninput="searchNotes(this.value)">
        </div>
      </div>
      <div class="sb-scroll">
        <div class="sb-section-label">All Notes</div>
        <div id="note-list"></div>
      </div>
      <div class="sb-footer">
        <div class="sb-footer-stats">
          <span id="sb-stats-notes">0 notes</span>
          <span id="sb-stats-words">0 words</span>
        </div>
      </div>
    </div>

    <!-- MAIN -->
    <div class="main" id="main">

      <div class="empty-state" id="empty-state">
        <div class="empty-icon">✦</div>
        <div class="empty-title">Your canvas awaits</div>
        <div class="empty-hint">CREATE A NOTE OR SELECT FROM SIDEBAR</div>
        <div class="empty-cta">
          <button class="tb-btn active" onclick="newNote()">+ New Note</button>
        </div>
      </div>

      <!-- EDITOR VIEW -->
      <div id="editor-view">

        <!-- ══ WRITE PANE ══ -->
        <div id="write-pane">
          <div class="write-scroll" id="write-scroll">
            <div class="write-inner">
              <input type="text" class="note-title-input" id="note-title" placeholder="Untitled note…"
                oninput="onTitleChange()">
              <div class="note-meta-row">
                <span class="note-meta-item" id="meta-date">—</span>
                <span class="note-meta-item" id="meta-wc">0 words</span>
                <div id="tag-row" style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;"></div>
                <button class="add-tag-btn" onclick="promptTag()">+ tag</button>
              </div>
              <div id="editor" contenteditable="true" spellcheck="true"
                data-placeholder="Start writing… type / for blocks, # for headings, ** for bold"></div>
            </div>
          </div>
          <!-- Word count -->
          <div class="wc-bar" id="wc-bar">
            <div class="wc-item"><span>Words</span><span class="wc-val" id="wc-words">0</span></div>
            <div class="wc-item"><span>Chars</span><span class="wc-val" id="wc-chars">0</span></div>
            <div class="wc-item" style="margin-left:auto;border-right:none;">
              <span class="wc-hint">/ blocks · [[link]] · # H1 · **bold**</span>
            </div>
          </div>
        </div>

        <!-- ══ DRAW PANE ══ -->
        <div id="draw-pane">
          <!-- Top bar -->
          <div class="draw-topbar">
            <button class="draw-tb-btn" onclick="triggerPdfImport()">📄 Import PDF</button>
            <input type="file" id="pdf-input" accept="application/pdf" style="display:none"
              onchange="handlePdfFile(this)">
            <div class="draw-tb-sep"></div>
            <button class="draw-tb-btn" id="bg-plain-btn" onclick="setBg('plain')">☐ Plain</button>
            <button class="draw-tb-btn active-bg" id="bg-grid-btn" onclick="setBg('grid')">⊞ Grid</button>
            <button class="draw-tb-btn" id="bg-lined-btn" onclick="setBg('lined')">≡ Lines</button>
            <button class="draw-tb-btn" id="bg-dots-btn" onclick="setBg('dots')">⠿ Dots</button>
            <div class="draw-tb-sep"></div>
            <button class="draw-tb-btn" onclick="exportPNG()">⬇ Export PNG</button>
            <div class="draw-tb-sep"></div>
            <div class="pdf-progress" id="pdf-progress">
              <div class="pdf-progress-bar">
                <div class="pdf-progress-fill" id="pdf-fill"></div>
              </div>
              <span class="pdf-progress-text" id="pdf-text">Loading…</span>
            </div>
          </div>

          <div class="draw-layout">
            <!-- LEFT TOOL SIDEBAR - GoodNotes style -->
            <div class="tool-sidebar">
              <!-- Drawing tools -->
              <div class="tool-group">
                <button class="tool-btn active" id="tool-pen" onclick="setTool('pen')" title="Pen (P)">✏️</button>
                <button class="tool-btn" id="tool-marker" onclick="setTool('marker')" title="Marker (M)">🖊️</button>
                <button class="tool-btn" id="tool-highlighter" onclick="setTool('highlighter')"
                  title="Highlighter (H)">🖌️</button>
              </div>
              <div class="tool-group">
                <button class="tool-btn" id="tool-eraser" onclick="setTool('eraser')" title="Eraser (E)">🧹</button>
                <button class="tool-btn" id="tool-scribble" onclick="setTool('scribble')" title="Scribble Erase (X)"
                  style="font-size:14px;font-family:var(--font-mono);color:var(--red);font-weight:700;">✗</button>
              </div>
              <div class="tool-group">
                <button class="tool-btn" id="tool-line" onclick="setTool('line')" title="Line">╱</button>
                <button class="tool-btn" id="tool-rect" onclick="setTool('rect')" title="Rectangle">□</button>
                <button class="tool-btn" id="tool-circle" onclick="setTool('circle')" title="Circle">○</button>
                <button class="tool-btn" id="tool-arrow" onclick="setTool('arrow')" title="Arrow">→</button>
              </div>
              <div class="tool-group">
                <button class="tool-btn" id="tool-text" onclick="setTool('text')" title="Text (T)"
                  style="font-family:var(--font-serif);font-size:20px;font-style:italic;">T</button>
                <button class="tool-btn" id="tool-pan" onclick="setTool('pan')" title="Pan (V)">✥</button>
              </div>
              <!-- Colors -->
              <div class="tool-group" style="gap:6px;padding:8px 0;">
                <div class="tool-color-dot active" style="background:#1a1916" onclick="setColor('#1a1916',this)"
                  title="Black"></div>
                <div class="tool-color-dot" style="background:#d4580a" onclick="setColor('#d4580a',this)" title="Amber">
                </div>
                <div class="tool-color-dot" style="background:#2563eb" onclick="setColor('#2563eb',this)" title="Blue">
                </div>
                <div class="tool-color-dot" style="background:#16a34a" onclick="setColor('#16a34a',this)" title="Green">
                </div>
                <div class="tool-color-dot" style="background:#dc2626" onclick="setColor('#dc2626',this)" title="Red">
                </div>
                <div class="tool-color-dot" style="background:#7c3aed" onclick="setColor('#7c3aed',this)"
                  title="Purple"></div>
                <div class="tool-color-dot" style="background:#ca8a04" onclick="setColor('#ca8a04',this)"
                  title="Yellow"></div>
                <div class="tool-color-dot" style="background:#0891b2" onclick="setColor('#0891b2',this)" title="Teal">
                </div>
              </div>
              <!-- Size slider -->
              <div class="tool-group">
                <div class="tool-size-wrap">
                  <input type="range" class="tool-size-slider" id="tool-size" min="1" max="32" value="3"
                    oninput="setSize(+this.value)">
                  <span class="tool-size-label" id="size-val">3px</span>
                </div>
              </div>
              <!-- Undo/Redo -->
              <div class="tool-group">
                <div class="tool-undo-redo">
                  <button class="tur-btn" onclick="undoDraw()" title="Undo (⌘Z)">↩</button>
                  <button class="tur-btn" onclick="redoDraw()" title="Redo (⌘Y)">↪</button>
                  <button class="tur-btn" onclick="clearPage()" title="Clear page"
                    style="color:var(--red);font-size:11px;font-family:var(--font-mono);">CLR</button>
                </div>
              </div>
            </div>

            <!-- INFINITE CANVAS -->
            <div id="canvas-area">
              <canvas id="bg-canvas"></canvas>
              <canvas id="draw-canvas"></canvas>
              <canvas id="overlay-canvas"></canvas>
              <div class="eraser-cursor" id="eraser-cursor">
                <div class="eraser-cursor-inner"></div>
              </div>
              <div class="scribble-cursor" id="scribble-cursor">
                <div class="scribble-cursor-inner"></div>
              </div>
              <!-- HUD -->
              <div class="canvas-hud">
                <div class="hud-item"><span>Tool</span><span class="hud-val" id="hud-tool">Pen</span></div>
                <div class="hud-item"><span>Size</span><span class="hud-val" id="hud-size">3px</span></div>
                <div class="hud-item"><span>Strokes</span><span class="hud-val" id="hud-strokes">0</span></div>
                <div class="hud-spacer"></div>
                <button class="hud-zoom-btn" onclick="zoomStep(-0.2)">−</button>
                <div class="hud-zoom-val" id="hud-zoom">100%</div>
                <button class="hud-zoom-btn" onclick="zoomStep(0.2)">+</button>
                <button class="hud-zoom-btn" onclick="resetViewport()"
                  style="padding:0 12px;border-left:1px solid var(--border);">Reset</button>
                <button class="hud-zoom-btn" onclick="fitToContent()"
                  style="padding:0 12px;border-left:1px solid var(--border);">Fit</button>
              </div>
            </div>

            <!-- PAGE THUMBNAILS -->
            <div class="pages-strip" id="pages-strip"></div>
          </div>
        </div>

        <!-- ══ MIXED PANE ══ -->
        <div id="mixed-pane">
          <div class="mixed-write">
            <div class="mixed-hd">✎ Write</div>
            <div style="flex:1;overflow-y:auto;padding:20px 24px 60px;">
              <div id="editor-mixed" contenteditable="true" spellcheck="true"
                style="min-height:300px;font-family:var(--font-body);font-size:15px;line-height:1.8;color:var(--text2);outline:none;caret-color:var(--accent);"
                data-placeholder="Write here…"></div>
            </div>
          </div>
          <div class="mixed-draw-area">
            <div class="mixed-hd">
              ✏ Draw
              <button class="draw-tb-btn" id="mx-pen" onclick="setTool('pen')"
                style="height:22px;padding:2px 8px;font-size:9px;margin-left:4px;">Pen</button>
              <button class="draw-tb-btn" id="mx-hl" onclick="setTool('highlighter')"
                style="height:22px;padding:2px 8px;font-size:9px;">HL</button>
              <button class="draw-tb-btn" id="mx-erase" onclick="setTool('scribble')"
                style="height:22px;padding:2px 8px;font-size:9px;color:var(--red);">✗</button>
              <button class="draw-tb-btn" id="mx-pan" onclick="setTool('pan')"
                style="height:22px;padding:2px 8px;font-size:9px;">Pan</button>
            </div>
            <div id="mixed-canvas-area">
              <canvas id="mixed-bg-canvas"></canvas>
              <canvas id="mixed-canvas"></canvas>
            </div>
          </div>
        </div>

      </div><!-- /editor-view -->

    </div><!-- /main -->

    <!-- ═══ BLITZ AI PANEL ═══ -->
    <div class="blitz-panel collapsed" id="blitz-panel">
      <div class="blitz-hdr">
        <div class="blitz-logo"><b>B.L.I.T.Z.</b> AI</div>
        <span class="blitz-badge">CANVAS</span>
        <button class="tb-btn ghost" onclick="toggleBlitz()" style="padding:3px 7px;font-size:11px;">✕</button>
      </div>
      <div class="blitz-quick">
        <button class="bq-btn" onclick="blitzAction('summarise')">Summarise</button>
        <button class="bq-btn" onclick="blitzAction('grammar')">Grammar</button>
        <button class="bq-btn" onclick="blitzAction('expand')">Expand</button>
        <button class="bq-btn" onclick="blitzAction('quiz')">Quiz Me</button>
        <button class="bq-btn" onclick="blitzAction('simplify')">Simplify</button>
        <button class="bq-btn" onclick="blitzAction('bullets')">Bullets</button>
      </div>
      <div class="send-note-btn">
        <button class="stb-btn" onclick="sendNoteToBlitz()">📋 Send current note to BLITZ</button>
      </div>
      <div class="blitz-feed" id="blitz-feed">
        <div class="b-msg b">
          <div class="b-who">BLITZ</div>
          <div class="b-bubble">Hey! I'm <b>B.L.I.T.Z.</b> — your AI writing assistant. Open a note, then use the quick
            actions or chat with me about your writing.</div>
        </div>
      </div>
      <div class="blitz-inp-area">
        <div class="b-inp-row">
          <textarea class="b-inp" id="blitz-input" placeholder="Ask BLITZ anything…" rows="1" oninput="autoGrow(this)"
            onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendBlitz();}"></textarea>
          <button class="b-send" onclick="sendBlitz()" title="Send">▶</button>
        </div>
      </div>
    </div>

  </div><!-- /layout -->

  <!-- ═══ READ MODE OVERLAY ═══ -->
  <div class="read-overlay" id="read-overlay">
    <div class="read-header">
      <button class="tb-btn" onclick="closeReadMode()" style="font-size:12px;">← Back to Editor</button>
      <div class="read-title" id="read-mode-title">—</div>
      <button class="tb-btn" onclick="closeReadMode()">✕ Close</button>
    </div>
    <div class="read-body" id="read-mode-body"></div>
  </div>

  <!-- ═══ GRAMMAR CHECK OVERLAY ═══ -->
  <div class="grammar-overlay" id="grammar-overlay" onclick="if(event.target===this)closeGrammar()">
    <div class="grammar-box">
      <div class="grammar-hd">
        <div class="grammar-title">✓ Grammar & Style Check</div>
        <button class="tb-btn ghost" onclick="closeGrammar()" style="padding:4px 8px;">✕</button>
      </div>
      <div class="grammar-body" id="grammar-body">
        <div class="grammar-loading">Select a note first to run grammar check.</div>
      </div>
      <div class="grammar-ft">
        <button class="modal-btn cancel" onclick="closeGrammar()">Close</button>
        <button class="modal-btn confirm" onclick="applyAllGrammarFixes()">Apply All Fixes</button>
      </div>
    </div>
  </div>

  <!-- ═══ ORGANISE OVERLAY ═══ -->
  <div class="organise-overlay" id="organise-overlay" onclick="if(event.target===this)closeOrganise()">
    <div class="organise-box">
      <div class="organise-hd">
        <div class="organise-title">📂 Organise Notes</div>
        <button class="tb-btn ghost" onclick="closeOrganise()" style="padding:4px 8px;">✕</button>
      </div>
      <div class="organise-body">
        <div class="organise-folders" id="organise-folders">
          <div class="org-label">FOLDERS</div>
        </div>
        <div class="organise-notes-col" id="organise-notes">
          <div class="org-label">NOTES</div>
        </div>
      </div>
    </div>
  </div>

  <!-- FORMAT BAR -->
  <div class="fmt-bar" id="fmt-bar">
    <button class="fb-btn" onclick="fmt('bold')"><b>B</b></button>
    <button class="fb-btn" onclick="fmt('italic')"><i>I</i></button>
    <button class="fb-btn" onclick="fmt('underline')" style="text-decoration:underline">U</button>
    <button class="fb-btn" onclick="fmt('strikeThrough')"><s>S</s></button>
    <div class="fb-sep"></div>
    <button class="fb-btn" onclick="fmtBlock('h1')">H1</button>
    <button class="fb-btn" onclick="fmtBlock('h2')">H2</button>
    <button class="fb-btn" onclick="fmtBlock('h3')">H3</button>
    <div class="fb-sep"></div>
    <button class="fb-btn" onclick="fmt('insertUnorderedList')">• list</button>
    <button class="fb-btn" onclick="fmt('insertOrderedList')">1.</button>
    <button class="fb-btn" onclick="doQuote()">❝</button>
    <div class="fb-sep"></div>
    <button class="fb-btn" onclick="doLink()">🔗</button>
  </div>

  <!-- SLASH MENU -->
  <div class="slash-menu" id="slash-menu">
    <input class="slash-search" id="slash-search" placeholder="Search blocks…" oninput="filterSlash(this.value)">
    <div id="slash-list"></div>
  </div>

  <!-- GRAPH -->
  <div class="graph-overlay" id="graph-overlay">
    <div class="graph-hd">
      <div class="graph-title">Note Graph</div>
      <button class="tb-btn" onclick="closeGraph()" style="margin-left:auto;">✕ Close</button>
    </div>
    <canvas id="graph-canvas"></canvas>
  </div>

  <!-- MAIN MODAL -->
  <div class="modal-overlay" id="modal-overlay" onclick="if(event.target===this)closeModal()">
    <div class="modal">
      <div class="modal-title" id="modal-title">—</div>
      <input type="text" class="modal-input" id="modal-input" onkeydown="if(event.key==='Enter')confirmModal()">
      <div class="modal-actions">
        <button class="modal-btn cancel" onclick="closeModal()">Cancel</button>
        <button class="modal-btn confirm" onclick="confirmModal()">OK</button>
      </div>
    </div>
  </div>

  <!-- CARD EDIT MODAL -->
  <div class="card-modal" id="card-modal" onclick="if(event.target===this)closeCardModal()">
    <div class="card-modal-body">
      <div class="cm-title" id="cm-title">Edit Card</div>
      <label class="cm-label">Title</label>
      <input type="text" class="cm-input" id="cm-card-title" placeholder="Card title…">
      <label class="cm-label">Description</label>
      <textarea class="cm-textarea" id="cm-card-desc" placeholder="Add a description…"></textarea>
      <label class="cm-label">Label color</label>
      <div class="cm-row" id="cm-colors">
        <div class="cm-color-btn sel" style="background:#6b7280;" data-color="#6b7280" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#dc2626;" data-color="#dc2626" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#d4580a;" data-color="#d4580a" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#ca8a04;" data-color="#ca8a04" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#16a34a;" data-color="#16a34a" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#2563eb;" data-color="#2563eb" onclick="selectCardColor(this)">
        </div>
        <div class="cm-color-btn" style="background:#7c3aed;" data-color="#7c3aed" onclick="selectCardColor(this)">
        </div>
      </div>
      <div class="cm-actions">
        <button class="cm-btn cancel" onclick="closeCardModal()">Cancel</button>
        <button class="cm-btn save" onclick="saveCard()">Save Card</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ═══════════════════════════════════════════════════════════
    //  THE CANVAS v3  —  GoodNotes-style + Functional Blocks
    //  Functional: Kanban (drag/drop/edit) · Code (highlight/run)
    //  Drawing: Pressure, scribble-erase, infinite canvas
    // ═══════════════════════════════════════════════════════════

    if (typeof pdfjsLib !== 'undefined')
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ─── STATE ───────────────────────────────────────────────────
    let notes = {}, folders = {}, activeNote = null;
    let currentMode = 'write';
    let modalCallback = null, toastTimer, saveTimer;

    // Draw
    let drawTool = 'pen', drawColor = '#1a1916', drawSize = 3;
    let isDrawing = false, isPanning = false;
    let currentStroke = null, startPt = null;
    let panStart = null, panVpStart = null;
    let drawData = {};   // noteId → { pages: [[stroke,...]], page: 0 }
    let undoStacks = {}, redoStacks = {};
    let viewports = {};  // noteId → { x, y, scale }
    let scribblePts = [], scribbleTimer = null;
    let palmOn = true;
    let drawingPointerId = null;
    let activePointers = new Map();
    let currentBg = 'grid';
    let mixVP = { x: 0, y: 0, scale: 1 };

    // Canvas refs
    let mainCvs, mainCtx, bgCvs, bgCtx, overlayCvs, overlayCtx;
    let mixCvs, mixCtx, mixBgCvs, mixBgCtx;

    // Kanban drag state
    let dragCard = null, dragCardData = null, dragGhost = null;
    let editingCardId = null, editingKanbanEl = null;
    let cardModalCb = null;

    // ── KANBAN EVENT DELEGATION ──────────────────────────────
    // All kanban clicks go through delegation to avoid contenteditable issues
    document.addEventListener('click', function (e) {
      // Add card button
      var addCardBtn = e.target.closest('.kanban-add-card');
      if (addCardBtn) {
        e.preventDefault(); e.stopPropagation();
        var col = addCardBtn.closest('.kanban-col');
        var wrap = addCardBtn.closest('.kanban-wrap');
        if (col && wrap) addKanbanCard(wrap.dataset.kbid, col.dataset.colid);
        return;
      }
      // Add column button
      var addColBtn = e.target.closest('.kanban-add-col-btn');
      if (addColBtn) {
        e.preventDefault(); e.stopPropagation();
        var wrap2 = addColBtn.closest('.kanban-wrap');
        if (wrap2) addKanbanCol(wrap2.dataset.kbid);
        return;
      }
      // Delete column
      var delColBtn = e.target.closest('.kanban-col-del');
      if (delColBtn) {
        e.preventDefault(); e.stopPropagation();
        var col2 = delColBtn.closest('.kanban-col');
        var wrap3 = delColBtn.closest('.kanban-wrap');
        if (col2 && wrap3) deleteKanbanCol(wrap3.dataset.kbid, col2.dataset.colid);
        return;
      }
      // Delete card
      var delCardBtn = e.target.closest('.kca-btn.del');
      if (delCardBtn) {
        e.preventDefault(); e.stopPropagation();
        var card = delCardBtn.closest('.kanban-card');
        var wrap4 = delCardBtn.closest('.kanban-wrap');
        if (card && wrap4) deleteKanbanCard(wrap4.dataset.kbid, card.dataset.colid, card.dataset.cardid);
        return;
      }
      // Edit card button
      var editCardBtn = e.target.closest('.kca-btn:not(.del)');
      if (editCardBtn) {
        e.preventDefault(); e.stopPropagation();
        var card2 = editCardBtn.closest('.kanban-card');
        var wrap5 = editCardBtn.closest('.kanban-wrap');
        if (card2 && wrap5) editKanbanCard(wrap5.dataset.kbid, card2.dataset.colid, card2.dataset.cardid);
        return;
      }
    }, true); // use capture phase

    // ─── SLASH BLOCKS ────────────────────────────────────────────
    const SLASH_BLOCKS = [
      { id: 'h1', icon: 'H₁', label: 'Heading 1', desc: 'Large heading', fn: () => fmtBlock('h1') },
      { id: 'h2', icon: 'H₂', label: 'Heading 2', desc: 'Medium heading', fn: () => fmtBlock('h2') },
      { id: 'h3', icon: 'H₃', label: 'Heading 3', desc: 'Small heading', fn: () => fmtBlock('h3') },
      { id: 'bullet', icon: '•', label: 'Bullet List', desc: 'Unordered list', fn: () => fmt('insertUnorderedList') },
      { id: 'numbered', icon: '1.', label: 'Numbered List', desc: 'Ordered list', fn: () => fmt('insertOrderedList') },
      { id: 'quote', icon: '❝', label: 'Blockquote', desc: 'Indented quote', fn: doQuote },
      { id: 'code', icon: '<>', label: 'Code Block', desc: 'Highlighted + runnable', fn: insertCodeBlock },
      { id: 'kanban', icon: '▦', label: 'Kanban Board', desc: 'Drag-drop task board', fn: insertKanban },
      { id: 'hr', icon: '─', label: 'Divider', desc: 'Horizontal rule', fn: () => { document.execCommand('insertHTML', false, '<hr>'); edFocus(); } },
      { id: 'wikilink', icon: '[[', label: 'Wiki Link', desc: 'Link to note', fn: doWikilink },
    ];

    // ═══════════════════════════════════════════════════════════
    //  STORAGE
    // ═══════════════════════════════════════════════════════════
    function save() {
      try {
        localStorage.setItem('cv3_notes', JSON.stringify(notes));
        // Strip large raster data before saving drawData
        const sd = {};
        for (const id in drawData) {
          sd[id] = {
            pages: drawData[id].pages.map(pg =>
              pg.filter(s => s.tool !== 'raster' && s.tool !== 'pdf_page')
            ),
            page: drawData[id].page
          };
        }
        localStorage.setItem('cv3_draw', JSON.stringify(sd));
        localStorage.setItem('cv3_vp', JSON.stringify(viewports));
        localStorage.setItem('cv3_folders', JSON.stringify(folders));
      } catch (e) { console.warn('storage full', e); }
    }
    function load() {
      try {
        const n = localStorage.getItem('cv3_notes');
        const d = localStorage.getItem('cv3_draw');
        const v = localStorage.getItem('cv3_vp');
        const f = localStorage.getItem('cv3_folders');
        if (n) notes = JSON.parse(n);
        if (d) drawData = JSON.parse(d);
        if (v) viewports = JSON.parse(v);
        if (f) folders = JSON.parse(f);
      } catch { }
    }

    // ═══════════════════════════════════════════════════════════
    //  INIT
    // ═══════════════════════════════════════════════════════════
    function init() {
      load();
      if (!Object.keys(notes).length) seedDefaults();
      renderNoteList(); updateStats();
      const ids = Object.keys(notes);
      if (ids.length) openNote(ids[0]);

      const ed = document.getElementById('editor');
      ed.addEventListener('input', onEditorInput);
      ed.addEventListener('mouseup', showFmtBar);
      ed.addEventListener('keyup', showFmtBar);
      ed.addEventListener('keydown', editorKey);
      document.getElementById('editor-mixed').addEventListener('input', onMixedInput);

      document.addEventListener('mousedown', e => {
        if (!document.getElementById('fmt-bar').contains(e.target)) hideFmtBar();
        if (!document.getElementById('slash-menu').contains(e.target)) closeSlash();
      });
      document.getElementById('slash-search').addEventListener('keydown', slashKeys);
      document.getElementById('b-inp-dummy')?.remove();
      document.addEventListener('keydown', globalKeys);

      initCanvases();
      buildSlashList(SLASH_BLOCKS);
      setupPdfDrop();

      if (window.innerWidth > 800) {
        document.getElementById('sidebar').classList.remove('hidden');
      }
    }

    function seedDefaults() {
      const id = createNote('Getting Started', `<h1>Welcome to Canvas v3</h1>
<p>This is a <strong>GoodNotes + Notion</strong> hybrid. Try the blocks below:</p>
<p>Type <code class="inline-code">/</code> anywhere to insert a block. The <strong>Kanban board</strong> and <strong>Code block</strong> are fully functional.</p>`, ['guide']);
    }

    // ═══════════════════════════════════════════════════════════
    //  NOTE CRUD
    // ═══════════════════════════════════════════════════════════
    function createNote(title = 'Untitled', content = '', tags = []) {
      const id = 'n_' + Date.now() + '_' + Math.random().toString(36).slice(2, 5);
      notes[id] = { id, title, content, tags, created: new Date().toISOString(), modified: new Date().toISOString(), hasDrawing: false, _wc: 0 };
      save(); return id;
    }
    function newNote() {
      const id = createNote();
      renderNoteList(); openNote(id);
      setTimeout(() => document.getElementById('note-title').select(), 60);
      toast('New note ✦', 'accent');
      if (window.innerWidth <= 800) closeSidebar();
    }
    function deleteNote(id, e) {
      e?.stopPropagation();
      if (Object.keys(notes).length <= 1) { toast('Cannot delete last note'); return; }
      if (!confirm(`Delete "${notes[id]?.title || 'note'}"?`)) return;
      delete notes[id]; delete drawData[id]; delete viewports[id]; save();
      if (activeNote === id) {
        activeNote = null;
        const rem = Object.keys(notes);
        if (rem.length) openNote(rem[0]);
        else {
          document.getElementById('editor-view').style.display = 'none';
          document.getElementById('empty-state').style.display = 'flex';
        }
      }
      renderNoteList(); updateStats();
    }

    // ═══════════════════════════════════════════════════════════
    //  OPEN NOTE
    // ═══════════════════════════════════════════════════════════
    function openNote(id) {
      if (!notes[id]) return;
      activeNote = id;
      const n = notes[id];
      document.getElementById('empty-state').style.display = 'none';
      document.getElementById('editor-view').style.display = 'flex';
      document.getElementById('note-title').value = n.title;
      document.getElementById('editor').innerHTML = n.content || '';
      document.getElementById('editor-mixed').innerHTML = n.contentMixed || '';
      document.getElementById('meta-date').textContent =
        new Date(n.modified).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      renderTagRow(n.tags);
      updateWordCount();
      document.getElementById('breadcrumb-title').textContent = n.title || 'Untitled';
      document.querySelectorAll('.sb-note').forEach(el => el.classList.toggle('active', el.dataset.id === id));

      if (!drawData[id]) drawData[id] = { pages: [[]], page: 0 };
      if (!undoStacks[id]) undoStacks[id] = [];
      if (!redoStacks[id]) redoStacks[id] = [];

      // Re-init code blocks + kanban in loaded content
      setTimeout(() => {
        initAllCodeBlocks();
        reattachAllKanbanEvents();
        renderPagesStrip();
        resizeAllCanvases();
        redrawMain();
        redrawBg();
        updateHUD();
      }, 50);

      setMode(currentMode);
      if (window.innerWidth <= 800) closeSidebar();
    }

    // ═══════════════════════════════════════════════════════════
    //  TITLE / CONTENT CHANGES
    // ═══════════════════════════════════════════════════════════
    function onTitleChange() {
      if (!activeNote) return;
      notes[activeNote].title = document.getElementById('note-title').value;
      notes[activeNote].modified = new Date().toISOString();
      document.getElementById('breadcrumb-title').textContent = notes[activeNote].title || 'Untitled';
      debounceSave(); renderNoteList();
    }
    function onEditorInput() {
      if (!activeNote) return;
      notes[activeNote].content = document.getElementById('editor').innerHTML;
      notes[activeNote].modified = new Date().toISOString();
      updateWordCount(); debounceSave();
    }
    function onMixedInput() {
      if (!activeNote) return;
      notes[activeNote].contentMixed = document.getElementById('editor-mixed').innerHTML;
      debounceSave();
    }
    function debounceSave() { clearTimeout(saveTimer); saveTimer = setTimeout(() => { save(); updateStats(); }, 700); }

    // ═══════════════════════════════════════════════════════════
    //  FUNCTIONAL CODE BLOCK
    // ═══════════════════════════════════════════════════════════
    const SUPPORTED_LANGS = ['javascript', 'python', 'html', 'css', 'json', 'typescript', 'bash', 'sql', 'markdown', 'plaintext'];

    function insertCodeBlock() {
      const cbId = 'cb_' + Date.now();
      const html = `<div class="code-block-wrap" data-cbid="${cbId}" contenteditable="false">
  <div class="code-block-header">
    <select class="code-lang-select" onchange="onLangChange(this,'${cbId}')">
      ${SUPPORTED_LANGS.map(l => `<option value="${l}"${l === 'javascript' ? ' selected' : ''}>${l}</option>`).join('')}
    </select>
    <span class="code-spacer"></span>
    <button class="code-run-btn" onclick="runCode('${cbId}')" title="Run (JS only)">▶ Run</button>
    <button class="code-copy-btn" onclick="copyCode('${cbId}')">Copy</button>
  </div>
  <textarea class="code-editor-area" id="codearea_${cbId}" placeholder="// Write code here…" onkeydown="codeKeydown(event,this)" oninput="onCodeInput('${cbId}')"></textarea>
  <div class="code-output" id="codeout_${cbId}">
    <div class="code-output-label">Output</div>
    <pre id="codepre_${cbId}"></pre>
  </div>
</div><p><br></p>`;

      edFocus();
      document.execCommand('insertHTML', false, html);
      setTimeout(() => {
        const ta = document.getElementById('codearea_' + cbId);
        if (ta) { ta.focus(); initCodeBlockHighlight(cbId); }
      }, 50);
    }

    function codeKeydown(e, ta) {
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = ta.selectionStart, end = ta.selectionEnd;
        ta.value = ta.value.substring(0, start) + '  ' + ta.value.substring(end);
        ta.selectionStart = ta.selectionEnd = start + 2;
      }
    }

    function onCodeInput(cbId) {
      // Save via editor content change
      if (activeNote) {
        notes[activeNote].content = document.getElementById('editor').innerHTML;
        debounceSave();
      }
    }

    function onLangChange(sel, cbId) {
      const lang = sel.value;
      const runBtn = sel.closest('.code-block-wrap')?.querySelector('.code-run-btn');
      if (runBtn) runBtn.style.display = lang === 'javascript' ? 'flex' : 'none';
    }

    function initCodeBlockHighlight(cbId) {
      // nothing extra needed for textarea-based editing
      const ta = document.getElementById('codearea_' + cbId);
      if (!ta) return;
      const sel = ta.closest('.code-block-wrap')?.querySelector('.code-lang-select');
      if (sel) onLangChange(sel, cbId);
    }

    function initAllCodeBlocks() {
      document.querySelectorAll('.code-block-wrap').forEach(wrap => {
        const cbId = wrap.dataset.cbid;
        if (cbId) {
          const sel = wrap.querySelector('.code-lang-select');
          if (sel) onLangChange(sel, cbId);
        }
      });
    }

    function runCode(cbId) {
      const ta = document.getElementById('codearea_' + cbId);
      const outEl = document.getElementById('codeout_' + cbId);
      const preEl = document.getElementById('codepre_' + cbId);
      if (!ta || !outEl || !preEl) return;

      const code = ta.value.trim();
      if (!code) { toast('Write some code first!'); return; }

      outEl.className = 'code-output show';
      preEl.textContent = '';

      const logs = [];
      const origConsole = { log: console.log, error: console.error, warn: console.warn, info: console.info };

      const capture = (...args) => {
        logs.push(args.map(a => {
          try { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }
          catch { return String(a); }
        }).join(' '));
      };

      console.log = capture;
      console.error = capture;
      console.warn = capture;
      console.info = capture;

      try {
        const result = new Function(code)();
        console.log = origConsole.log;
        console.error = origConsole.error;
        console.warn = origConsole.warn;
        console.info = origConsole.info;

        let output = logs.join('\n');
        if (result !== undefined) output += (output ? '\n' : '') + '→ ' + (typeof result === 'object' ? JSON.stringify(result, null, 2) : String(result));
        preEl.textContent = output || '(no output)';
        outEl.className = 'code-output show';
        toast('Ran ✓', 'green');
      } catch (err) {
        console.log = origConsole.log;
        console.error = origConsole.error;
        console.warn = origConsole.warn;
        console.info = origConsole.info;
        preEl.textContent = '⚠ ' + err.message;
        outEl.className = 'code-output show error';
      }
    }

    function copyCode(cbId) {
      const ta = document.getElementById('codearea_' + cbId);
      if (!ta) return;
      navigator.clipboard.writeText(ta.value).then(() => toast('Copied!')).catch(() => {
        const el = document.createElement('textarea');
        el.value = ta.value; document.body.appendChild(el);
        el.select(); document.execCommand('copy'); document.body.removeChild(el);
        toast('Copied!');
      });
    }

    // ═══════════════════════════════════════════════════════════
    //  FUNCTIONAL KANBAN BOARD
    // ═══════════════════════════════════════════════════════════
    const KANBAN_COLORS = ['#6b7280', '#dc2626', '#d4580a', '#ca8a04', '#16a34a', '#2563eb', '#7c3aed'];
    const COL_COLORS = ['#2563eb', '#ca8a04', '#16a34a', '#7c3aed', '#dc2626', '#0891b2'];

    function insertKanban() {
      const kbId = 'kb_' + Date.now();
      const defaultCols = [
        {
          id: 'col_1', name: 'To Do', color: '#6b7280', cards: [
            { id: 'card_1', title: 'Research topic', desc: '', color: '#6b7280' },
            { id: 'card_2', title: 'Plan outline', desc: '', color: '#6b7280' }
          ]
        },
        {
          id: 'col_2', name: 'In Progress', color: '#ca8a04', cards: [
            { id: 'card_3', title: 'Draft content', desc: 'Working on this now', color: '#ca8a04' }
          ]
        },
        {
          id: 'col_3', name: 'Done', color: '#16a34a', cards: [
            { id: 'card_4', title: 'Setup project', desc: '', color: '#16a34a' }
          ]
        }
      ];
      const html = renderKanbanHTML(kbId, 'My Board', defaultCols);
      edFocus();
      document.execCommand('insertHTML', false, html + '<p><br></p>');
      setTimeout(function () { attachKanbanDragEvents(kbId); }, 80);
    }

    function renderKanbanHTML(kbId, boardTitle, cols) {
      var colsHtml = cols.map(function (col) {
        return '<div class="kanban-col" id="kcol_' + col.id + '" data-colid="' + col.id + '" data-kbid="' + kbId + '">' +
          '<div class="kanban-col-header">' +
          '<div class="kanban-col-dot" style="background:' + col.color + '"></div>' +
          '<input class="kanban-col-name" value="' + esc(col.name) + '" style="color:' + col.color + '">' +
          '<span class="kanban-col-count">' + col.cards.length + '</span>' +
          '<button class="kanban-col-del" title="Delete column">\u2715</button>' +
          '</div>' +
          '<div class="kanban-cards" id="kcards_' + col.id + '" data-colid="' + col.id + '" data-kbid="' + kbId + '"></div>' +
          '<button class="kanban-add-card">\uff0b Add card</button>' +
          '</div>';
      }).join('');

      // Render cards separately after inserting cols
      var result = '<div class="kanban-wrap" data-kbid="' + kbId + '" contenteditable="false">' +
        '<div class="kanban-header">' +
        '<input class="kanban-board-title" value="' + esc(boardTitle) + '">' +
        '<button class="kanban-add-col-btn">\uff0b Column</button>' +
        '</div>' +
        '<div class="kanban-cols" id="kboard_' + kbId + '">' + colsHtml + '</div>' +
        '</div>';

      // We'll populate cards after DOM insertion
      setTimeout(function () {
        cols.forEach(function (col) {
          var dest = document.getElementById('kcards_' + col.id);
          if (dest) {
            col.cards.forEach(function (card) {
              dest.insertAdjacentHTML('beforeend', renderCardHTML(kbId, col.id, card));
            });
          }
        });
        attachKanbanDragEvents(kbId);
      }, 100);

      return result;
    }

    function renderCardHTML(kbId, colId, card) {
      var descHtml = card.desc ? '<div class="kanban-card-desc">' + esc(card.desc) + '</div>' : '';
      var colName = getColName(kbId, colId) || '\u2014';
      return '<div class="kanban-card" id="kcard_' + card.id + '" draggable="true" ' +
        'data-cardid="' + card.id + '" data-colid="' + colId + '" data-kbid="' + kbId + '">' +
        '<div class="kanban-card-title">' + esc(card.title) + '</div>' +
        descHtml +
        '<div class="kanban-card-meta">' +
        '<div class="kanban-card-tag" style="background:' + card.color + '22;color:' + card.color + ';border:1px solid ' + card.color + '44;">' + colName + '</div>' +
        '<div class="kanban-card-actions">' +
        '<button class="kca-btn edit-btn">Edit</button>' +
        '<button class="kca-btn del">\u2715</button>' +
        '</div>' +
        '</div>' +
        '</div>';
    }

    function getKanbanData(kbId) {
      var board = document.getElementById('kboard_' + kbId);
      if (!board) return null;
      var cols = [];
      board.querySelectorAll('.kanban-col').forEach(function (colEl) {
        var colId = colEl.dataset.colid;
        var nameInput = colEl.querySelector('.kanban-col-name');
        var dotEl = colEl.querySelector('.kanban-col-dot');
        var cards = [];
        colEl.querySelectorAll('.kanban-card').forEach(function (cardEl) {
          cards.push({
            id: cardEl.dataset.cardid,
            title: cardEl.querySelector('.kanban-card-title')?.textContent || '',
            desc: cardEl.querySelector('.kanban-card-desc')?.textContent || '',
            color: cardEl.querySelector('.kanban-card-tag')?.style.color || '#6b7280'
          });
        });
        cols.push({ id: colId, name: nameInput?.value || '', color: dotEl?.style.background || '#6b7280', cards: cards });
      });
      return cols;
    }

    function getColName(kbId, colId) {
      var colEl = document.getElementById('kcol_' + colId);
      return colEl?.querySelector('.kanban-col-name')?.value || '';
    }

    // ── Drag and Drop (with same-column reorder) ──────────────
    function attachKanbanDragEvents(kbId) {
      var board = document.getElementById('kboard_' + kbId);
      if (!board) return;
      // Attach drag events via event delegation on the board
      board.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        // Show drop position within column
        var cardsContainer = e.target.closest('.kanban-cards');
        if (cardsContainer && dragCard) {
          var afterEl = getDragAfterElement(cardsContainer, e.clientY);
          var ghost = document.querySelector('.kanban-card-ghost');
          if (!ghost) {
            ghost = document.createElement('div');
            ghost.className = 'kanban-card-ghost';
            ghost.style.height = '4px';
            ghost.style.borderRadius = '2px';
            ghost.style.background = 'var(--accent, #2563eb)';
            ghost.style.margin = '4px 0';
            ghost.style.transition = 'all .1s';
          }
          if (afterEl) cardsContainer.insertBefore(ghost, afterEl);
          else cardsContainer.appendChild(ghost);
        }
      });
      board.addEventListener('dragenter', function (e) {
        e.preventDefault();
        var col = e.target.closest('.kanban-col');
        if (col) {
          document.querySelectorAll('.kanban-col.drag-over').forEach(function (el) { el.classList.remove('drag-over'); });
          col.classList.add('drag-over');
        }
      });
      board.addEventListener('dragleave', function (e) {
        var col = e.target.closest('.kanban-col');
        if (col && !col.contains(e.relatedTarget)) col.classList.remove('drag-over');
      });
      board.addEventListener('drop', function (e) {
        e.preventDefault();
        document.querySelectorAll('.kanban-card-ghost').forEach(function (g) { g.remove(); });
        if (!dragCard) return;
        var cardsContainer = e.target.closest('.kanban-cards');
        if (!cardsContainer) { cleanupDrag(); return; }
        var toColId = cardsContainer.dataset.colid;
        var fromColId = dragCard.colId;
        var cardId = dragCard.cardId;
        var cardEl = document.getElementById('kcard_' + cardId);
        if (!cardEl) { cleanupDrag(); return; }

        // Determine insertion point
        var afterEl = getDragAfterElement(cardsContainer, e.clientY);

        // Move the actual card element (preserves all state)
        if (afterEl) cardsContainer.insertBefore(cardEl, afterEl);
        else cardsContainer.appendChild(cardEl);

        // Update card data attributes
        cardEl.dataset.colid = toColId;
        cardEl.dataset.kbid = kbId;

        // Update tag text to show new column name
        var tagEl = cardEl.querySelector('.kanban-card-tag');
        if (tagEl) tagEl.textContent = getColName(kbId, toColId) || '\u2014';

        // Update counts
        updateColCount(kbId, fromColId);
        updateColCount(kbId, toColId);

        cleanupDrag();
        kanbanPersist();
        if (fromColId !== toColId) toast('Card moved \u2192');
      });
    }

    function getDragAfterElement(container, y) {
      var elements = Array.from(container.querySelectorAll('.kanban-card:not(.dragging)'));
      var closest = null, closestOffset = Number.NEGATIVE_INFINITY;
      elements.forEach(function (child) {
        var box = child.getBoundingClientRect();
        var offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closestOffset) {
          closestOffset = offset;
          closest = child;
        }
      });
      return closest;
    }

    function cleanupDrag() {
      document.querySelectorAll('.kanban-col.drag-over').forEach(function (el) { el.classList.remove('drag-over'); });
      document.querySelectorAll('.kanban-card-ghost').forEach(function (el) { el.remove(); });
      if (dragCard) {
        var cardEl = document.getElementById('kcard_' + dragCard.cardId);
        if (cardEl) cardEl.classList.remove('dragging');
      }
      dragCard = null;
    }

    // Global drag start/end (these are still needed for inline ondragstart)
    function kanbanDragStart(e, kbId, colId, cardId) {
      dragCard = { kbId: kbId, colId: colId, cardId: cardId };
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', cardId);
      setTimeout(function () {
        var cardEl = document.getElementById('kcard_' + cardId);
        if (cardEl) cardEl.classList.add('dragging');
      }, 0);
    }
    function kanbanDragEnd(e) { cleanupDrag(); }
    // Legacy compat (inline handlers from saved HTML)
    function kanbanDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function kanbanDragEnter(e, kbId, colId) {
      e.preventDefault();
      document.querySelectorAll('.kanban-col.drag-over').forEach(function (el) { el.classList.remove('drag-over'); });
      document.getElementById('kcol_' + colId)?.classList.add('drag-over');
    }
    function kanbanDragLeave(e, colId) {
      var col = document.getElementById('kcol_' + colId);
      if (col && !col.contains(e.relatedTarget)) col.classList.remove('drag-over');
    }
    function kanbanDrop(e, kbId, toColId) {
      e.preventDefault();
      if (!dragCard) return;
      var cardId = dragCard.cardId;
      var fromColId = dragCard.colId;
      var cardEl = document.getElementById('kcard_' + cardId);
      if (!cardEl) { cleanupDrag(); return; }
      var dest = document.getElementById('kcards_' + toColId);
      if (!dest) { cleanupDrag(); return; }
      var afterEl = getDragAfterElement(dest, e.clientY);
      if (afterEl) dest.insertBefore(cardEl, afterEl);
      else dest.appendChild(cardEl);
      cardEl.dataset.colid = toColId;
      var tagEl = cardEl.querySelector('.kanban-card-tag');
      if (tagEl) tagEl.textContent = getColName(kbId, toColId) || '\u2014';
      updateColCount(kbId, fromColId);
      updateColCount(kbId, toColId);
      cleanupDrag();
      kanbanPersist();
      if (fromColId !== toColId) toast('Card moved \u2192');
    }

    function updateColCount(kbId, colId) {
      var colEl = document.getElementById('kcol_' + colId);
      if (!colEl) return;
      var count = colEl.querySelectorAll('.kanban-card').length;
      var countEl = colEl.querySelector('.kanban-col-count');
      if (countEl) countEl.textContent = count;
    }

    function kanbanPersist() {
      if (activeNote) { notes[activeNote].content = document.getElementById('editor').innerHTML; debounceSave(); }
    }

    function addKanbanCard(kbId, colId) {
      var cardId = 'card_' + Date.now();
      openCardModal('New Card', kbId, colId, cardId, null, function (cardData) {
        var card = { id: cardId, title: cardData.title, desc: cardData.desc, color: cardData.color };
        var html = renderCardHTML(kbId, colId, card);
        var dest = document.getElementById('kcards_' + colId);
        if (dest) {
          dest.insertAdjacentHTML('beforeend', html);
          // Re-attach drag events for new card
          var newCard = document.getElementById('kcard_' + cardId);
          if (newCard) {
            newCard.setAttribute('ondragstart', "kanbanDragStart(event,'" + kbId + "','" + colId + "','" + cardId + "')");
            newCard.setAttribute('ondragend', 'kanbanDragEnd(event)');
          }
        }
        updateColCount(kbId, colId);
        kanbanPersist();
        toast('Card added');
      });
    }

    function editKanbanCard(kbId, colId, cardId) {
      var cardEl = document.getElementById('kcard_' + cardId);
      if (!cardEl) return;
      var title = cardEl.querySelector('.kanban-card-title')?.textContent || '';
      var desc = cardEl.querySelector('.kanban-card-desc')?.textContent || '';
      var tagEl = cardEl.querySelector('.kanban-card-tag');
      var color = tagEl ? tagEl.style.color : '#6b7280';

      openCardModal('Edit Card', kbId, colId, cardId, { title: title, desc: desc, color: color }, function (cardData) {
        var titleEl = cardEl.querySelector('.kanban-card-title');
        if (titleEl) titleEl.textContent = cardData.title;
        var descEl = cardEl.querySelector('.kanban-card-desc');
        if (cardData.desc) {
          if (!descEl) {
            descEl = document.createElement('div');
            descEl.className = 'kanban-card-desc';
            titleEl.after(descEl);
          }
          descEl.textContent = cardData.desc;
        } else if (descEl) descEl.remove();
        if (tagEl) {
          tagEl.style.background = cardData.color + '22';
          tagEl.style.color = cardData.color;
          tagEl.style.borderColor = cardData.color + '44';
        }
        kanbanPersist();
        toast('Card updated');
      });
    }

    function deleteKanbanCard(kbId, colId, cardId) {
      var cardEl = document.getElementById('kcard_' + cardId);
      if (!cardEl) return;
      cardEl.remove();
      updateColCount(kbId, colId);
      kanbanPersist();
      toast('Card deleted');
    }

    function addKanbanCol(kbId) {
      var colId = 'col_' + Date.now();
      var existingCols = document.querySelectorAll('[data-kbid="' + kbId + '"] .kanban-col').length;
      var color = COL_COLORS[existingCols % COL_COLORS.length];
      var html = '<div class="kanban-col" id="kcol_' + colId + '" data-colid="' + colId + '" data-kbid="' + kbId + '">' +
        '<div class="kanban-col-header">' +
        '<div class="kanban-col-dot" style="background:' + color + '"></div>' +
        '<input class="kanban-col-name" value="New Column" style="color:' + color + '">' +
        '<span class="kanban-col-count">0</span>' +
        '<button class="kanban-col-del" title="Delete column">\u2715</button>' +
        '</div>' +
        '<div class="kanban-cards" id="kcards_' + colId + '" data-colid="' + colId + '" data-kbid="' + kbId + '"></div>' +
        '<button class="kanban-add-card">\uff0b Add card</button>' +
        '</div>';
      var board = document.getElementById('kboard_' + kbId);
      if (board) {
        board.insertAdjacentHTML('beforeend', html);
        // Focus the new column name input
        var newCol = document.getElementById('kcol_' + colId);
        if (newCol) {
          var nameInput = newCol.querySelector('.kanban-col-name');
          if (nameInput) { nameInput.focus(); nameInput.select(); }
        }
      }
      kanbanPersist();
      toast('Column added');
    }

    function deleteKanbanCol(kbId, colId) {
      var cards = document.querySelectorAll('#kcards_' + colId + ' .kanban-card').length;
      if (cards > 0 && !confirm('Delete column with ' + cards + ' card(s)?')) return;
      document.getElementById('kcol_' + colId)?.remove();
      kanbanPersist();
      toast('Column deleted');
    }

    function onColNameChange(kbId, colId, newName) {
      document.querySelectorAll('#kcards_' + colId + ' .kanban-card-tag').forEach(function (el) {
        el.textContent = newName;
      });
      kanbanPersist();
    }

    function onBoardTitleChange(kbId, newTitle) {
      kanbanPersist();
    }

    // Re-attach events when loading saved kanban boards
    function attachKanbanEvents(kbId) {
      attachKanbanDragEvents(kbId);
    }

    // Re-attach for all boards on page load
    function reattachAllKanbanEvents() {
      document.querySelectorAll('.kanban-wrap').forEach(function (wrap) {
        var kbId = wrap.dataset.kbid;
        if (kbId) attachKanbanDragEvents(kbId);
      });
    }

    // Card Modal
    function openCardModal(title, kbId, colId, cardId, existing, cb) {
      document.getElementById('cm-title').textContent = title;
      document.getElementById('cm-card-title').value = existing?.title || '';
      document.getElementById('cm-card-desc').value = existing?.desc || '';
      // Select color
      document.querySelectorAll('.cm-color-btn').forEach(btn => {
        btn.classList.toggle('sel', btn.dataset.color === (existing?.color || '#6b7280'));
      });
      cardModalCb = cb;
      document.getElementById('card-modal').classList.add('open');
      setTimeout(() => document.getElementById('cm-card-title').focus(), 50);
    }
    function closeCardModal() {
      document.getElementById('card-modal').classList.remove('open');
      cardModalCb = null;
    }
    function selectCardColor(btn) {
      document.querySelectorAll('.cm-color-btn').forEach(b => b.classList.remove('sel'));
      btn.classList.add('sel');
    }
    function saveCard() {
      var title = document.getElementById('cm-card-title').value.trim();
      if (!title) { document.getElementById('cm-card-title').focus(); return; }
      var desc = document.getElementById('cm-card-desc').value.trim();
      var colorBtn = document.querySelector('.cm-color-btn.sel');
      var color = colorBtn?.dataset.color || '#6b7280';
      // IMPORTANT: grab callback BEFORE closeCardModal nullifies it
      var cb = cardModalCb;
      closeCardModal();
      if (cb) cb({ title: title, desc: desc, color: color });
    }
    // Enter key submits the card modal
    document.getElementById('cm-card-title').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') { e.preventDefault(); saveCard(); }
    });

    // ═══════════════════════════════════════════════════════════
    //  FORMAT / SLASH
    // ═══════════════════════════════════════════════════════════
    function edFocus() { document.getElementById('editor').focus(); }
    function fmt(cmd) { document.execCommand(cmd, false, null); edFocus(); }
    function fmtBlock(tag) { document.execCommand('formatBlock', false, tag); edFocus(); }
    function doQuote() { document.execCommand('formatBlock', false, 'blockquote'); edFocus(); }
    function doLink() {
      const sel = window.getSelection();
      if (!sel.toString()) return;
      const url = prompt('Enter URL:');
      if (url) document.execCommand('createLink', false, url);
    }
    function doWikilink() {
      openModal('Link to Note', 'Note title…', name => {
        if (!name.trim()) return;
        edFocus();
        document.execCommand('insertHTML', false,
          `<span class="wikilink" onclick="openByTitle('${esc(name)}')">${esc(name)}</span>&nbsp;`);
      });
    }
    function openByTitle(title) {
      const m = Object.values(notes).find(n => n.title.toLowerCase() === title.toLowerCase());
      if (m) { openNote(m.id); toast(`→ ${title}`); }
      else toast(`Note "${title}" not found`);
    }

    let slashFiltered = [...SLASH_BLOCKS], slashFocus = 0, slashOpen = false;

    function buildSlashList(list) {
      document.getElementById('slash-list').innerHTML = list.map((b, i) => `
    <div class="slash-item${i === slashFocus ? ' focus' : ''}" onclick="execSlash('${b.id}')">
      <span class="slash-icon">${b.icon}</span>
      <div><div class="slash-label">${b.label}</div><div class="slash-desc">${b.desc}</div></div>
    </div>`).join('');
    }
    function filterSlash(q) {
      slashFiltered = SLASH_BLOCKS.filter(b => b.label.toLowerCase().includes(q.toLowerCase()));
      slashFocus = 0; buildSlashList(slashFiltered);
    }
    function openSlash() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const rect = sel.getRangeAt(0).getBoundingClientRect();
      const m = document.getElementById('slash-menu');
      m.style.left = Math.max(8, rect.left) + 'px';
      m.style.top = (rect.bottom + 5) + 'px';
      m.classList.add('open'); slashOpen = true;
      document.getElementById('slash-search').value = '';
      slashFiltered = [...SLASH_BLOCKS]; slashFocus = 0; buildSlashList(slashFiltered);
      document.getElementById('slash-search').focus();
      document.execCommand('delete', false, null);
    }
    function closeSlash() { document.getElementById('slash-menu').classList.remove('open'); slashOpen = false; }
    function slashKeys(e) {
      if (e.key === 'ArrowDown') { slashFocus = (slashFocus + 1) % Math.max(1, slashFiltered.length); buildSlashList(slashFiltered); e.preventDefault(); }
      else if (e.key === 'ArrowUp') { slashFocus = (slashFocus - 1 + Math.max(1, slashFiltered.length)) % Math.max(1, slashFiltered.length); buildSlashList(slashFiltered); e.preventDefault(); }
      else if (e.key === 'Enter') { if (slashFiltered[slashFocus]) execSlash(slashFiltered[slashFocus].id); e.preventDefault(); }
      else if (e.key === 'Escape') closeSlash();
    }
    function execSlash(id) {
      closeSlash(); edFocus();
      const b = SLASH_BLOCKS.find(x => x.id === id);
      if (b) b.fn();
    }
    function editorKey(e) {
      if (e.key === '/' && !slashOpen) { setTimeout(openSlash, 30); return; }
      if (e.key === 'Escape') closeSlash();
      if (e.key === ' ' || e.key === 'Enter') checkMdTriggers();
    }
    function checkMdTriggers() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const node = sel.getRangeAt(0).startContainer;
      const txt = (node.textContent || '').trim();
      const map = { '#': 'h1', '##': 'h2', '###': 'h3', '>': 'blockquote', '>>': 'blockquote' };
      const tag = map[txt] || map[txt.slice(0, -1)];
      if (tag) { document.execCommand('formatBlock', false, tag); try { node.textContent = ''; } catch { } }
      if (txt === '-' || txt === '*') { document.execCommand('insertUnorderedList'); try { node.textContent = ''; } catch { } }
    }

    function showFmtBar() {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed || !sel.toString().trim()) { hideFmtBar(); return; }
      const tb = document.getElementById('fmt-bar');
      const rect = sel.getRangeAt(0).getBoundingClientRect();
      const tw = 440;
      let left = rect.left + rect.width / 2 - tw / 2;
      let top = rect.top - 46 + window.scrollY;
      left = Math.max(8, Math.min(innerWidth - tw - 8, left));
      if (top < 8) top = rect.bottom + 8;
      tb.style.left = left + 'px'; tb.style.top = top + 'px'; tb.style.width = tw + 'px';
      tb.classList.add('visible');
    }
    function hideFmtBar() { document.getElementById('fmt-bar').classList.remove('visible'); }

    // ═══════════════════════════════════════════════════════════
    //  WORD COUNT
    // ═══════════════════════════════════════════════════════════
    function updateWordCount() {
      const el = document.getElementById('editor');
      const txt = el.innerText || '';
      const w = txt.trim() ? txt.trim().split(/\s+/).length : 0;
      document.getElementById('wc-words').textContent = w.toLocaleString();
      document.getElementById('wc-chars').textContent = txt.length.toLocaleString();
      document.getElementById('meta-wc').textContent = `${w} word${w !== 1 ? 's' : ''}`;
      if (activeNote) notes[activeNote]._wc = w;
    }

    // ═══════════════════════════════════════════════════════════
    //  DRAWING ENGINE — GoodNotes feel
    // ═══════════════════════════════════════════════════════════
    function initCanvases() {
      mainCvs = document.getElementById('draw-canvas');
      mainCtx = mainCvs.getContext('2d');
      bgCvs = document.getElementById('bg-canvas');
      bgCtx = bgCvs.getContext('2d');
      overlayCvs = document.getElementById('overlay-canvas');
      overlayCtx = overlayCvs.getContext('2d');
      mixCvs = document.getElementById('mixed-canvas');
      mixCtx = mixCvs.getContext('2d');
      mixBgCvs = document.getElementById('mixed-bg-canvas');
      mixBgCtx = mixBgCvs.getContext('2d');

      const ca = document.getElementById('canvas-area');
      const mca = document.getElementById('mixed-canvas-area');

      new ResizeObserver(() => { resizeCanvas(mainCvs, ca); resizeCanvas(bgCvs, ca); resizeCanvas(overlayCvs, ca); redrawMain(); redrawBg(); }).observe(ca);
      new ResizeObserver(() => { resizeCanvas(mixCvs, mca); resizeCanvas(mixBgCvs, mca); redrawMix(); redrawMixBg(); }).observe(mca);

      resizeAllCanvases();
      setupPointerEvents(ca, 'main');
      setupPointerEvents(mca, 'mixed');
      setupPinch(ca, 'main');
      setupPinch(mca, 'mixed');

      ca.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          const vp = getVP();
          const rect = ca.getBoundingClientRect();
          zoomAtPt(e.clientX - rect.left, e.clientY - rect.top, e.deltaY < 0 ? 1.1 : 1 / 1.1, 'main');
        } else {
          const vp = getVP();
          vp.x -= e.deltaX; vp.y -= e.deltaY;
          redrawMain(); redrawBg(); updateHUD();
        }
      }, { passive: false });
    }

    function resizeCanvas(cvs, wrap) {
      if (!cvs || !wrap) return;
      const { width: w, height: h } = wrap.getBoundingClientRect();
      if (w > 0 && h > 0) { cvs.width = w; cvs.height = h; }
    }
    function resizeAllCanvases() {
      const ca = document.getElementById('canvas-area');
      const mca = document.getElementById('mixed-canvas-area');
      if (ca) { resizeCanvas(mainCvs, ca); resizeCanvas(bgCvs, ca); resizeCanvas(overlayCvs, ca); }
      if (mca) { resizeCanvas(mixCvs, mca); resizeCanvas(mixBgCvs, mca); }
      redrawMain(); redrawBg(); redrawMix(); redrawMixBg();
    }

    function getVP(which = 'main') {
      if (!activeNote) return { x: 0, y: 0, scale: 1 };
      const key = activeNote + '_' + which;
      if (!viewports[key]) viewports[key] = { x: 0, y: 0, scale: 1 };
      return viewports[key];
    }

    function setupPinch(wrap, vk) {
      let lastDist = null, lastMX = 0, lastMY = 0;
      wrap.addEventListener('touchstart', e => { if (e.touches.length === 2) { lastDist = null; e.preventDefault(); } }, { passive: false });
      wrap.addEventListener('touchmove', e => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const t0 = e.touches[0], t1 = e.touches[1];
          const rect = wrap.getBoundingClientRect();
          const dx = t0.clientX - t1.clientX, dy = t0.clientY - t1.clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mx = (t0.clientX + t1.clientX) / 2 - rect.left;
          const my = (t0.clientY + t1.clientY) / 2 - rect.top;
          if (lastDist !== null) {
            zoomAtPt(mx, my, dist / lastDist, vk);
            const vp = getVP(vk);
            vp.x += mx - lastMX; vp.y += my - lastMY;
          }
          lastDist = dist; lastMX = mx; lastMY = my;
          if (vk === 'main') { redrawMain(); redrawBg(); updateHUD(); } else { redrawMix(); redrawMixBg(); }
        }
      }, { passive: false });
      wrap.addEventListener('touchend', e => { if (e.touches.length < 2) lastDist = null; });
    }

    function zoomAtPt(sx, sy, factor, vk = 'main') {
      const vp = getVP(vk);
      const minS = 0.05, maxS = 20;
      const ns = Math.max(minS, Math.min(maxS, vp.scale * factor));
      const af = ns / vp.scale;
      vp.x = sx - af * (sx - vp.x);
      vp.y = sy - af * (sy - vp.y);
      vp.scale = ns;
      if (vk === 'main') { document.getElementById('hud-zoom').textContent = Math.round(ns * 100) + '%'; updateHUD(); }
    }

    function zoomStep(d) {
      const ca = document.getElementById('canvas-area');
      const r = ca.getBoundingClientRect();
      zoomAtPt(r.width / 2, r.height / 2, d > 0 ? 1 + d : 1 / (1 - d), 'main');
      redrawMain(); redrawBg();
    }

    function resetViewport() {
      if (!activeNote) return;
      const vp = getVP('main');
      vp.x = 0; vp.y = 0; vp.scale = 1;
      document.getElementById('hud-zoom').textContent = '100%';
      redrawMain(); redrawBg(); updateHUD();
      toast('View reset');
    }

    function fitToContent() {
      if (!activeNote || !drawData[activeNote]) return;
      const allStrokes = drawData[activeNote].pages.flat();
      if (!allStrokes.length) { resetViewport(); return; }
      let x1 = Infinity, y1 = Infinity, x2 = -Infinity, y2 = -Infinity;
      allStrokes.forEach(s => {
        if (s.pts) s.pts.forEach(p => { x1 = Math.min(x1, p.x); y1 = Math.min(y1, p.y); x2 = Math.max(x2, p.x); y2 = Math.max(y2, p.y); });
        if (s.start) { x1 = Math.min(x1, s.start.x, s.end.x); y1 = Math.min(y1, s.start.y, s.end.y); x2 = Math.max(x2, s.start.x, s.end.x); y2 = Math.max(y2, s.start.y, s.end.y); }
        if (s.x != null) { x1 = Math.min(x1, s.x); y1 = Math.min(y1, s.y); x2 = Math.max(x2, s.x + (s.w || 0)); y2 = Math.max(y2, s.y + (s.h || 0)); }
      });
      const ca = document.getElementById('canvas-area');
      const ww = ca.clientWidth, wh = ca.clientHeight;
      const pad = 60;
      const s = Math.min((ww - pad * 2) / Math.max(x2 - x1, 1), (wh - pad * 2) / Math.max(y2 - y1, 1), 2);
      const vp = getVP('main');
      vp.scale = s;
      vp.x = (ww - (x2 - x1) * s) / 2 - x1 * s;
      vp.y = (wh - (y2 - y1) * s) / 2 - y1 * s;
      document.getElementById('hud-zoom').textContent = Math.round(s * 100) + '%';
      redrawMain(); redrawBg(); updateHUD();
      toast('Fitted ✓', 'accent');
    }

    function updateHUD() {
      if (!activeNote) return;
      const vp = getVP('main');
      document.getElementById('hud-zoom').textContent = Math.round(vp.scale * 100) + '%';
      const strokeCount = drawData[activeNote]?.pages?.[drawData[activeNote].page || 0]?.length || 0;
      document.getElementById('hud-strokes').textContent = strokeCount;
      document.getElementById('hud-size').textContent = drawSize + 'px';
      document.getElementById('hud-tool').textContent = drawTool.charAt(0).toUpperCase() + drawTool.slice(1);
    }

    // ─── POINTER EVENTS (Palm rejection + pressure) ──────────────
    function setupPointerEvents(wrap, vk) {
      wrap.addEventListener('pointerdown', e => {
        e.preventDefault();
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType, w: e.width || 1, h: e.height || 1 });

        // Palm rejection: large touch area = palm
        if (palmOn && e.pointerType === 'touch') {
          if (e.width > 40 || e.height > 40) { activePointers.delete(e.pointerId); return; }
          // If stylus already drawing, ignore additional touches
          if (drawingPointerId !== null) {
            const dp = activePointers.get(drawingPointerId);
            if (dp && dp.type === 'pen') { activePointers.delete(e.pointerId); return; }
          }
        }

        // 2-finger pan (touch)
        const touches = [...activePointers.values()].filter(p => p.type === 'touch');
        if (touches.length >= 2) {
          if (isDrawing && drawingPointerId) endDraw(e, vk);
          drawingPointerId = null; return;
        }

        if (drawTool === 'pan') {
          isPanning = true;
          const vp = getVP(vk);
          panStart = { x: e.clientX, y: e.clientY };
          panVpStart = { x: vp.x, y: vp.y };
          drawingPointerId = e.pointerId;
          try { wrap.querySelector('#draw-canvas, #mixed-canvas, canvas')?.setPointerCapture?.(e.pointerId); } catch { }
          return;
        }

        drawingPointerId = e.pointerId;
        try {
          const cvs = vk === 'main' ? mainCvs : mixCvs;
          cvs?.setPointerCapture(e.pointerId);
        } catch { }
        startDraw(e, vk);
      }, { passive: false });

      wrap.addEventListener('pointermove', e => {
        e.preventDefault();
        if (activePointers.has(e.pointerId)) {
          activePointers.set(e.pointerId, { ...activePointers.get(e.pointerId), x: e.clientX, y: e.clientY });
        }

        // Update custom cursors
        if (drawTool === 'eraser' || drawTool === 'scribble') {
          const rect = wrap.getBoundingClientRect();
          const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
          const cursId = drawTool === 'eraser' ? 'eraser-cursor' : 'scribble-cursor';
          const curs = document.getElementById(cursId);
          if (curs) { curs.style.left = cx + 'px'; curs.style.top = cy + 'px'; curs.style.display = 'block'; }
        }

        if (isPanning && e.pointerId === drawingPointerId) {
          const vp = getVP(vk);
          vp.x = panVpStart.x + (e.clientX - panStart.x);
          vp.y = panVpStart.y + (e.clientY - panStart.y);
          if (vk === 'main') { redrawMain(); redrawBg(); updateHUD(); } else { redrawMix(); redrawMixBg(); }
          return;
        }
        if (!isDrawing || e.pointerId !== drawingPointerId) return;
        moveDraw(e, vk);
      }, { passive: false });

      const endHandler = e => {
        e.preventDefault();
        activePointers.delete(e.pointerId);
        ['eraser-cursor', 'scribble-cursor'].forEach(id => {
          const c = document.getElementById(id); if (c) c.style.display = 'none';
        });
        if (isPanning && e.pointerId === drawingPointerId) {
          isPanning = false; drawingPointerId = null;
          const ca = document.getElementById('canvas-area');
          ca.classList.remove('panning'); return;
        }
        if (e.pointerId === drawingPointerId) {
          endDraw(e, vk); drawingPointerId = null;
        }
      };

      wrap.addEventListener('pointerup', endHandler, { passive: false });
      wrap.addEventListener('pointercancel', endHandler, { passive: false });
      wrap.addEventListener('pointerleave', () => {
        ['eraser-cursor', 'scribble-cursor'].forEach(id => {
          const c = document.getElementById(id); if (c) c.style.display = 'none';
        });
      });
    }

    function screenToWorld(sx, sy, vk = 'main') {
      const vp = getVP(vk);
      return { x: (sx - vp.x) / vp.scale, y: (sy - vp.y) / vp.scale };
    }

    function getPt(e, vk = 'main') {
      const wrap = document.getElementById(vk === 'main' ? 'canvas-area' : 'mixed-canvas-area');
      const r = wrap.getBoundingClientRect();
      return screenToWorld(e.clientX - r.left, e.clientY - r.top, vk);
    }

    // GoodNotes-style pressure → line width
    function getPressureWidth(e, basePx) {
      const p = (e.pressure && e.pressure > 0 && e.pointerType === 'pen') ? e.pressure : 0.5;
      const v = e._velocity || 0;
      // Width varies with pressure and inversely with velocity (fast strokes = thinner)
      const velocityFactor = Math.max(0.4, 1 - v * 0.003);
      return Math.max(0.5, basePx * p * velocityFactor * 1.8);
    }

    let lastPt = null, lastTime = 0;

    function startDraw(e, vk) {
      if (!activeNote) return;
      isDrawing = true;
      const pt = getPt(e, vk);
      lastPt = pt; lastTime = Date.now();

      if (drawTool === 'scribble') {
        scribblePts = [pt];
        currentStroke = { tool: 'scribble', pts: [pt] };
        return;
      }
      if (drawTool === 'text') {
        const txt = prompt('Enter text:');
        if (txt) pushStroke({ tool: 'text', x: pt.x, y: pt.y, text: txt, color: drawColor, size: drawSize * 4 + 14, font: 'serif' }, vk);
        isDrawing = false; return;
      }
      if (drawTool === 'eraser') {
        currentStroke = { tool: 'eraser', pts: [pt], size: drawSize * 8 };
        return;
      }
      if (['pen', 'marker', 'highlighter'].includes(drawTool)) {
        const lw = drawTool === 'highlighter' ? drawSize * 8 :
          drawTool === 'marker' ? drawSize * 3.5 :
            getPressureWidth(e, drawSize);
        currentStroke = {
          tool: drawTool, pts: [pt],
          widths: [lw],
          color: drawColor,
          opacity: drawTool === 'highlighter' ? 0.32 : drawTool === 'marker' ? 0.65 : 1
        };
        return;
      }
      // Shape tools
      startPt = pt;
      currentStroke = { tool: drawTool, start: pt, end: pt, color: drawColor, size: drawSize };
    }

    function moveDraw(e, vk) {
      if (!isDrawing || !currentStroke) return;
      const pt = getPt(e, vk);
      const now = Date.now();
      const dt = now - lastTime || 1;
      const dist = lastPt ? Math.hypot(pt.x - lastPt.x, pt.y - lastPt.y) : 0;
      const velocity = dist / dt * 16; // px/frame approx
      e._velocity = velocity;
      lastPt = pt; lastTime = now;

      const vp = getVP(vk);
      const ctx = vk === 'main' ? mainCtx : mixCtx;
      const cvs = vk === 'main' ? mainCvs : mixCvs;

      if (currentStroke.tool === 'scribble') {
        scribblePts.push(pt);
        currentStroke.pts.push(pt);
        // Visual feedback
        const oc = vk === 'main' ? overlayCtx : mixCtx;
        if (oc) {
          const oCvs = vk === 'main' ? overlayCvs : mixCvs;
          oc.clearRect(0, 0, oCvs.width, oCvs.height);
          oc.save();
          oc.translate(vp.x, vp.y); oc.scale(vp.scale, vp.scale);
          oc.strokeStyle = 'rgba(220,38,38,0.35)';
          oc.lineWidth = 20 / vp.scale; oc.lineCap = 'round'; oc.lineJoin = 'round';
          oc.beginPath(); scribblePts.forEach((p, i) => i === 0 ? oc.moveTo(p.x, p.y) : oc.lineTo(p.x, p.y));
          oc.stroke(); oc.restore();
        }
        clearTimeout(scribbleTimer);
        scribbleTimer = setTimeout(() => doScribbleErase(vk), 350);
        return;
      }

      if (['pen', 'marker', 'highlighter', 'eraser'].includes(currentStroke.tool)) {
        const lw = currentStroke.tool === 'eraser' ? currentStroke.size :
          currentStroke.tool === 'highlighter' ? currentStroke.widths?.[0] || drawSize * 8 :
            currentStroke.tool === 'marker' ? currentStroke.widths?.[0] || drawSize * 3.5 :
              getPressureWidth(e, drawSize);
        if (currentStroke.widths) currentStroke.widths.push(lw);
        currentStroke.pts.push(pt);

        ctx.save();
        ctx.translate(vp.x, vp.y); ctx.scale(vp.scale, vp.scale);
        applyStyle(currentStroke, ctx, lw);

        const pts = currentStroke.pts;
        if (pts.length >= 3) {
          const i = pts.length - 1;
          const p0 = pts[i - 2], p1 = pts[i - 1], p2 = pts[i];
          const w0 = currentStroke.widths?.[i - 2] || lw;
          const w1 = currentStroke.widths?.[i - 1] || lw;
          const w2 = currentStroke.widths?.[i] || lw;

          if (currentStroke.tool === 'pen') {
            // Variable width pen - draw tapered segment
            ctx.lineWidth = (w1 + w2) / 2;
            ctx.beginPath();
            const mx1 = (p0.x + p1.x) / 2, my1 = (p0.y + p1.y) / 2;
            const mx2 = (p1.x + p2.x) / 2, my2 = (p1.y + p2.y) / 2;
            ctx.moveTo(mx1, my1);
            ctx.quadraticCurveTo(p1.x, p1.y, mx2, my2);
            ctx.stroke();
          } else {
            ctx.lineWidth = w1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
          }
        } else if (pts.length === 2) {
          ctx.lineWidth = lw;
          ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y); ctx.stroke();
        }
        ctx.restore();
      } else {
        // Shape preview on overlay
        currentStroke.end = pt;
        if (vk === 'main') {
          overlayCtx.clearRect(0, 0, overlayCvs.width, overlayCvs.height);
          overlayCtx.save();
          overlayCtx.translate(vp.x, vp.y); overlayCtx.scale(vp.scale, vp.scale);
          drawShapeStroke(currentStroke, overlayCtx, true);
          overlayCtx.restore();
        }
      }
    }

    function endDraw(e, vk) {
      if (!isDrawing) return;
      isDrawing = false;
      if (vk === 'main') overlayCtx.clearRect(0, 0, overlayCvs.width, overlayCvs.height);

      if (currentStroke?.tool === 'scribble') {
        clearTimeout(scribbleTimer);
        doScribbleErase(vk);
        currentStroke = null; scribblePts = [];
        return;
      }
      if (!currentStroke) return;

      if (!['pen', 'marker', 'highlighter', 'eraser'].includes(currentStroke.tool)) {
        currentStroke.end = getPt(e, vk);
      }

      // Taper pen stroke ends
      if (currentStroke.tool === 'pen' && currentStroke.pts.length > 4) {
        const ws = currentStroke.widths;
        if (ws && ws.length > 2) {
          // Taper start and end
          ws[0] = ws[0] * 0.1;
          ws[1] = ws[1] * 0.5;
          ws[ws.length - 1] = ws[ws.length - 1] * 0.1;
          ws[ws.length - 2] = ws[ws.length - 2] * 0.5;
        }
      }

      pushStroke(currentStroke, vk);
      currentStroke = null; startPt = null;
      if (vk === 'main') { redrawMain(); updateHUD(); } else redrawMix();
    }

    // ─── SCRIBBLE ERASE ──────────────────────────────────────────
    function doScribbleErase(vk) {
      if (scribblePts.length < 6) return;
      const xs = scribblePts.map(p => p.x), ys = scribblePts.map(p => p.y);
      let reversals = 0;
      const win = 5;
      for (let i = win; i < xs.length - win; i++) {
        if ((xs[i] - xs[i - win]) * (xs[i + win] - xs[i]) < -30) reversals++;
        if ((ys[i] - ys[i - win]) * (ys[i + win] - ys[i]) < -30) reversals++;
      }

      if (reversals >= 3) {
        const x1 = Math.min(...xs) - 15, y1 = Math.min(...ys) - 15;
        const x2 = Math.max(...xs) + 15, y2 = Math.max(...ys) + 15;

        if (!activeNote || !drawData[activeNote]) return;
        const d = drawData[activeNote];
        const erased = [];
        d.pages = d.pages.map(pg => pg.filter(s => {
          if (strokeInBox(s, x1, y1, x2, y2)) { erased.push(s); return false; }
          return true;
        }));

        if (erased.length) {
          undoStacks[activeNote].push({ type: 'scribble_erase', erased, page: d.page || 0 });
          redoStacks[activeNote] = [];
          debounceSave();
          if (vk === 'main') { redrawMain(); updateHUD(); } else redrawMix();
          toast(`Erased ${erased.length} stroke${erased.length > 1 ? 's' : ''}`, 'accent');
        }
      }

      // Clear overlay
      if (vk === 'main') overlayCtx.clearRect(0, 0, overlayCvs.width, overlayCvs.height);
      scribblePts = [];
    }

    function strokeInBox(s, x1, y1, x2, y2) {
      if (s.pts) return s.pts.some(p => p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2);
      if (s.start) return !(Math.max(s.start.x, s.end.x) < x1 || Math.min(s.start.x, s.end.x) > x2 || Math.max(s.start.y, s.end.y) < y1 || Math.min(s.start.y, s.end.y) > y2);
      if (s.x != null) return !(s.x > x2 || s.x + (s.w || 0) < x1 || s.y > y2 || s.y + (s.h || 0) < y1);
      return false;
    }

    // ─── PUSH / UNDO / REDO ──────────────────────────────────────
    function pushStroke(stroke, vk = 'main') {
      if (!activeNote) return;
      const d = drawData[activeNote]; const p = d.page || 0;
      if (!d.pages[p]) d.pages[p] = [];
      d.pages[p].push(stroke);
      undoStacks[activeNote].push({ type: 'stroke', stroke, page: p });
      redoStacks[activeNote] = [];
      notes[activeNote].hasDrawing = true;
      debounceSave();
    }

    function undoDraw() {
      if (!activeNote) return;
      const st = undoStacks[activeNote];
      if (!st?.length) { toast('Nothing to undo'); return; }
      const act = st.pop();
      redoStacks[activeNote].push(act);
      if (act.type === 'stroke') {
        const pg = drawData[activeNote].pages[act.page];
        const idx = pg ? pg.lastIndexOf(act.stroke) : -1;
        if (idx !== -1) pg.splice(idx, 1);
      } else if (act.type === 'scribble_erase') {
        if (!drawData[activeNote].pages[act.page]) drawData[activeNote].pages[act.page] = [];
        drawData[activeNote].pages[act.page].push(...act.erased);
      }
      redrawMain(); updateHUD(); debounceSave();
    }

    function redoDraw() {
      if (!activeNote) return;
      const rs = redoStacks[activeNote];
      if (!rs?.length) { toast('Nothing to redo'); return; }
      const act = rs.pop();
      undoStacks[activeNote].push(act);
      if (act.type === 'stroke') {
        const p = act.page;
        if (!drawData[activeNote].pages[p]) drawData[activeNote].pages[p] = [];
        drawData[activeNote].pages[p].push(act.stroke);
      } else if (act.type === 'scribble_erase') {
        const pg = drawData[activeNote].pages[act.page];
        if (pg) act.erased.forEach(s => { const i = pg.indexOf(s); if (i !== -1) pg.splice(i, 1); });
      }
      redrawMain(); updateHUD(); debounceSave();
    }

    function clearPage() {
      if (!activeNote || !confirm('Clear this page?')) return;
      const d = drawData[activeNote]; const p = d.page || 0;
      undoStacks[activeNote].push({ type: 'scribble_erase', erased: [...(d.pages[p] || [])], page: p });
      d.pages[p] = []; redoStacks[activeNote] = [];
      redrawMain(); updateHUD(); debounceSave(); toast('Page cleared');
    }

    // ─── REDRAW ──────────────────────────────────────────────────
    function redrawMain() {
      if (!mainCvs || !mainCtx) return;
      const vp = getVP('main');
      mainCtx.clearRect(0, 0, mainCvs.width, mainCvs.height);
      if (!activeNote || !drawData[activeNote]) return;
      const d = drawData[activeNote]; const p = d.page || 0;
      mainCtx.save();
      mainCtx.translate(vp.x, vp.y); mainCtx.scale(vp.scale, vp.scale);
      (d.pages[p] || []).forEach(s => drawStroke(s, mainCtx, vp.scale));
      mainCtx.restore();
    }

    function redrawMix() {
      if (!mixCvs || !mixCtx) return;
      const vp = getVP('mixed');
      mixCtx.clearRect(0, 0, mixCvs.width, mixCvs.height);
      if (!activeNote || !drawData[activeNote]) return;
      const d = drawData[activeNote]; const p = d.page || 0;
      mixCtx.save();
      mixCtx.translate(vp.x, vp.y); mixCtx.scale(vp.scale, vp.scale);
      (d.pages[p] || []).forEach(s => drawStroke(s, mixCtx, vp.scale));
      mixCtx.restore();
    }

    function redrawBg() {
      if (!bgCvs || !bgCtx) return;
      const w = bgCvs.width, h = bgCvs.height;
      bgCtx.clearRect(0, 0, w, h);

      // Read current theme colors from CSS variables
      const style = getComputedStyle(document.documentElement);
      const paperColor = style.getPropertyValue('--canvas-paper').trim() || '#fffffe';
      const gridColor = style.getPropertyValue('--canvas-grid').trim() || 'rgba(0,0,0,0.055)';
      const linesColor = style.getPropertyValue('--canvas-lines').trim() || 'rgba(0,0,0,0.07)';
      const dotsColor = style.getPropertyValue('--canvas-dots').trim() || 'rgba(0,0,0,0.12)';
      const marginColor = style.getPropertyValue('--canvas-margin').trim() || 'rgba(212,88,10,0.15)';

      bgCtx.fillStyle = paperColor;
      bgCtx.fillRect(0, 0, w, h);
      const vp = getVP('main');
      if (currentBg === 'plain') return;

      const gridPx = 28 * vp.scale;
      const ox = ((vp.x % gridPx) + gridPx) % gridPx;
      const oy = ((vp.y % gridPx) + gridPx) % gridPx;

      bgCtx.save();
      if (currentBg === 'grid') {
        bgCtx.strokeStyle = gridColor; bgCtx.lineWidth = 1;
        for (let x = ox - gridPx; x <= w + gridPx; x += gridPx) { bgCtx.beginPath(); bgCtx.moveTo(x, 0); bgCtx.lineTo(x, h); bgCtx.stroke(); }
        for (let y = oy - gridPx; y <= h + gridPx; y += gridPx) { bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(w, y); bgCtx.stroke(); }
      } else if (currentBg === 'lined') {
        const lh = 32 * vp.scale;
        const loy = ((vp.y % lh) + lh) % lh;
        bgCtx.strokeStyle = linesColor; bgCtx.lineWidth = 1;
        for (let y = loy - lh; y <= h + lh; y += lh) { bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(w, y); bgCtx.stroke(); }
        const mx = 80 * vp.scale + vp.x;
        bgCtx.strokeStyle = marginColor; bgCtx.lineWidth = 1.5;
        bgCtx.beginPath(); bgCtx.moveTo(mx, 0); bgCtx.lineTo(mx, h); bgCtx.stroke();
      } else if (currentBg === 'dots') {
        bgCtx.fillStyle = dotsColor;
        for (let x = ox - gridPx; x <= w + gridPx; x += gridPx) for (let y = oy - gridPx; y <= h + gridPx; y += gridPx) {
          bgCtx.beginPath(); bgCtx.arc(x, y, 1.2, 0, Math.PI * 2); bgCtx.fill();
        }
      }
      bgCtx.restore();
    }

    function redrawMixBg() {
      if (!mixBgCvs || !mixBgCtx) return;
      const w = mixBgCvs.width, h = mixBgCvs.height;
      const style = getComputedStyle(document.documentElement);
      const paperColor = style.getPropertyValue('--canvas-paper').trim() || '#fffffe';
      const linesColor = style.getPropertyValue('--canvas-lines').trim() || 'rgba(0,0,0,0.07)';
      mixBgCtx.clearRect(0, 0, w, h);
      mixBgCtx.fillStyle = paperColor; mixBgCtx.fillRect(0, 0, w, h);
      mixBgCtx.strokeStyle = linesColor; mixBgCtx.lineWidth = 1;
      for (let y = 28; y < h; y += 28) { mixBgCtx.beginPath(); mixBgCtx.moveTo(0, y); mixBgCtx.lineTo(w, y); mixBgCtx.stroke(); }
    }

    // ─── STROKE RENDER ───────────────────────────────────────────
    function drawStroke(s, ctx, vpScale = 1) {
      if (!s?.tool) return;
      ctx.save();

      if (s.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.lineWidth = s.size; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        smoothPath(s.pts, ctx); ctx.restore(); return;
      }
      if (s.tool === 'highlighter') {
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = hexA(s.color, s.opacity || 0.32);
        ctx.lineWidth = s.widths?.[0] || drawSize * 8;
        ctx.lineCap = 'square'; ctx.lineJoin = 'bevel';
        flatPath(s.pts, ctx); ctx.restore(); return;
      }
      if (s.tool === 'marker') {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = hexA(s.color, s.opacity || 0.65);
        ctx.lineWidth = s.widths?.[0] || drawSize * 3.5;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        smoothPath(s.pts, ctx); ctx.restore(); return;
      }
      if (s.tool === 'pen') {
        ctx.globalCompositeOperation = 'source-over';
        // Variable width pen stroke
        const pts = s.pts, ws = s.widths;
        if (!pts || pts.length < 2) { ctx.restore(); return; }
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        for (let i = 1; i < pts.length; i++) {
          const lw = ws ? (ws[i - 1] + ws[i]) / 2 : drawSize;
          ctx.strokeStyle = hexA(s.color, 1);
          ctx.lineWidth = Math.max(0.3, lw);
          ctx.beginPath();
          if (i === 1) {
            ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y);
          } else {
            const mx = (pts[i - 1].x + pts[i].x) / 2, my = (pts[i - 1].y + pts[i].y) / 2;
            ctx.moveTo((pts[i - 2].x + pts[i - 1].x) / 2, (pts[i - 2].y + pts[i - 1].y) / 2);
            ctx.quadraticCurveTo(pts[i - 1].x, pts[i - 1].y, mx, my);
          }
          ctx.stroke();
        }
        ctx.restore(); return;
      }
      if (s.tool === 'line') {
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(s.start.x, s.start.y); ctx.lineTo(s.end.x, s.end.y); ctx.stroke();
      } else if (s.tool === 'rect') {
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size;
        ctx.strokeRect(s.start.x, s.start.y, s.end.x - s.start.x, s.end.y - s.start.y);
      } else if (s.tool === 'circle') {
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size;
        const rx = Math.abs(s.end.x - s.start.x) / 2, ry = Math.abs(s.end.y - s.start.y) / 2;
        if (rx > 0 && ry > 0) { ctx.beginPath(); ctx.ellipse((s.start.x + s.end.x) / 2, (s.start.y + s.end.y) / 2, rx, ry, 0, 0, Math.PI * 2); ctx.stroke(); }
      } else if (s.tool === 'arrow') {
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.lineCap = 'round';
        drawArrow(ctx, s.start, s.end);
      } else if (s.tool === 'text') {
        ctx.fillStyle = s.color;
        const ff = s.font === 'serif' ? 'Lora,Georgia,serif' : 'Geist Mono,monospace';
        ctx.font = `${s.size}px ${ff}`;
        ctx.fillText(s.text, s.x, s.y);
      } else if (s.tool === 'raster' || s.tool === 'pdf_page') {
        if (s.img) {
          ctx.globalAlpha = 1; ctx.drawImage(s.img, s.x, s.y, s.w, s.h);
        } else if (s.dataURL) {
          const img = new Image();
          img.onload = () => { s.img = img; redrawMain(); };
          img.src = s.dataURL;
        }
      }
      ctx.restore();
    }

    function applyStyle(s, ctx, lw) {
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
      if (s.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)'; ctx.lineWidth = s.size;
      } else if (s.tool === 'highlighter') {
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = hexA(s.color, s.opacity || 0.32); ctx.lineWidth = lw;
        ctx.lineCap = 'square';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = hexA(s.color, s.opacity || 1); ctx.lineWidth = lw;
      }
    }

    function drawShapeStroke(s, ctx, preview = false) {
      if (!s?.start || !s?.end) return;
      ctx.save();
      ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.lineCap = 'round';
      if (preview) { ctx.globalAlpha = 0.6; ctx.setLineDash([6, 4]); }
      if (s.tool === 'line') { ctx.beginPath(); ctx.moveTo(s.start.x, s.start.y); ctx.lineTo(s.end.x, s.end.y); ctx.stroke(); }
      else if (s.tool === 'rect') { ctx.strokeRect(s.start.x, s.start.y, s.end.x - s.start.x, s.end.y - s.start.y); }
      else if (s.tool === 'circle') { const rx = Math.abs(s.end.x - s.start.x) / 2, ry = Math.abs(s.end.y - s.start.y) / 2; if (rx > 0 && ry > 0) { ctx.beginPath(); ctx.ellipse((s.start.x + s.end.x) / 2, (s.start.y + s.end.y) / 2, rx, ry, 0, 0, Math.PI * 2); ctx.stroke(); } }
      else if (s.tool === 'arrow') { drawArrow(ctx, s.start, s.end); }
      ctx.restore();
    }

    function smoothPath(pts, ctx) {
      if (!pts || pts.length < 2) return;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length - 1; i++) {
        const mx = (pts[i].x + pts[i + 1].x) / 2, my = (pts[i].y + pts[i + 1].y) / 2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, mx, my);
      }
      ctx.lineTo(pts[pts.length - 1].x, pts[pts.length - 1].y);
      ctx.stroke();
    }

    function flatPath(pts, ctx) {
      if (!pts || pts.length < 2) return;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
    }

    function drawArrow(ctx, a, b) {
      if (!a || !b) return;
      const ang = Math.atan2(b.y - a.y, b.x - a.x), hl = 16;
      ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - hl * Math.cos(ang - Math.PI / 6), b.y - hl * Math.sin(ang - Math.PI / 6));
      ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - hl * Math.cos(ang + Math.PI / 6), b.y - hl * Math.sin(ang + Math.PI / 6));
      ctx.stroke();
    }

    function hexA(hex, a) {
      if (!hex || hex.length < 7) return `rgba(26,25,22,${a})`;
      const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // ─── TOOL CONTROLS ───────────────────────────────────────────
    function setTool(t) {
      drawTool = t;
      document.querySelectorAll('.tool-btn[id^="tool-"]').forEach(b => b.classList.remove('active'));
      document.getElementById('tool-' + t)?.classList.add('active');
      ['pen', 'hl', 'erase', 'pan'].forEach(x => {
        document.getElementById('mx-' + x)?.classList.toggle('active-bg', t === (x === 'hl' ? 'highlighter' : x === 'erase' ? 'scribble' : x));
      });
      const ca = document.getElementById('canvas-area');
      ca.className = ca.className.replace(/tool-\w+/g, '') + ' tool-' + t;
      // Update HUD
      document.getElementById('hud-tool').textContent = t.charAt(0).toUpperCase() + t.slice(1);
      // Hide cursors
      ['eraser-cursor', 'scribble-cursor'].forEach(id => {
        const c = document.getElementById(id); if (c) c.style.display = 'none';
      });
    }

    function setColor(c, el) {
      drawColor = c;
      document.querySelectorAll('.tool-color-dot').forEach(d => d.classList.remove('active'));
      el?.classList.add('active');
    }

    function setSize(v) {
      drawSize = v;
      document.getElementById('size-val').textContent = v + 'px';
      document.getElementById('hud-size').textContent = v + 'px';
    }

    function setBg(bg) {
      currentBg = bg;
      ['plain', 'grid', 'lined', 'dots'].forEach(b => {
        document.getElementById('bg-' + b + '-btn')?.classList.toggle('active-bg', b === bg);
      });
      redrawBg();
    }

    function exportPNG() {
      const w = mainCvs.width, h = mainCvs.height;
      const comp = document.createElement('canvas');
      comp.width = w; comp.height = h;
      const ctx = comp.getContext('2d');
      ctx.drawImage(bgCvs, 0, 0); ctx.drawImage(mainCvs, 0, 0);
      const a = document.createElement('a');
      a.download = (notes[activeNote]?.title || 'drawing').replace(/\s+/g, '_') + '.png';
      a.href = comp.toDataURL('image/png'); a.click();
      toast('Exported ✓', 'green');
    }

    // ─── PAGES ───────────────────────────────────────────────────
    function renderPagesStrip() {
      if (!activeNote || !drawData[activeNote]) return;
      const d = drawData[activeNote];
      const strip = document.getElementById('pages-strip');
      let h = d.pages.map((pg, i) => `
    <div class="page-thumb${i === d.page ? ' active' : ''}" onclick="switchPage(${i})" title="Page ${i + 1}">
      <span style="font-family:var(--font-mono);font-size:10px;color:var(--muted)">P${i + 1}</span>
      <span class="page-thumb-num">${pg.length} strokes</span>
    </div>`).join('');
      h += `<button class="page-add-btn" onclick="addPage()" title="Add page">＋</button>`;
      strip.innerHTML = h;
    }

    function switchPage(idx) {
      if (!activeNote) return;
      drawData[activeNote].page = idx;
      renderPagesStrip(); redrawMain(); updateHUD();
    }

    function addPage() {
      if (!activeNote) return;
      const d = drawData[activeNote];
      d.pages.push([]); d.page = d.pages.length - 1;
      renderPagesStrip(); redrawMain(); updateHUD(); debounceSave();
      toast(`Page ${d.page + 1} added`, 'accent');
    }

    // ─── PDF IMPORT ──────────────────────────────────────────────
    function triggerPdfImport() { document.getElementById('pdf-input').click(); }
    function handlePdfFile(inp) { if (inp.files?.[0]) importPdf(inp.files[0]); inp.value = ''; }

    function setupPdfDrop() {
      const ca = document.getElementById('canvas-area');
      ca.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
      ca.addEventListener('drop', e => {
        e.preventDefault();
        const f = e.dataTransfer.files[0];
        if (f?.type === 'application/pdf') importPdf(f);
        else toast('Drop a PDF file');
      });
    }

    async function importPdf(file) {
      if (!activeNote) { toast('Open a note first'); return; }
      if (typeof pdfjsLib === 'undefined') { toast('PDF.js not loaded'); return; }
      const prog = document.getElementById('pdf-progress');
      const fill = document.getElementById('pdf-fill');
      const txt = document.getElementById('pdf-text');
      prog.classList.add('show');

      try {
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        const total = pdf.numPages;
        txt.textContent = `0/${total} pages`;

        const vp = getVP('main');
        const wrap = document.getElementById('canvas-area');
        let y = (-vp.y / vp.scale) + 20;
        const x = (-vp.x / vp.scale) + 20;

        for (let i = 1; i <= total; i++) {
          fill.style.width = ((i / total) * 95) + '%';
          txt.textContent = `${i}/${total} pages`;
          const page = await pdf.getPage(i);
          const pv = page.getViewport({ scale: 1.5 });
          const c = document.createElement('canvas');
          c.width = pv.width; c.height = pv.height;
          const cx = c.getContext('2d');
          cx.fillStyle = '#fff'; cx.fillRect(0, 0, c.width, c.height);
          await page.render({ canvasContext: cx, viewport: pv }).promise;
          const dataURL = c.toDataURL('image/jpeg', 0.88);
          const img = new Image(); await new Promise(r => { img.onload = r; img.src = dataURL; });
          const w = pv.width / 1.5, h = pv.height / 1.5;
          pushStroke({ tool: 'pdf_page', x, y, w, h, img, dataURL }, 'main');
          y += h + 24;
        }

        fill.style.width = '100%'; txt.textContent = 'Done!';
        setTimeout(() => prog.classList.remove('show'), 800);
        setTimeout(() => fitToContent(), 100);
        notes[activeNote].hasDrawing = true; renderNoteList();
        toast(`Imported ${total} page${total > 1 ? 's' : ''} ✓`, 'green');
      } catch (err) {
        prog.classList.remove('show');
        toast('PDF error: ' + err.message);
        console.error(err);
      }
    }

    // ═══════════════════════════════════════════════════════════
    //  MODE SWITCHER
    // ═══════════════════════════════════════════════════════════
    function setMode(mode) {
      currentMode = mode;
      ['write', 'draw', 'mixed'].forEach(m => document.getElementById('mt-' + m)?.classList.toggle('active', m === mode));
      document.getElementById('write-pane').classList.toggle('active', mode === 'write');
      document.getElementById('draw-pane').classList.toggle('active', mode === 'draw');
      document.getElementById('mixed-pane').classList.toggle('active', mode === 'mixed');
      if (mode === 'draw' || mode === 'mixed') {
        setTimeout(() => { resizeAllCanvases(); redrawMain(); redrawBg(); redrawMix(); redrawMixBg(); }, 60);
      }
    }

    // ═══════════════════════════════════════════════════════════
    //  SIDEBAR + NOTE LIST
    // ═══════════════════════════════════════════════════════════
    function renderNoteList(filter = '') {
      const sorted = Object.values(notes)
        .filter(n => !filter || n.title.toLowerCase().includes(filter.toLowerCase()) || stripHtml(n.content || '').toLowerCase().includes(filter.toLowerCase()))
        .sort((a, b) => new Date(b.modified) - new Date(a.modified));

      document.getElementById('note-list').innerHTML = sorted.map(n => {
        const d = new Date(n.modified).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        const preview = stripHtml(n.content || '').slice(0, 60).trim();
        const icon = n.hasDrawing ? '✏' : '✦';
        return `<div class="sb-note${activeNote === n.id ? ' active' : ''}" data-id="${n.id}" onclick="openNote('${n.id}')">
      <span class="sb-note-icon">${icon}</span>
      <div class="sb-note-body">
        <div class="sb-note-title">${esc(n.title || 'Untitled')}</div>
        <div class="sb-note-meta">${d} · ${n._wc || 0} words</div>
      </div>
      <button class="sb-note-del" onclick="deleteNote('${n.id}',event)">✕</button>
    </div>`;
      }).join('');

      document.getElementById('note-count-badge').textContent = sorted.length + ' notes';
    }

    function searchNotes(q) { renderNoteList(q); }
    function updateStats() {
      const c = Object.keys(notes).length;
      const w = Object.values(notes).reduce((s, n) => s + (n._wc || 0), 0);
      document.getElementById('sb-stats-notes').textContent = `${c} note${c !== 1 ? 's' : ''}`;
      document.getElementById('sb-stats-words').textContent = `${w.toLocaleString()} words`;
      document.getElementById('note-count-badge').textContent = c + ' notes';
    }

    function renderTagRow(tags) {
      document.getElementById('tag-row').innerHTML = (tags || []).map(t =>
        `<span class="note-tag">#${esc(t)}</span>`).join('');
    }

    function promptTag() {
      openModal('Add Tag', 'Tag name…', tag => {
        tag = tag.toLowerCase().trim().replace(/\s+/g, '-');
        if (!tag || !activeNote) return;
        notes[activeNote].tags = [...new Set([...(notes[activeNote].tags || []), tag])];
        renderTagRow(notes[activeNote].tags); save();
      });
    }

    // ═══════════════════════════════════════════════════════════
    //  GRAPH VIEW
    // ═══════════════════════════════════════════════════════════
    let gNodes = [], gEdges = [], gAnim = null;
    function showGraph() {
      document.getElementById('graph-overlay').classList.add('open');
      buildGraph(); animateGraph();
    }
    function closeGraph() {
      document.getElementById('graph-overlay').classList.remove('open');
      if (gAnim) { cancelAnimationFrame(gAnim); gAnim = null; }
    }
    function buildGraph() {
      gNodes = []; gEdges = [];
      const cvs = document.getElementById('graph-canvas');
      cvs.width = cvs.offsetWidth || innerWidth; cvs.height = cvs.offsetHeight || (innerHeight - 60);
      const W = cvs.width, H = cvs.height;
      Object.values(notes).forEach((n, i, arr) => {
        const a = (i / arr.length) * Math.PI * 2, r = Math.min(W, H) * .32;
        gNodes.push({ id: n.id, label: (n.title || '').slice(0, 20), x: W / 2 + r * Math.cos(a), y: H / 2 + r * Math.sin(a), vx: 0, vy: 0, active: n.id === activeNote });
      });
      Object.values(notes).forEach(n => {
        const wikiLinks = [...((n.content || '').matchAll(/data-target="([^"]+)"/g))].map(m => m[1]);
        wikiLinks.forEach(title => {
          const tgt = Object.values(notes).find(x => x.title.toLowerCase() === title.toLowerCase());
          if (tgt && tgt.id !== n.id) gEdges.push({ from: n.id, to: tgt.id });
        });
      });
    }
    function animateGraph() {
      const cvs = document.getElementById('graph-canvas');
      if (!cvs || !document.getElementById('graph-overlay').classList.contains('open')) return;
      const ctx = cvs.getContext('2d'), W = cvs.width, H = cvs.height;
      gNodes.forEach(n => {
        gNodes.forEach(m => { if (m.id === n.id) return; const dx = n.x - m.x, dy = n.y - m.y, d = Math.sqrt(dx * dx + dy * dy) || 1, f = 2000 / (d * d); n.vx += dx / d * f; n.vy += dy / d * f; });
        n.vx += (W / 2 - n.x) * .002; n.vy += (H / 2 - n.y) * .002; n.vx *= .85; n.vy *= .85;
        n.x = Math.max(60, Math.min(W - 60, n.x + n.vx)); n.y = Math.max(30, Math.min(H - 30, n.y + n.vy));
      });
      gEdges.forEach(e => {
        const a = gNodes.find(n => n.id === e.from), b = gNodes.find(n => n.id === e.to); if (!a || !b) return;
        const dx = b.x - a.x, dy = b.y - a.y, d = Math.sqrt(dx * dx + dy * dy) || 1, f = (d - 120) * .007;
        a.vx += dx / d * f; a.vy += dy / d * f; b.vx -= dx / d * f; b.vy -= dy / d * f;
      });
      ctx.clearRect(0, 0, W, H);
      gEdges.forEach(e => {
        const a = gNodes.find(n => n.id === e.from), b = gNodes.find(n => n.id === e.to); if (!a || !b) return;
        ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.strokeStyle = 'rgba(212,88,10,.25)'; ctx.lineWidth = 1.5; ctx.stroke();
      });
      gNodes.forEach(n => {
        const r = n.active ? 10 : 7;
        ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
        ctx.fillStyle = n.active ? 'rgba(212,88,10,.9)' : 'rgba(61,59,53,.45)'; ctx.fill();
        ctx.fillStyle = 'rgba(26,25,22,.75)'; ctx.font = '10px Geist Mono,monospace'; ctx.textAlign = 'center';
        ctx.fillText(n.label, n.x, n.y - r - 6);
      });
      gAnim = requestAnimationFrame(animateGraph);
    }
    document.getElementById('graph-canvas').addEventListener('click', e => {
      const cvs = document.getElementById('graph-canvas'), r = cvs.getBoundingClientRect();
      const hit = gNodes.find(n => Math.hypot(n.x - (e.clientX - r.left), n.y - (e.clientY - r.top)) < 14);
      if (hit) { closeGraph(); openNote(hit.id); }
    });

    // ═══════════════════════════════════════════════════════════
    //  SIDEBAR TOGGLE
    // ═══════════════════════════════════════════════════════════
    function toggleSidebar() {
      const sb = document.getElementById('sidebar');
      const mobile = window.innerWidth <= 800;
      if (mobile) {
        sb.classList.toggle('open');
        document.getElementById('sb-overlay').classList.toggle('show', sb.classList.contains('open'));
      } else {
        sb.classList.toggle('hidden');
        document.getElementById('wc-bar').classList.toggle('no-sb', sb.classList.contains('hidden'));
      }
    }
    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('sb-overlay').classList.remove('show');
    }

    // ═══════════════════════════════════════════════════════════
    //  MODAL
    // ═══════════════════════════════════════════════════════════
    function openModal(title, placeholder, cb) {
      document.getElementById('modal-title').textContent = title;
      document.getElementById('modal-input').placeholder = placeholder;
      document.getElementById('modal-input').value = '';
      modalCallback = cb;
      document.getElementById('modal-overlay').classList.add('open');
      setTimeout(() => document.getElementById('modal-input').focus(), 50);
    }
    function closeModal() { document.getElementById('modal-overlay').classList.remove('open'); modalCallback = null; }
    function confirmModal() { const v = document.getElementById('modal-input').value.trim(); closeModal(); if (modalCallback) modalCallback(v); }

    // ═══════════════════════════════════════════════════════════
    //  GLOBAL KEYS
    // ═══════════════════════════════════════════════════════════
    function globalKeys(e) {
      const m = e.metaKey || e.ctrlKey;
      if (m && e.key === 'n') { e.preventDefault(); newNote(); }
      if (m && e.key === 's') { e.preventDefault(); save(); toast('Saved ✓'); }
      if (m && (e.key === 'z' || e.key === 'Z') && !e.shiftKey && currentMode !== 'write') { e.preventDefault(); undoDraw(); }
      if ((m && e.key === 'y') || (m && e.shiftKey && e.key === 'Z')) { if (currentMode !== 'write') { e.preventDefault(); redoDraw(); } }
      if (e.key === 'Escape') { closeModal(); closeSlash(); closeGraph(); closeCardModal(); closeReadMode(); closeGrammar(); closeOrganise(); }
      if (m && e.key === 'b') { e.preventDefault(); toggleBlitz(); }
      if (m && e.shiftKey && e.key === 'R') { e.preventDefault(); openReadMode(); }
      if (currentMode === 'draw' || currentMode === 'mixed') {
        if (!m) {
          if (e.key === 'p') setTool('pen');
          if (e.key === 'm') setTool('marker');
          if (e.key === 'h') setTool('highlighter');
          if (e.key === 'e') setTool('eraser');
          if (e.key === 'x') setTool('scribble');
          if (e.key === 'v') setTool('pan');
          if (e.key === 't') setTool('text');
          if (e.key === '=' || e.key === '+') zoomStep(0.2);
          if (e.key === '-') zoomStep(-0.2);
          if (e.key === '0') resetViewport();
        }
      }
    }

    // ═══════════════════════════════════════════════════════════
    //  HELPERS
    // ═══════════════════════════════════════════════════════════
    function stripHtml(h) { const d = document.createElement('div'); d.innerHTML = h; return d.innerText || d.textContent || ''; }
    function esc(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }
    function autoGrow(el) { el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, 120) + 'px'; }
    function toast(msg, style = '') {
      const t = document.getElementById('toast');
      t.textContent = msg; t.className = 'toast show' + (style ? ' ' + style : '');
      clearTimeout(toastTimer); toastTimer = setTimeout(() => t.classList.remove('show'), 2200);
    }

    // ═══════════════════════════════════════════════════════════
    //  THEME TOGGLE
    // ═══════════════════════════════════════════════════════════
    let isDark = false;
    function toggleTheme() {
      isDark = !isDark;
      document.documentElement.classList.toggle('dark', isDark);
      const btn = document.getElementById('theme-btn');
      btn.textContent = isDark ? '☀ Light' : '☾ Dark';
      localStorage.setItem('cv3_theme', isDark ? 'dark' : 'light');
      // Redraw canvas backgrounds with new palette
      setTimeout(() => { redrawBg(); redrawMixBg(); }, 20);
    }

    function loadTheme() {
      const saved = localStorage.getItem('cv3_theme');
      if (saved === 'dark') { isDark = true; document.documentElement.classList.add('dark'); document.getElementById('theme-btn').textContent = '☀ Light'; }
    }

    // ═══════════════════════════════════════════════════════════
    //  BLITZ AI PANEL
    // ═══════════════════════════════════════════════════════════
    let blitzOpen = false;
    let blitzWS = null;
    let blitzStreamBubble = null;
    let blitzStreamText = '';

    function toggleBlitz() {
      blitzOpen = !blitzOpen;
      const panel = document.getElementById('blitz-panel');
      panel.classList.toggle('collapsed', !blitzOpen);
      const btn = document.getElementById('blitz-toggle-btn');
      if (btn) btn.classList.toggle('active', blitzOpen);
      if (blitzOpen && !blitzWS) connectBlitzWS();
    }

    function getWSBase() {
      const loc = window.location;
      const proto = loc.protocol === 'https:' ? 'wss:' : 'ws:';
      return proto + '//' + loc.host;
    }

    function connectBlitzWS() {
      try {
        blitzWS = new WebSocket(getWSBase() + '/ws/chat');
        blitzWS.onopen = () => { console.log('[BLITZ] WS connected'); };
        blitzWS.onmessage = (ev) => {
          const d = JSON.parse(ev.data);
          if (d.type === 'token') {
            blitzStreamText += d.text;
            if (blitzStreamBubble) blitzStreamBubble.innerHTML = formatBlitzText(blitzStreamText);
            scrollBlitzFeed();
          } else if (d.type === 'status') {
            appendBlitzStatus(d.text);
          } else if (d.type === 'done') {
            blitzStreamBubble = null;
            blitzStreamText = '';
            removeTypingIndicator();
          } else if (d.type === 'error') {
            appendBlitzMsg('b', 'Error: ' + d.text);
            removeTypingIndicator();
          }
        };
        blitzWS.onclose = () => {
          blitzWS = null;
          setTimeout(() => { if (blitzOpen) connectBlitzWS(); }, 3000);
        };
        blitzWS.onerror = () => { blitzWS = null; };
      } catch (e) { blitzWS = null; }
    }

    function sendBlitz() {
      const inp = document.getElementById('blitz-input');
      const text = inp.value.trim();
      if (!text) return;
      inp.value = ''; inp.style.height = 'auto';
      appendBlitzMsg('u', text);
      showTypingIndicator();
      startBlitzStreamBubble();
      if (blitzWS && blitzWS.readyState === 1) {
        blitzWS.send(JSON.stringify({ text: text, active_modules: ['research'] }));
      } else {
        // Fallback REST
        fetch('/api/command', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: text, active_modules: ['research'] }) })
          .then(r => r.json())
          .then(d => {
            if (blitzStreamBubble) blitzStreamBubble.innerHTML = formatBlitzText(d.response || d.text || 'No response');
            removeTypingIndicator();
            blitzStreamBubble = null; blitzStreamText = '';
          })
          .catch(e => { appendBlitzMsg('b', 'Connection error. Is the server running?'); removeTypingIndicator(); blitzStreamBubble = null; });
      }
    }

    function blitzAction(action) {
      if (!activeNote || !notes[activeNote]) { toast('Open a note first'); return; }
      const n = notes[activeNote];
      const content = stripHtml(n.content || '');
      if (!content.trim()) { toast('Note is empty'); return; }
      const prompts = {
        summarise: `Summarise the following note concisely:\n\n${content}`,
        grammar: `Check the following text for grammar, spelling, and style issues. For each issue, state the problem, the original text, and suggested fix:\n\n${content}`,
        expand: `Expand and elaborate on the following note. Add more detail, examples, and depth:\n\n${content}`,
        quiz: `Create a short quiz (5 questions) based on the following note content to test understanding:\n\n${content}`,
        simplify: `Simplify the following text. Make it easier to understand while keeping the key points:\n\n${content}`,
        bullets: `Convert the following text into a well-organised bullet point list:\n\n${content}`,
      };
      const msg = prompts[action] || content;
      if (!blitzOpen) toggleBlitz();
      appendBlitzMsg('u', `[${action.toUpperCase()}] ${n.title || 'Untitled'}`);
      showTypingIndicator();
      startBlitzStreamBubble();
      if (blitzWS && blitzWS.readyState === 1) {
        blitzWS.send(JSON.stringify({ text: msg, active_modules: [] }));
      } else {
        connectBlitzWS();
        setTimeout(() => {
          if (blitzWS && blitzWS.readyState === 1) {
            blitzWS.send(JSON.stringify({ text: msg, active_modules: [] }));
          } else {
            if (blitzStreamBubble) blitzStreamBubble.innerHTML = 'Could not connect to BLITZ. Is the server running?';
            removeTypingIndicator();
          }
        }, 1500);
      }
    }

    function sendNoteToBlitz() {
      if (!activeNote || !notes[activeNote]) { toast('Open a note first'); return; }
      const n = notes[activeNote];
      const content = stripHtml(n.content || '');
      if (!content.trim()) { toast('Note is empty'); return; }
      if (!blitzOpen) toggleBlitz();
      appendBlitzMsg('u', `📋 Sent note: "${n.title || 'Untitled'}"\n\n${content.substring(0, 300)}${content.length > 300 ? '…' : ''}`);
      appendBlitzMsg('b', `Got it! I've read your note <b>"${esc(n.title || 'Untitled')}"</b>. What would you like me to do with it? I can summarise, check grammar, expand, create a quiz, simplify, or convert to bullet points.`);
    }

    function appendBlitzMsg(who, text) {
      const feed = document.getElementById('blitz-feed');
      const wrap = document.createElement('div');
      wrap.className = 'b-msg ' + who;
      const whoEl = document.createElement('div');
      whoEl.className = 'b-who';
      whoEl.textContent = who === 'u' ? 'YOU' : 'BLITZ';
      const bubble = document.createElement('div');
      bubble.className = 'b-bubble';
      bubble.innerHTML = who === 'b' ? formatBlitzText(text) : esc(text).replace(/\n/g, '<br>');
      const ts = document.createElement('div');
      ts.className = 'b-ts';
      ts.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      wrap.appendChild(whoEl);
      wrap.appendChild(bubble);
      wrap.appendChild(ts);
      feed.appendChild(wrap);
      scrollBlitzFeed();
    }

    function appendBlitzStatus(text) {
      const feed = document.getElementById('blitz-feed');
      const el = document.createElement('div');
      el.className = 'b-msg b';
      el.innerHTML = `<div class="b-who">BLITZ</div><div class="b-bubble" style="font-style:italic;opacity:.7;font-size:11px;">${esc(text)}</div>`;
      feed.appendChild(el);
      scrollBlitzFeed();
    }

    function startBlitzStreamBubble() {
      blitzStreamText = '';
      const feed = document.getElementById('blitz-feed');
      const wrap = document.createElement('div');
      wrap.className = 'b-msg b';
      const whoEl = document.createElement('div');
      whoEl.className = 'b-who'; whoEl.textContent = 'BLITZ';
      const bubble = document.createElement('div');
      bubble.className = 'b-bubble'; bubble.innerHTML = '…';
      wrap.appendChild(whoEl);
      wrap.appendChild(bubble);
      feed.appendChild(wrap);
      blitzStreamBubble = bubble;
      scrollBlitzFeed();
    }

    function showTypingIndicator() {
      removeTypingIndicator();
      const feed = document.getElementById('blitz-feed');
      const el = document.createElement('div');
      el.className = 'b-typing'; el.id = 'blitz-typing';
      el.innerHTML = '<div class="tdot"></div><div class="tdot"></div><div class="tdot"></div>';
      feed.appendChild(el);
      scrollBlitzFeed();
    }

    function removeTypingIndicator() {
      const el = document.getElementById('blitz-typing');
      if (el) el.remove();
    }

    function scrollBlitzFeed() {
      const feed = document.getElementById('blitz-feed');
      feed.scrollTop = feed.scrollHeight;
    }

    function formatBlitzText(text) {
      // Simple markdown-like formatting
      let h = esc(text);
      h = h.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      h = h.replace(/\*(.+?)\*/g, '<em>$1</em>');
      h = h.replace(/`([^`]+)`/g, '<code>$1</code>');
      h = h.replace(/\n/g, '<br>');
      return h;
    }

    // ═══════════════════════════════════════════════════════════
    //  READ MODE
    // ═══════════════════════════════════════════════════════════
    function openReadMode() {
      if (!activeNote || !notes[activeNote]) { toast('Open a note first'); return; }
      const n = notes[activeNote];
      document.getElementById('read-mode-title').textContent = n.title || 'Untitled';
      document.getElementById('read-mode-body').innerHTML = n.content || '<p style="color:var(--muted);font-style:italic;">This note is empty.</p>';
      document.getElementById('read-overlay').classList.add('open');
    }

    function closeReadMode() {
      document.getElementById('read-overlay').classList.remove('open');
    }

    // ═══════════════════════════════════════════════════════════
    //  GRAMMAR CHECK
    // ═══════════════════════════════════════════════════════════
    let grammarIssues = [];

    function openGrammarCheck() {
      if (!activeNote || !notes[activeNote]) { toast('Open a note first'); return; }
      const n = notes[activeNote];
      const content = stripHtml(n.content || '');
      if (!content.trim()) { toast('Note is empty'); return; }
      document.getElementById('grammar-overlay').classList.add('open');
      document.getElementById('grammar-body').innerHTML = '<div class="grammar-loading">⏳ Analysing your writing…</div>';
      grammarIssues = [];

      const prompt = `You are a grammar and style checker. Analyse the following text and return a JSON array of issues. Each issue should have these fields:
- "type": one of "spelling", "grammar", "style"
- "original": the problematic text
- "suggestion": the corrected text
- "explanation": brief explanation of the issue

Return ONLY the JSON array, no other text. If there are no issues, return an empty array [].

Text to check:
${content}`;

      if (blitzWS && blitzWS.readyState === 1) {
        // Use a temporary listener for grammar response
        let grammarResponse = '';
        const originalOnMessage = blitzWS.onmessage;
        blitzWS.onmessage = (ev) => {
          const d = JSON.parse(ev.data);
          if (d.type === 'token') {
            grammarResponse += d.text;
          } else if (d.type === 'done') {
            blitzWS.onmessage = originalOnMessage;
            parseGrammarResponse(grammarResponse);
          } else if (d.type === 'error') {
            blitzWS.onmessage = originalOnMessage;
            document.getElementById('grammar-body').innerHTML = '<div class="grammar-loading">Error checking grammar. Please try again.</div>';
          }
        };
        blitzWS.send(JSON.stringify({ text: prompt, active_modules: [] }));
      } else {
        // REST fallback
        fetch('/api/command', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: prompt, active_modules: [] }) })
          .then(r => r.json())
          .then(d => parseGrammarResponse(d.response || d.text || '[]'))
          .catch(() => { document.getElementById('grammar-body').innerHTML = '<div class="grammar-loading">Connection error. Is the server running?</div>'; });
      }
    }

    function parseGrammarResponse(response) {
      try {
        // Try to find JSON array in response
        const match = response.match(/\[[\s\S]*\]/);
        if (match) {
          grammarIssues = JSON.parse(match[0]);
        } else {
          grammarIssues = [];
        }
      } catch (e) {
        grammarIssues = [];
      }
      renderGrammarIssues();
    }

    function renderGrammarIssues() {
      const body = document.getElementById('grammar-body');
      if (!grammarIssues.length) {
        body.innerHTML = '<div class="grammar-empty">✨ No issues found — your writing looks great!</div>';
        return;
      }
      const icons = { spelling: '🔤', grammar: '📝', style: '✨' };
      body.innerHTML = grammarIssues.map((issue, i) => `
        <div class="grammar-issue" onclick="applyGrammarFix(${i})">
          <div class="grammar-issue-icon">${icons[issue.type] || '📝'}</div>
          <div class="grammar-issue-body">
            <div class="grammar-issue-type ${issue.type || 'grammar'}">${(issue.type || 'grammar').toUpperCase()}</div>
            <div class="grammar-issue-text">${esc(issue.explanation || '')}</div>
            <div class="grammar-issue-fix">"${esc(issue.original || '')}" → "${esc(issue.suggestion || '')}"</div>
          </div>
        </div>
      `).join('');
    }

    function applyGrammarFix(index) {
      if (!activeNote || !grammarIssues[index]) return;
      const issue = grammarIssues[index];
      const ed = document.getElementById('editor');
      if (ed && issue.original && issue.suggestion) {
        const html = ed.innerHTML;
        const escapedOrig = issue.original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(escapedOrig, 'gi');
        ed.innerHTML = html.replace(regex, issue.suggestion);
        notes[activeNote].content = ed.innerHTML;
        debounceSave();
        grammarIssues.splice(index, 1);
        renderGrammarIssues();
        toast('Fix applied ✓', 'green');
      }
    }

    function applyAllGrammarFixes() {
      if (!activeNote || !grammarIssues.length) return;
      const ed = document.getElementById('editor');
      if (!ed) return;
      let html = ed.innerHTML;
      let count = 0;
      grammarIssues.forEach(issue => {
        if (issue.original && issue.suggestion) {
          const escapedOrig = issue.original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(escapedOrig, 'gi');
          if (regex.test(html)) { html = html.replace(regex, issue.suggestion); count++; }
        }
      });
      ed.innerHTML = html;
      notes[activeNote].content = html;
      debounceSave();
      grammarIssues = [];
      renderGrammarIssues();
      toast(`Applied ${count} fix${count !== 1 ? 'es' : ''} ✓`, 'green');
    }

    function closeGrammar() {
      document.getElementById('grammar-overlay').classList.remove('open');
    }

    // ═══════════════════════════════════════════════════════════
    //  ORGANISE NOTES & FOLDERS
    // ═══════════════════════════════════════════════════════════
    let orgSelectedFolder = '__all__';

    function openOrganise() {
      document.getElementById('organise-overlay').classList.add('open');
      renderOrganise();
    }

    function closeOrganise() {
      document.getElementById('organise-overlay').classList.remove('open');
    }

    function renderOrganise() {
      // Gather all folder names
      const folderSet = new Set(['__all__']);
      Object.values(notes).forEach(n => { if (n.folder) folderSet.add(n.folder); });
      if (Object.keys(folders).length) Object.keys(folders).forEach(f => folderSet.add(f));

      const fContainer = document.getElementById('organise-folders');
      fContainer.innerHTML = '<div class="org-label">FOLDERS</div>';

      // All notes button
      const allBtn = document.createElement('button');
      allBtn.className = 'org-folder-btn' + (orgSelectedFolder === '__all__' ? ' active' : '');
      allBtn.innerHTML = '📋 All Notes';
      allBtn.onclick = () => { orgSelectedFolder = '__all__'; renderOrganise(); };
      fContainer.appendChild(allBtn);

      // Each folder
      [...folderSet].filter(f => f !== '__all__').sort().forEach(folder => {
        const btn = document.createElement('button');
        btn.className = 'org-folder-btn' + (orgSelectedFolder === folder ? ' active' : '');
        btn.innerHTML = `📁 ${esc(folder)}`;
        btn.onclick = () => { orgSelectedFolder = folder; renderOrganise(); };
        // Right click to rename/delete
        btn.oncontextmenu = (e) => {
          e.preventDefault();
          const action = prompt(`Folder: "${folder}"\n\nType new name to rename, or type DELETE to remove this folder:`);
          if (!action) return;
          if (action.toUpperCase() === 'DELETE') {
            delete folders[folder];
            Object.values(notes).forEach(n => { if (n.folder === folder) n.folder = ''; });
            orgSelectedFolder = '__all__';
            debounceSave();
            renderOrganise();
            toast('Folder deleted');
          } else {
            folders[action] = true;
            delete folders[folder];
            Object.values(notes).forEach(n => { if (n.folder === folder) n.folder = action; });
            orgSelectedFolder = action;
            debounceSave();
            renderOrganise();
            toast('Folder renamed');
          }
        };
        fContainer.appendChild(btn);
      });

      // New folder button
      const newBtn = document.createElement('button');
      newBtn.className = 'org-new-folder';
      newBtn.textContent = '+ New Folder';
      newBtn.onclick = () => {
        const name = prompt('New folder name:');
        if (!name || !name.trim()) return;
        folders[name.trim()] = true;
        orgSelectedFolder = name.trim();
        debounceSave();
        renderOrganise();
        toast('Folder created ✓', 'green');
      };
      fContainer.appendChild(newBtn);

      // Notes list
      const nContainer = document.getElementById('organise-notes');
      nContainer.innerHTML = '<div class="org-label">NOTES</div>';
      const filtered = Object.entries(notes).filter(([id, n]) => {
        if (orgSelectedFolder === '__all__') return true;
        return (n.folder || '') === orgSelectedFolder;
      });
      if (!filtered.length) {
        nContainer.innerHTML += '<div style="text-align:center;padding:24px;color:var(--muted);font-style:italic;font-size:12px;">No notes in this folder</div>';
        return;
      }
      filtered.forEach(([id, n]) => {
        const row = document.createElement('div');
        row.className = 'org-note-row';
        row.draggable = true;
        row.dataset.noteId = id;
        row.innerHTML = `
          <span style="font-size:13px;">📄</span>
          <span class="org-note-name">${esc(n.title || 'Untitled')}</span>
          <span class="org-note-folder">${n.folder ? '📁 ' + esc(n.folder) : 'Unfiled'}</span>
          <button class="org-move-btn" onclick="moveNoteToFolder('${id}')">Move</button>
        `;
        // Drag and drop
        row.ondragstart = (e) => { e.dataTransfer.setData('text/plain', id); row.classList.add('dragging'); };
        row.ondragend = () => { row.classList.remove('dragging'); };
        nContainer.appendChild(row);
      });

      // Allow dropping on folder buttons
      fContainer.querySelectorAll('.org-folder-btn').forEach(btn => {
        btn.ondragover = (e) => { e.preventDefault(); btn.style.borderColor = 'var(--accent)'; };
        btn.ondragleave = () => { btn.style.borderColor = ''; };
        btn.ondrop = (e) => {
          e.preventDefault(); btn.style.borderColor = '';
          const noteId = e.dataTransfer.getData('text/plain');
          if (noteId && notes[noteId]) {
            const folderName = btn.textContent.replace(/^📋\s*|^📁\s*/g, '').trim();
            notes[noteId].folder = folderName === 'All Notes' ? '' : folderName;
            debounceSave();
            renderOrganise();
            updateNoteList();
            toast('Note moved ✓', 'green');
          }
        };
      });
    }

    function moveNoteToFolder(noteId) {
      if (!notes[noteId]) return;
      const folderList = ['(Unfiled)', ...Object.keys(folders)];
      Object.values(notes).forEach(n => { if (n.folder && !folderList.includes(n.folder)) folderList.push(n.folder); });
      const choice = prompt('Move to folder:\n\n' + folderList.join('\n') + '\n\nType folder name (or leave empty to unfile):');
      if (choice === null) return;
      if (!choice.trim() || choice === '(Unfiled)') {
        notes[noteId].folder = '';
      } else {
        notes[noteId].folder = choice.trim();
        folders[choice.trim()] = true;
      }
      debounceSave();
      renderOrganise();
      updateNoteList();
      toast('Note moved ✓', 'green');
    }

    window.addEventListener('load', init);
    window.addEventListener('load', loadTheme);
  </script>
</body>

</html>
