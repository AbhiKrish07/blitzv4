<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>The Studio v3 ‚Äî B.L.I.T.Z.</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&family=Share+Tech+Mono&family=Exo+2:ital,wght@0,300;0,400;0,600;0,700;1,300&display=swap"
    rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0
    }

    :root {
      --bg: #0a0312;
      --bg2: #0f0520;
      --bg3: #130728;
      --bg4: #180a30;
      --border: rgba(180, 100, 255, 0.14);
      --border2: rgba(180, 100, 255, 0.30);
      --border3: rgba(210, 140, 255, 0.60);
      --text: rgba(248, 235, 255, 0.97);
      --text2: rgba(215, 185, 255, 0.85);
      --muted: rgba(185, 148, 245, 0.68);
      --faint: rgba(155, 65, 255, 0.08);
      --faint2: rgba(155, 65, 255, 0.16);
      --purple: #cc88ff;
      --purple2: #e0b0ff;
      --teal: #00ffcc;
      --gold: #ffcc00;
      --red: #ff4477;
      --green: #44ff99;
      --orange: #ff9955;
      --cyan: #55ddff;
      --accent: #dd99ff;
      --accent2: #aa55ee;
      --holo: rgba(185, 100, 255, 0.20);
      --left-w: 240px;
      --right-w: 320px;
      --topbar-h: 44px;
      --modebar-h: 36px;
      --statusbar-h: 24px;
      --font: 'Rajdhani', sans-serif;
      --mono: 'Share Tech Mono', monospace;
      --body: 'Exo 2', sans-serif;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
    }

    body {
      font-family: var(--font);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    /* Scanlines */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      z-index: 9999;
      pointer-events: none;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(185, 100, 255, 0.018) 3px, rgba(185, 100, 255, 0.018) 4px);
      mix-blend-mode: screen;
    }

    body::after {
      content: '';
      position: fixed;
      inset: 0;
      z-index: 9998;
      pointer-events: none;
      background: radial-gradient(ellipse at 20% 30%, rgba(100, 30, 200, 0.12) 0%, transparent 55%),
        radial-gradient(ellipse at 80% 75%, rgba(180, 60, 255, 0.09) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(60, 15, 120, 0.06) 0%, transparent 70%);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ TOPBAR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--topbar-h);
      z-index: 300;
      display: flex;
      align-items: center;
      background: rgba(10, 3, 20, 0.98);
      border-bottom: 1px solid var(--border2);
    }

    .topbar::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      opacity: .7;
    }

    .tb-brand {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 14px;
      border-right: 1px solid var(--border2);
      width: var(--left-w);
      flex-shrink: 0;
    }

    .back-btn {
      font-family: var(--mono);
      font-size: 9px;
      color: var(--muted);
      padding: 4px 8px;
      border: 1px solid var(--border2);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      text-decoration: none;
      transition: all .15s;
      white-space: nowrap;
    }

    .back-btn:hover {
      color: var(--accent);
      border-color: var(--border3);
    }

    .brand-name {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: .18em;
      color: var(--accent);
      text-shadow: 0 0 28px rgba(210, 140, 255, .8), 0 0 8px rgba(210, 140, 255, .4);
    }

    .brand-sub {
      font-family: var(--mono);
      font-size: 7px;
      color: var(--muted);
      letter-spacing: .12em;
    }

    .tb-mode-strip {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .mode-btn {
      padding: 5px 14px;
      font-family: var(--mono);
      font-size: 9px;
      font-weight: 700;
      letter-spacing: .1em;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--muted);
      cursor: pointer;
      transition: all .15s;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .mode-btn:hover {
      border-color: var(--border3);
      color: var(--accent);
    }

    .mode-btn.active {
      background: rgba(160, 80, 255, .1);
      border-color: var(--border3);
      color: var(--accent);
      box-shadow: 0 0 14px rgba(160, 80, 255, .18) inset;
    }

    .tb-right {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 12px;
      border-left: 1px solid var(--border2);
      width: var(--right-w);
      flex-shrink: 0;
      justify-content: flex-end;
    }

    .tb-chip {
      font-family: var(--mono);
      font-size: 8px;
      padding: 3px 8px;
      border-radius: 3px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: all .15s;
    }

    .tb-chip:hover {
      border-color: var(--border3);
      color: var(--accent);
    }

    .tb-chip.active {
      border-color: rgba(180, 100, 255, .4);
      color: var(--accent);
      background: rgba(160, 80, 255, .09);
    }

    .api-pill {
      display: flex;
      align-items: center;
      gap: 4px;
      font-family: var(--mono);
      font-size: 8px;
      color: var(--muted);
    }

    .api-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: var(--muted);
    }

    .api-dot.on {
      background: var(--green);
      box-shadow: 0 0 6px rgba(68, 255, 136, .6);
      animation: dot-live 2s infinite;
    }

    .api-dot.off {
      background: var(--red);
    }

    @keyframes dot-live {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: .4
      }
    }

    /* MODE BAR */
    .modebar {
      position: fixed;
      top: var(--topbar-h);
      left: 0;
      right: 0;
      height: var(--modebar-h);
      z-index: 299;
      display: flex;
      align-items: center;
      background: rgba(8, 3, 18, 0.96);
      border-bottom: 1px solid var(--border);
      gap: 0;
    }

    .mb-section {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 0 10px;
      border-right: 1px solid var(--border);
      height: 100%;
    }

    .mb-section:last-child {
      border-right: none;
      margin-left: auto;
    }

    .mb-btn {
      padding: 3px 8px;
      font-family: var(--mono);
      font-size: 8.5px;
      color: var(--muted);
      background: transparent;
      border: 1px solid transparent;
      border-radius: 3px;
      cursor: pointer;
      transition: all .12s;
      white-space: nowrap;
    }

    .mb-btn:hover {
      color: var(--accent);
      border-color: var(--border2);
    }

    .mb-btn.active {
      color: var(--accent);
      background: var(--faint2);
      border-color: var(--border2);
    }

    .mb-sep {
      width: 1px;
      height: 16px;
      background: var(--border);
      margin: 0 3px;
    }

    .mb-label {
      font-family: var(--mono);
      font-size: 7.5px;
      color: var(--muted);
      letter-spacing: .1em;
      text-transform: uppercase;
      margin-right: 4px;
    }

    .snap-val {
      font-family: var(--mono);
      font-size: 8px;
      color: var(--accent);
      padding: 2px 5px;
      background: var(--faint2);
      border: 1px solid var(--border2);
      border-radius: 2px;
      min-width: 30px;
      text-align: center;
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ LAYOUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .layout {
      position: fixed;
      top: calc(var(--topbar-h) + var(--modebar-h));
      bottom: var(--statusbar-h);
      left: 0;
      right: 0;
      display: flex;
    }

    /* LEFT PANEL */
    .left-panel {
      width: var(--left-w);
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      background: rgba(8, 3, 18, 0.97);
      border-right: 1px solid var(--border2);
      overflow: hidden;
      transition: width .2s cubic-bezier(.4, 0, .2, 1);
    }

    .left-panel.collapsed {
      width: 0;
    }

    .lp-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .lp-tab {
      flex: 1;
      padding: 6px 4px;
      font-family: var(--mono);
      font-size: 8px;
      font-weight: 700;
      letter-spacing: .08em;
      text-align: center;
      cursor: pointer;
      color: var(--muted);
      transition: all .15s;
      border-right: 1px solid var(--border);
    }

    .lp-tab:last-child {
      border-right: none;
    }

    .lp-tab.active {
      color: var(--accent);
      background: var(--faint2);
    }

    .lp-scroll {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .lp-scroll::-webkit-scrollbar {
      width: 2px;
    }

    .lp-scroll::-webkit-scrollbar-thumb {
      background: var(--border2);
    }

    /* Panel sections */
    .ps {
      border-bottom: 1px solid var(--border);
    }

    .ps-head {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 7px 10px;
      cursor: pointer;
      user-select: none;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--text2);
      background: rgba(155, 65, 255, 0.06);
    }

    .ps-head:hover {
      color: var(--accent);
      background: rgba(155, 65, 255, 0.12);
    }

    .ps-head .ps-arrow {
      font-size: 8px;
      transition: transform .15s;
      color: var(--muted);
    }

    .ps-head.open .ps-arrow {
      transform: rotate(90deg);
    }

    .ps-body {
      padding: 6px 8px 8px;
      display: none;
    }

    .ps-body.open {
      display: block;
    }

    /* Primitive grid */
    .prim-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
      margin-bottom: 4px;
    }

    .prim-btn {
      padding: 8px 4px;
      border-radius: 5px;
      background: rgba(160, 80, 255, 0.08);
      border: 1px solid var(--border2);
      cursor: pointer;
      text-align: center;
      transition: all .15s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    .prim-btn:hover {
      border-color: var(--border3);
      background: rgba(200, 130, 255, 0.16);
      transform: translateY(-1px);
    }

    .prim-btn:active {
      border-color: var(--accent);
      background: rgba(200, 130, 255, 0.24);
      transform: translateY(0);
    }

    .prim-btn .prim-icon {
      font-size: 16px;
      line-height: 1;
    }

    .prim-btn .prim-label {
      font-family: var(--mono);
      font-size: 8px;
      color: var(--text2);
    }

    .prim-btn:hover .prim-label {
      color: var(--accent);
    }

    /* ECE components */
    .ece-btn {
      width: 100%;
      padding: 6px 10px;
      border-radius: 4px;
      background: rgba(160, 80, 255, 0.06);
      border: 1px solid var(--border);
      cursor: pointer;
      text-align: left;
      transition: all .15s;
      display: flex;
      align-items: center;
      gap: 7px;
      margin-bottom: 3px;
    }

    .ece-btn:hover {
      border-color: var(--border3);
      background: rgba(200, 130, 255, 0.14);
    }

    .ece-btn .ece-icon {
      font-size: 13px;
      flex-shrink: 0;
    }

    .ece-btn .ece-label {
      font-family: var(--mono);
      font-size: 8.5px;
      color: var(--text2);
      font-weight: 600;
    }

    .ece-btn .ece-cat {
      font-family: var(--mono);
      font-size: 7px;
      color: var(--muted);
      margin-left: auto;
    }

    /* Transform controls */
    .xform-row {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
    }

    .xform-label {
      font-family: var(--mono);
      font-size: 7.5px;
      color: var(--muted);
      width: 18px;
      flex-shrink: 0;
      text-transform: uppercase;
    }

    .xform-inp {
      flex: 1;
      background: var(--faint2);
      border: 1px solid var(--border2);
      border-radius: 3px;
      padding: 3px 5px;
      font-family: var(--mono);
      font-size: 8.5px;
      color: var(--accent);
      outline: none;
      caret-color: var(--accent);
      text-align: right;
      transition: border-color .15s;
    }

    .xform-inp:focus {
      border-color: var(--border3);
    }

    .xform-axis {
      display: flex;
      gap: 2px;
      margin-bottom: 5px;
    }

    .axis-btn {
      flex: 1;
      padding: 3px;
      font-family: var(--mono);
      font-size: 8px;
      font-weight: 700;
      border-radius: 2px;
      border: 1px solid;
      cursor: pointer;
      transition: all .12s;
      text-align: center;
    }

    .axis-btn.x {
      color: #ff4466;
      border-color: rgba(255, 68, 102, .3);
      background: rgba(255, 68, 102, .06);
    }

    .axis-btn.y {
      color: #66ff66;
      border-color: rgba(102, 255, 102, .3);
      background: rgba(102, 255, 102, .06);
    }

    .axis-btn.z {
      color: #4488ff;
      border-color: rgba(68, 136, 255, .3);
      background: rgba(68, 136, 255, .06);
    }

    .axis-btn:hover {
      opacity: .8;
    }

    /* Material picker */
    .mat-presets {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 4px;
      margin-top: 4px;
    }

    .mat-swatch {
      height: 20px;
      border-radius: 3px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all .15s;
    }

    .mat-swatch:hover {
      transform: scale(1.15);
    }

    .mat-swatch.active {
      border-color: var(--accent);
    }

    /* Object list */
    .obj-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      transition: all .12s;
      font-family: var(--mono);
      font-size: 8.5px;
      color: var(--text2);
    }

    .obj-item:hover {
      background: var(--faint2);
      color: var(--accent);
    }

    .obj-item.selected {
      background: rgba(160, 80, 255, .08);
      color: var(--accent);
      border-left: 2px solid var(--accent);
    }

    .obj-item .obj-eye {
      font-size: 10px;
      color: var(--muted);
      cursor: pointer;
      margin-left: auto;
    }

    .obj-item .obj-del {
      font-size: 9px;
      color: var(--muted);
      cursor: pointer;
      opacity: 0;
      transition: opacity .12s;
    }

    .obj-item:hover .obj-del {
      opacity: 1;
    }

    .obj-item .obj-del:hover {
      color: var(--red);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ CANVAS ZONE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .canvas-zone {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #04010c;
    }

    #three-canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Move mode cursor */
    .canvas-zone.move-mode {
      cursor: crosshair;
    }

    .canvas-zone.dragging-obj {
      cursor: grabbing;
    }

    /* Touch-friendly: bigger buttons on tablets */
    @media (pointer:coarse) {
      .prim-btn {
        padding: 14px 6px;
      }

      .mode-btn,
      .mb-btn,
      .cam-btn,
      .tb-chip {
        padding: 8px 14px;
        font-size: 10px;
      }

      .ece-btn {
        padding: 10px 12px;
      }

      .tb-brand {
        width: 180px;
      }

      :root {
        --left-w: 200px;
        --right-w: 280px;
      }

      .xform-inp {
        font-size: 12px;
        padding: 6px 8px;
      }

      .b-inp {
        font-size: 13px;
        padding: 10px 12px;
      }

      .b-send {
        width: 40px;
        height: 40px;
        font-size: 16px;
      }
    }

    @media (max-width:900px) {

      .left-panel,
      .right-panel {
        position: fixed;
        z-index: 350;
        top: calc(var(--topbar-h)+var(--modebar-h));
        bottom: var(--statusbar-h);
      }

      .left-panel {
        left: 0;
      }

      .right-panel {
        right: 0;
      }

      .left-panel.collapsed,
      .right-panel.collapsed {
        width: 0;
      }
    }

    /* HUD */
    .hud-tl {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .hud-tr {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 20;
    }

    .hud-br {
      position: absolute;
      bottom: 12px;
      right: 12px;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-end;
    }

    .hud-pill {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: var(--mono);
      font-size: 9px;
      background: rgba(10, 3, 22, .92);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border2);
      color: var(--text2);
    }

    .hud-pill .led {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(210, 140, 255, .9);
      animation: dot-live 2s infinite;
    }

    .hud-coord {
      font-family: var(--mono);
      font-size: 8.5px;
      color: rgba(210, 160, 255, .7);
      letter-spacing: .04em;
    }

    /* Move hint overlay */
    .move-hint {
      position: absolute;
      bottom: 56px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      padding: 8px 18px;
      border-radius: 6px;
      font-family: var(--mono);
      font-size: 10px;
      background: rgba(10, 3, 20, .96);
      border: 1px solid rgba(210, 140, 255, .55);
      color: #e8c0ff;
      box-shadow: 0 0 24px rgba(185, 100, 255, .3), 0 4px 16px rgba(0, 0, 0, .6);
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s;
      white-space: nowrap;
      letter-spacing: .04em;
    }

    .move-hint.show {
      opacity: 1;
    }

    /* Active transform mode banner */
    .tx-mode-banner {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 26;
      padding: 5px 16px;
      border-radius: 4px;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: .14em;
      background: rgba(10, 3, 20, .95);
      border: 2px solid;
      box-shadow: 0 0 20px, 0 4px 16px rgba(0, 0, 0, .5);
      opacity: 0;
      pointer-events: none;
      transition: all .2s;
      white-space: nowrap;
    }

    .tx-mode-banner.show {
      opacity: 1;
    }

    .tx-mode-banner.grab {
      color: #dd99ff;
      border-color: rgba(210, 140, 255, .7);
      box-shadow: 0 0 20px rgba(210, 140, 255, .25), 0 4px 16px rgba(0, 0, 0, .5);
    }

    .tx-mode-banner.rotate {
      color: #55ddff;
      border-color: rgba(85, 221, 255, .7);
      box-shadow: 0 0 20px rgba(85, 221, 255, .25), 0 4px 16px rgba(0, 0, 0, .5);
    }

    .tx-mode-banner.scale {
      color: #44ff99;
      border-color: rgba(68, 255, 153, .7);
      box-shadow: 0 0 20px rgba(68, 255, 153, .25), 0 4px 16px rgba(0, 0, 0, .5);
    }

    /* Gizmo */
    .gizmo-wrap {
      position: absolute;
      bottom: 12px;
      left: 12px;
      z-index: 20;
      width: 70px;
      height: 70px;
    }

    #gizmo-canvas {
      width: 70px;
      height: 70px;
    }

    /* Render tag */
    .render-tag {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      padding: 8px 20px;
      border-radius: 4px;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: .2em;
      background: rgba(160, 80, 255, .09);
      border: 1px solid rgba(160, 80, 255, .45);
      color: var(--accent);
      opacity: 0;
      pointer-events: none;
      transition: opacity .3s;
      text-transform: uppercase;
    }

    .render-tag.show {
      opacity: 1;
    }

    .render-tag.pulse {
      animation: rend-pulse .5s ease-in-out 3;
    }

    @keyframes rend-pulse {

      0%,
      100% {
        opacity: 1;
        box-shadow: 0 0 20px rgba(160, 80, 255, .35)
      }

      50% {
        opacity: .3;
        box-shadow: none
      }
    }

    /* Camera buttons */
    .cam-strip {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: flex;
      gap: 3px;
    }

    .cam-btn {
      padding: 4px 9px;
      font-family: var(--mono);
      font-size: 8px;
      background: rgba(8, 3, 15, .88);
      border: 1px solid var(--border2);
      color: var(--muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all .15s;
    }

    .cam-btn:hover {
      color: var(--accent);
      border-color: var(--border3);
    }

    /* Right panel */
    .right-panel {
      width: var(--right-w);
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border2);
      background: rgba(6, 2, 14, 0.96);
      backdrop-filter: blur(20px);
      overflow: hidden;
      transition: width .22s cubic-bezier(.4, 0, .2, 1);
    }

    .right-panel.collapsed {
      width: 0;
    }

    .rp-header {
      padding: 10px 12px 8px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .rp-logo {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: .04em;
      flex: 1;
      font-family: var(--font);
    }

    .rp-logo em {
      color: var(--accent);
      font-style: normal;
      text-shadow: 0 0 14px rgba(160, 80, 255, .55);
    }

    .rp-badge {
      padding: 2px 7px;
      border-radius: 3px;
      font-family: var(--mono);
      font-size: 7.5px;
      font-weight: 700;
      background: rgba(160, 80, 255, .08);
      color: var(--accent);
      border: 1px solid var(--border2);
      letter-spacing: .1em;
    }

    /* Scene library */
    .scene-lib {
      flex-shrink: 0;
      border-bottom: 1px solid var(--border);
    }

    .scene-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .scene-tab {
      flex: 1;
      padding: 4px;
      font-family: var(--mono);
      font-size: 7.5px;
      text-align: center;
      cursor: pointer;
      color: var(--muted);
      border-right: 1px solid var(--border);
      transition: all .12s;
      letter-spacing: .06em;
    }

    .scene-tab:last-child {
      border-right: none;
    }

    .scene-tab.active {
      color: var(--accent);
      background: var(--faint2);
    }

    .scene-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3px;
      padding: 6px;
    }

    .scene-card {
      padding: 7px 9px;
      border-radius: 5px;
      border: 1px solid var(--border2);
      background: rgba(155, 65, 255, 0.07);
      cursor: pointer;
      transition: all .15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .scene-card:hover {
      border-color: var(--border3);
      background: rgba(185, 100, 255, 0.15);
      transform: translateY(-1px);
    }

    .scene-card.active {
      border-color: rgba(210, 140, 255, .55);
      background: rgba(185, 100, 255, 0.14);
    }

    .scene-icon {
      font-size: 14px;
      flex-shrink: 0;
    }

    .scene-info .scene-name {
      font-family: var(--mono);
      font-size: 8.5px;
      color: var(--text2);
      display: block;
    }

    .scene-info .scene-cat {
      font-family: var(--mono);
      font-size: 7px;
      color: var(--muted);
      display: block;
    }

    .scene-card:hover .scene-name,
    .scene-card.active .scene-name {
      color: var(--accent);
    }

    /* Chat */
    .blitz-feed {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .blitz-feed::-webkit-scrollbar {
      width: 2px;
    }

    .blitz-feed::-webkit-scrollbar-thumb {
      background: var(--border2);
    }

    .b-msg {
      display: flex;
      flex-direction: column;
      gap: 2px;
      max-width: 97%;
    }

    .b-msg.u {
      align-self: flex-end;
      align-items: flex-end;
    }

    .b-msg.b {
      align-self: flex-start;
    }

    .b-who {
      font-family: var(--mono);
      font-size: 7px;
      color: var(--muted);
      letter-spacing: .08em;
      margin-bottom: 1px;
    }

    .b-bubble {
      padding: 7px 10px;
      border-radius: 4px;
      font-family: var(--body);
      font-size: 11px;
      line-height: 1.55;
      cursor: text;
      user-select: text;
    }

    .b-msg.u .b-bubble {
      background: rgba(160, 80, 255, .07);
      border: 1px solid rgba(160, 80, 255, .16);
    }

    .b-msg.b .b-bubble {
      background: rgba(160, 80, 255, .03);
      border: 1px solid rgba(160, 80, 255, .09);
    }

    .b-bubble code {
      font-family: var(--mono);
      font-size: 9px;
      background: rgba(160, 80, 255, .12);
      padding: 1px 4px;
      border-radius: 2px;
      color: var(--accent);
    }

    .b-bubble pre {
      background: rgba(0, 0, 0, .7);
      border: 1px solid var(--border2);
      border-radius: 4px;
      padding: 8px;
      font-family: var(--mono);
      font-size: 8px;
      color: rgba(200, 140, 255, .8);
      overflow-x: auto;
      margin: 4px 0;
      white-space: pre-wrap;
    }

    .b-ts {
      font-family: var(--mono);
      font-size: 7px;
      color: var(--muted);
    }

    .b-typing {
      align-self: flex-start;
      padding: 8px 11px;
      background: rgba(160, 80, 255, .04);
      border: 1px solid rgba(160, 80, 255, .1);
      border-radius: 4px;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .tdot {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: rgba(160, 80, 255, .55);
      animation: tdot-b 1.2s ease-in-out infinite;
    }

    .tdot:nth-child(2) {
      animation-delay: .2s
    }

    .tdot:nth-child(3) {
      animation-delay: .4s
    }

    @keyframes tdot-b {

      0%,
      80%,
      100% {
        transform: scale(1);
        opacity: .4
      }

      40% {
        transform: scale(1.4);
        opacity: 1
      }
    }

    .inject-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
      padding: 3px 9px;
      border-radius: 3px;
      font-family: var(--mono);
      font-size: 8px;
      font-weight: 700;
      background: rgba(160, 80, 255, .09);
      border: 1px solid rgba(160, 80, 255, .28);
      color: var(--accent);
      cursor: pointer;
      transition: all .15s;
    }

    .inject-btn:hover {
      background: rgba(160, 80, 255, .18);
    }

    .render-cta {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin: 0 12px 5px;
      padding: 6px;
      border-radius: 4px;
      font-family: var(--mono);
      font-size: 8.5px;
      font-weight: 700;
      letter-spacing: .08em;
      background: rgba(160, 80, 255, .08);
      border: 1px solid rgba(160, 80, 255, .25);
      color: var(--accent);
      cursor: pointer;
      transition: all .15s;
    }

    .render-cta:hover {
      background: rgba(160, 80, 255, .18);
      border-color: var(--border3);
    }

    /* Input */
    .blitz-inp-area {
      padding: 8px 10px 10px;
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .b-inp-row {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .b-inp {
      flex: 1;
      background: rgba(160, 80, 255, .03);
      border: 1px solid var(--border2);
      border-radius: 4px;
      padding: 6px 9px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--text);
      outline: none;
      caret-color: var(--accent);
      transition: border-color .15s;
    }

    .b-inp:focus {
      border-color: var(--border3);
    }

    .b-inp::placeholder {
      color: var(--muted);
    }

    .b-send {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      flex-shrink: 0;
      cursor: pointer;
      border: 1px solid rgba(160, 80, 255, .25);
      background: rgba(160, 80, 255, .07);
      color: rgba(160, 80, 255, .75);
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .15s;
    }

    .b-send:hover {
      background: rgba(160, 80, 255, .18);
      color: var(--accent);
    }

    .quick-prompts {
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
      margin-top: 5px;
    }

    .qp-btn {
      padding: 2px 7px;
      border-radius: 2px;
      font-family: var(--mono);
      font-size: 7.5px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: all .12s;
    }

    .qp-btn:hover {
      border-color: var(--border2);
      color: var(--accent);
      background: var(--faint);
    }

    /* Status bar */
    .statusbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--statusbar-h);
      z-index: 300;
      display: flex;
      align-items: center;
      background: rgba(12, 4, 26, 0.97);
      border-top: 1px solid var(--border2);
      font-family: var(--mono);
      font-size: 8.5px;
    }

    .sb-item {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 11px;
      border-right: 1px solid var(--border);
      height: 100%;
      color: rgba(200, 160, 255, .65);
      white-space: nowrap;
    }

    .sb-item:last-child {
      border-right: none;
      margin-left: auto;
    }

    .sb-val {
      color: rgba(220, 180, 255, .95);
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 36px;
      left: 50%;
      transform: translateX(-50%) translateY(8px);
      z-index: 9000;
      background: rgba(12, 4, 26, .98);
      border: 1px solid var(--border2);
      border-radius: 5px;
      padding: 7px 16px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--text);
      opacity: 0;
      pointer-events: none;
      transition: all .25s cubic-bezier(.34, 1.56, .64, 1);
      white-space: nowrap;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .toast.purple {
      border-color: rgba(210, 140, 255, .55);
      color: var(--accent);
      box-shadow: 0 0 20px rgba(185, 100, 255, .2);
    }

    /* Popup menu for light/curve/empty */
    .popup-menu {
      position: fixed;
      z-index: 400;
      background: rgba(12, 4, 26, .99);
      border: 1px solid var(--border3);
      border-radius: 7px;
      padding: 5px;
      min-width: 150px;
      display: none;
      box-shadow: 0 8px 40px rgba(0, 0, 0, .7), 0 0 24px rgba(185, 100, 255, .1);
    }

    .popup-menu.open {
      display: block;
    }

    .popup-item {
      padding: 6px 12px;
      font-family: var(--mono);
      font-size: 9.5px;
      color: var(--text2);
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all .12s;
    }

    .popup-item:hover {
      background: rgba(185, 100, 255, .18);
      color: var(--accent);
    }

    .popup-sep {
      height: 1px;
      background: var(--border2);
      margin: 3px 0;
    }

    .popup-label {
      padding: 4px 12px;
      font-family: var(--mono);
      font-size: 7.5px;
      color: var(--muted);
      letter-spacing: .12em;
      text-transform: uppercase;
    }

    /* Axis constraint HUD - large center indicator */
    .axis-hud {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      padding: 5px 16px;
      border-radius: 4px;
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 700;
      letter-spacing: .2em;
      border: 1px solid;
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s;
    }

    .axis-hud.show {
      opacity: 1;
    }

    .axis-hud.ax-x {
      color: #ff5577;
      border-color: rgba(255, 85, 119, .5);
      background: rgba(255, 85, 119, .1);
    }

    .axis-hud.ax-y {
      color: #55ff88;
      border-color: rgba(85, 255, 136, .5);
      background: rgba(85, 255, 136, .1);
    }

    .axis-hud.ax-z {
      color: #55aaff;
      border-color: rgba(85, 170, 255, .5);
      background: rgba(85, 170, 255, .1);
    }

    .axis-hud.ax-free {
      color: var(--accent);
      border-color: rgba(210, 140, 255, .5);
      background: rgba(185, 100, 255, .1);
    }
  </style>
</head>

<body>

  <!-- ‚ïê‚ïê‚ïê TOPBAR ‚ïê‚ïê‚ïê -->
  <div class="topbar">
    <div class="tb-brand">
      <a href="index.html" class="back-btn">‚Üê Hub</a>
      <div>
        <div class="brand-name">STUDIO</div>
        <div class="brand-sub">B.L.I.T.Z. ¬∑ 3D LAB v3</div>
      </div>
    </div>
    <div class="tb-mode-strip">
      <button class="mode-btn active" id="mode-object" onclick="setMode('object')">Object</button>
      <button class="mode-btn" id="mode-edit" onclick="setMode('edit')">Edit</button>
      <button class="mode-btn" id="mode-sim" onclick="setMode('sim')">Simulate</button>
      <button class="mode-btn" id="mode-render" onclick="setMode('render')">Render</button>
    </div>
    <div class="tb-right">
      <button class="tb-chip" id="chip-wire" onclick="toggleWireframe()">Wireframe</button>
      <button class="tb-chip active" id="chip-grid" onclick="toggleGrid()">Grid</button>
      <button class="tb-chip" id="chip-axes" onclick="toggleAxes()">Axes</button>
      <button class="tb-chip" id="chip-anim" onclick="toggleAnimation()">‚ñ∂ Anim</button>
      <button class="tb-chip" onclick="clearScene()">‚¨° Clear</button>
      <button class="tb-chip" onclick="toggleBlitz()">‚ö° Blitz</button>
      <div class="api-pill">
        <div class="api-dot" id="api-dot"></div><span id="api-lbl">‚Äî</span>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê MODE BAR ‚ïê‚ïê‚ïê -->
  <div class="modebar">
    <div class="mb-section">
      <span class="mb-label">Add</span>
      <button class="mb-btn" onclick="addPrimitive('box')">‚¨ú Mesh</button>
      <button class="mb-btn" onclick="openPopup('curve-menu', event)">„Ä∞ Curve</button>
      <button class="mb-btn" onclick="openPopup('light-menu', event)">üí° Light</button>
      <button class="mb-btn" onclick="openPopup('empty-menu', event)">‚äï Empty</button>
    </div>
    <div class="mb-section">
      <span class="mb-label">Transform</span>
      <button class="mb-btn active" id="tx-select" onclick="setTxMode('select')">‚óà Select</button>
      <button class="mb-btn" id="tx-move" onclick="setTxMode('move')">‚äï Move</button>
      <button class="mb-btn" id="tx-rotate" onclick="setTxMode('rotate')">‚Üª Rotate</button>
      <button class="mb-btn" id="tx-scale" onclick="setTxMode('scale')">‚üê Scale</button>
    </div>
    <div class="mb-section">
      <span class="mb-label">Snap</span>
      <button class="mb-btn" id="snap-btn" onclick="toggleSnap()">‚äû Snap</button>
      <div class="snap-val" id="snap-val">0.5</div>
    </div>
    <div class="mb-section">
      <span class="mb-label">Viewport</span>
      <button class="mb-btn" onclick="setCameraPreset('persp')">Persp</button>
      <button class="mb-btn" onclick="setCameraPreset('ortho')">Ortho</button>
      <button class="mb-btn" onclick="setCameraPreset('top')">Top</button>
      <button class="mb-btn" onclick="setCameraPreset('front')">Front</button>
      <button class="mb-btn" onclick="setCameraPreset('side')">Side</button>
      <button class="mb-btn" onclick="resetCamera()">Reset</button>
    </div>
    <div class="mb-section">
      <span id="sb-coords" class="mb-label" style="color:rgba(160,80,255,.7);font-size:8px;letter-spacing:.08em;">X:0.00
        Y:0.00 Z:0.00</span>
    </div>
    <div class="mb-section">
      <button class="mb-btn" onclick="toggleLeftPanel()" title="Toggle left panel">‚ò∞ Panels</button>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê LAYOUT ‚ïê‚ïê‚ïê -->
  <div class="layout">

    <!-- LEFT PANEL -->
    <div class="left-panel" id="left-panel">
      <div class="lp-tabs">
        <div class="lp-tab active" id="lt-add" onclick="switchLTab('add')">ADD</div>
        <div class="lp-tab" id="lt-props" onclick="switchLTab('props')">PROPS</div>
        <div class="lp-tab" id="lt-scene" onclick="switchLTab('scene')">SCENE</div>
      </div>
      <div class="lp-scroll">

        <!-- ADD TAB -->
        <div id="ltab-add">
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Mesh</div>
            <div class="ps-body open">
              <div class="prim-grid">
                <div class="prim-btn" onclick="addPrimitive('box')">
                  <div class="prim-icon">‚¨ú</div>
                  <div class="prim-label">Cube</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('sphere')">
                  <div class="prim-icon">‚ö™</div>
                  <div class="prim-label">Sphere</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('cylinder')">
                  <div class="prim-icon">‚¨°</div>
                  <div class="prim-label">Cylinder</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('cone')">
                  <div class="prim-icon">‚ñ≥</div>
                  <div class="prim-label">Cone</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('torus')">
                  <div class="prim-icon">‚óé</div>
                  <div class="prim-label">Torus</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('plane')">
                  <div class="prim-icon">‚ñ¨</div>
                  <div class="prim-label">Plane</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('knot')">
                  <div class="prim-icon">‚àû</div>
                  <div class="prim-label">Knot</div>
                </div>
                <div class="prim-btn" onclick="addPrimitive('ico')">
                  <div class="prim-icon">‚óà</div>
                  <div class="prim-label">Ico</div>
                </div>
              </div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> ECE Components</div>
            <div class="ps-body open">
              <div class="ece-btn" onclick="addECE('resistor')"><span class="ece-icon">‚üä</span><span
                  class="ece-label">Resistor</span><span class="ece-cat">PASSIVE</span></div>
              <div class="ece-btn" onclick="addECE('capacitor')"><span class="ece-icon">‚ä£‚ä¢</span><span
                  class="ece-label">Capacitor</span><span class="ece-cat">PASSIVE</span></div>
              <div class="ece-btn" onclick="addECE('inductor')"><span class="ece-icon">‚àø‚àø</span><span
                  class="ece-label">Inductor</span><span class="ece-cat">PASSIVE</span></div>
              <div class="ece-btn" onclick="addECE('transistor')"><span class="ece-icon">‚ä≥</span><span
                  class="ece-label">Transistor</span><span class="ece-cat">ACTIVE</span></div>
              <div class="ece-btn" onclick="addECE('opamp')"><span class="ece-icon">‚ñ∑</span><span
                  class="ece-label">Op-Amp</span><span class="ece-cat">ACTIVE</span></div>
              <div class="ece-btn" onclick="addECE('gate_and')"><span class="ece-icon">‚äì</span><span
                  class="ece-label">AND Gate</span><span class="ece-cat">LOGIC</span></div>
              <div class="ece-btn" onclick="addECE('gate_or')"><span class="ece-icon">‚äî</span><span class="ece-label">OR
                  Gate</span><span class="ece-cat">LOGIC</span></div>
              <div class="ece-btn" onclick="addECE('gate_not')"><span class="ece-icon">‚äø</span><span
                  class="ece-label">NOT Gate</span><span class="ece-cat">LOGIC</span></div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Science</div>
            <div class="ps-body">
              <div class="ece-btn" onclick="addECE('atom')"><span class="ece-icon">‚öõ</span><span class="ece-label">Atom
                  Model</span><span class="ece-cat">PHYSICS</span></div>
              <div class="ece-btn" onclick="addECE('wave')"><span class="ece-icon">„Ä∞</span><span
                  class="ece-label">Wave</span><span class="ece-cat">EM</span></div>
              <div class="ece-btn" onclick="addECE('em_field')"><span class="ece-icon">‚ü≥</span><span
                  class="ece-label">EM Field</span><span class="ece-cat">EM</span></div>
              <div class="ece-btn" onclick="addECE('vector_field')"><span class="ece-icon">‚Üó</span><span
                  class="ece-label">Vector Field</span><span class="ece-cat">MATH</span></div>
              <div class="ece-btn" onclick="addECE('fft')"><span class="ece-icon">‚äû</span><span class="ece-label">FFT
                  Spectrum</span><span class="ece-cat">SIGNAL</span></div>
              <div class="ece-btn" onclick="addECE('phasor')"><span class="ece-icon">‚Üª</span><span
                  class="ece-label">Phasor</span><span class="ece-cat">AC</span></div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Lights</div>
            <div class="ps-body">
              <div class="prim-grid">
                <div class="prim-btn" onclick="addLight('point')">
                  <div class="prim-icon">üí°</div>
                  <div class="prim-label">Point</div>
                </div>
                <div class="prim-btn" onclick="addLight('spot')">
                  <div class="prim-icon">üî¶</div>
                  <div class="prim-label">Spot</div>
                </div>
                <div class="prim-btn" onclick="addLight('dir')">
                  <div class="prim-icon">‚òÄÔ∏è</div>
                  <div class="prim-label">Direct</div>
                </div>
                <div class="prim-btn" onclick="addLight('ambient')">
                  <div class="prim-icon">üåê</div>
                  <div class="prim-label">Ambient</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- PROPS TAB -->
        <div id="ltab-props" style="display:none">
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Transform</div>
            <div class="ps-body open">
              <div
                style="font-family:var(--mono);font-size:7px;color:var(--muted);margin-bottom:4px;letter-spacing:.1em;">
                TIP: G=Move ‚Ä¢ R=Rotate ‚Ä¢ S=Scale ‚Ä¢ X/Y/Z=Constrain
              </div>
              <div class="xform-axis">
                <div class="axis-btn x">X</div>
                <div class="axis-btn y">Y</div>
                <div class="axis-btn z">Z</div>
              </div>
              <div style="font-family:var(--mono);font-size:7.5px;color:var(--muted);margin-bottom:3px;">LOCATION</div>
              <div class="xform-row"><span class="xform-label" style="color:#ff4466">X</span><input class="xform-inp"
                  id="px" value="0.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#66ff66">Y</span><input class="xform-inp"
                  id="py" value="0.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#4488ff">Z</span><input class="xform-inp"
                  id="pz" value="0.000" oninput="applyTransform()" /></div>
              <div style="font-family:var(--mono);font-size:7.5px;color:var(--muted);margin:5px 0 3px;">ROTATION (¬∞)
              </div>
              <div class="xform-row"><span class="xform-label" style="color:#ff4466">X</span><input class="xform-inp"
                  id="rx" value="0.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#66ff66">Y</span><input class="xform-inp"
                  id="ry" value="0.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#4488ff">Z</span><input class="xform-inp"
                  id="rz" value="0.000" oninput="applyTransform()" /></div>
              <div style="font-family:var(--mono);font-size:7.5px;color:var(--muted);margin:5px 0 3px;">SCALE</div>
              <div class="xform-row"><span class="xform-label" style="color:#ff4466">X</span><input class="xform-inp"
                  id="sx" value="1.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#66ff66">Y</span><input class="xform-inp"
                  id="sy" value="1.000" oninput="applyTransform()" /></div>
              <div class="xform-row"><span class="xform-label" style="color:#4488ff">Z</span><input class="xform-inp"
                  id="sz" value="1.000" oninput="applyTransform()" /></div>
              <div style="margin-top:6px;display:flex;gap:3px;">
                <button class="mb-btn" style="flex:1;padding:4px;" onclick="duplicateSelected()">‚ßâ Dupe</button>
                <button class="mb-btn" style="flex:1;padding:4px;color:var(--red);" onclick="deleteSelected()">‚úï
                  Delete</button>
              </div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Material</div>
            <div class="ps-body open">
              <div class="xform-row" style="margin-bottom:5px;">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);flex:1;">COLOR</span>
                <input type="color" id="mat-color" value="#a050ff"
                  style="width:50px;height:18px;border:1px solid var(--border2);border-radius:2px;background:none;cursor:pointer;"
                  oninput="applyMaterial()" />
              </div>
              <div class="xform-row">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">METALNESS</span>
                <input type="range" id="mat-metal" min="0" max="1" step="0.01" value="0.3"
                  style="flex:1;margin-left:6px;accent-color:var(--accent);" oninput="applyMaterial()" />
              </div>
              <div class="xform-row">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">ROUGHNESS</span>
                <input type="range" id="mat-rough" min="0" max="1" step="0.01" value="0.4"
                  style="flex:1;margin-left:6px;accent-color:var(--accent);" oninput="applyMaterial()" />
              </div>
              <div class="xform-row">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">EMISSIVE</span>
                <input type="range" id="mat-emissive" min="0" max="2" step="0.01" value="0.2"
                  style="flex:1;margin-left:6px;accent-color:var(--accent);" oninput="applyMaterial()" />
              </div>
              <div class="xform-row">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">OPACITY</span>
                <input type="range" id="mat-opacity" min="0.1" max="1" step="0.01" value="1"
                  style="flex:1;margin-left:6px;accent-color:var(--accent);" oninput="applyMaterial()" />
              </div>
              <div style="font-family:var(--mono);font-size:7.5px;color:var(--muted);margin:6px 0 4px;">PRESETS</div>
              <div class="mat-presets">
                <div class="mat-swatch" style="background:linear-gradient(135deg,#aaa,#444)"
                  onclick="applyMatPreset('metal',event)" title="Metal"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#00ffcc,#004433)"
                  onclick="applyMatPreset('holo',event)" title="Holo"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#ff4466,#330011)"
                  onclick="applyMatPreset('hot',event)" title="Hot"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#4488ff,#001144)"
                  onclick="applyMatPreset('cool',event)" title="Cool"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#ffcc00,#443300)"
                  onclick="applyMatPreset('gold',event)" title="Gold"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#fff,#444)"
                  onclick="applyMatPreset('glass',event)" title="Glass"></div>
                <div class="mat-swatch active" style="background:linear-gradient(135deg,#cc88ff,#220044)"
                  onclick="applyMatPreset('plasma',event)" title="Plasma"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#a050ff,#1a0066)"
                  onclick="applyMatPreset('purple',event)" title="Purple"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#ff8800,#331100)"
                  onclick="applyMatPreset('ember',event)" title="Ember"></div>
                <div class="mat-swatch" style="background:linear-gradient(135deg,#00ff88,#001a0a)"
                  onclick="applyMatPreset('neon',event)" title="Neon"></div>
              </div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Object Info</div>
            <div class="ps-body open" id="obj-info-panel">
              <div style="font-family:var(--mono);font-size:8px;color:var(--muted);padding:4px 0;">No object selected
              </div>
            </div>
          </div>
        </div>

        <!-- SCENE TAB -->
        <div id="ltab-scene" style="display:none">
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Outliner</div>
            <div class="ps-body open" id="outliner-list">
              <div style="font-family:var(--mono);font-size:8px;color:var(--muted);padding:4px 0;">Scene is empty</div>
            </div>
          </div>
          <div class="ps">
            <div class="ps-head open" onclick="togglePS(this)"><span class="ps-arrow">‚ñ∂</span> Render Settings</div>
            <div class="ps-body open">
              <div class="xform-row"><span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">BG
                  COLOR</span>
                <input type="color" value="#04010c" id="bg-color"
                  style="width:40px;height:16px;border:1px solid var(--border2);border-radius:2px;background:none;cursor:pointer;"
                  oninput="renderer.setClearColor(this.value,1)" />
              </div>
              <div class="xform-row" style="margin-top:5px;">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">SHADOWS</span>
                <input type="checkbox" id="shadows-cb" checked onchange="renderer.shadowMap.enabled=this.checked;"
                  style="margin-left:auto;accent-color:var(--accent);" />
              </div>
              <div class="xform-row">
                <span style="font-family:var(--mono);font-size:7.5px;color:var(--muted);">FOG</span>
                <input type="checkbox" id="fog-cb" onchange="toggleFog(this.checked);"
                  style="margin-left:auto;accent-color:var(--accent);" />
              </div>
            </div>
          </div>
        </div>

      </div><!-- /lp-scroll -->
    </div><!-- /left-panel -->

    <!-- 3D CANVAS -->
    <div class="canvas-zone" id="canvas-zone">
      <canvas id="three-canvas"></canvas>

      <div class="hud-tl">
        <div class="hud-pill">
          <div class="led"></div><span id="scene-name">Empty Scene</span>
        </div>
        <div class="hud-pill" id="poly-hud" style="display:none;font-family:var(--mono);font-size:8px;">0 verts</div>
        <div class="hud-pill" id="mode-hud" style="font-family:var(--mono);font-size:8px;color:rgba(160,80,255,.7);">‚óà
          SELECT</div>
      </div>

      <div class="render-tag" id="render-tag">‚¨° RENDERED</div>

      <div class="cam-strip">
        <button class="cam-btn" onclick="setCameraPreset('front')">Front</button>
        <button class="cam-btn" onclick="setCameraPreset('top')">Top</button>
        <button class="cam-btn" onclick="setCameraPreset('side')">Side</button>
        <button class="cam-btn" onclick="setCameraPreset('persp')">Persp</button>
        <button class="cam-btn" onclick="resetCamera()">Reset</button>
      </div>

      <div class="hud-br">
        <div class="hud-coord" id="hud-fps">60 FPS</div>
        <div class="hud-coord" id="hud-obj">0 objects</div>
      </div>

      <div class="gizmo-wrap"><canvas id="gizmo-canvas" width="70" height="70"></canvas></div>
      <div class="move-hint" id="move-hint">üñ± Drag to move ¬∑ X/Y/Z axis lock ¬∑ Enter ‚úì ¬∑ Esc ‚úï</div>
      <div class="tx-mode-banner" id="tx-mode-banner">‚äï GRAB</div>
      <div class="axis-hud" id="axis-hud">FREE</div>
    </div>

    <!-- RIGHT PANEL - BLITZ -->
    <div class="right-panel" id="right-panel">
      <div class="rp-header">
        <div class="rp-logo">B.L.I.T.<em>Z</em>.</div>
        <div class="rp-badge">3D STUDIO</div>
        <button class="tb-chip" onclick="toggleBlitz()" style="padding:2px 6px;font-size:8px;">‚úï</button>
      </div>
      <div class="scene-lib">
        <div class="scene-tabs">
          <div class="scene-tab active" id="stab-physics" onclick="switchSceneTab('physics')">PHYSICS</div>
          <div class="scene-tab" id="stab-ece" onclick="switchSceneTab('ece')">ECE</div>
          <div class="scene-tab" id="stab-math" onclick="switchSceneTab('math')">MATH</div>
          <div class="scene-tab" id="stab-cs" onclick="switchSceneTab('cs')">CS</div>
        </div>
        <div class="scene-grid" id="scene-grid"></div>
      </div>
      <div class="blitz-feed" id="blitz-feed"></div>
      <button class="render-cta" onclick="renderFromChat()">‚¨° Re-render Last Scene</button>
      <div class="blitz-inp-area">
        <div class="b-inp-row">
          <input type="text" class="b-inp" id="b-inp" placeholder='Ask Blitz to build a 3D scene‚Ä¶' />
          <button class="b-send" onclick="sendStudio()">‚Üë</button>
        </div>
        <div class="quick-prompts">
          <button class="qp-btn" onclick="quickP('3D op-amp circuit with signal flow')">Op-Amp</button>
          <button class="qp-btn" onclick="quickP('electromagnetic wave propagation')">EM Wave</button>
          <button class="qp-btn" onclick="quickP('binary tree data structure')">Bin Tree</button>
          <button class="qp-btn" onclick="quickP('fourier transform visualization')">FFT</button>
          <button class="qp-btn" onclick="quickP('neural network layers')">Neural Net</button>
        </div>
      </div>
    </div>

  </div><!-- /layout -->

  <!-- POPUP MENUS -->
  <div class="popup-menu" id="light-menu">
    <div class="popup-label">Light Type</div>
    <div class="popup-item" onclick="addLight('point');closePopups()">üí° Point Light</div>
    <div class="popup-item" onclick="addLight('spot');closePopups()">üî¶ Spot Light</div>
    <div class="popup-item" onclick="addLight('dir');closePopups()">‚òÄÔ∏è Directional</div>
    <div class="popup-item" onclick="addLight('ambient');closePopups()">üåê Ambient</div>
  </div>
  <div class="popup-menu" id="curve-menu">
    <div class="popup-label">Curve Type</div>
    <div class="popup-item" onclick="addCurve('bezier');closePopups()">„Ä∞ B√©zier Curve</div>
    <div class="popup-item" onclick="addCurve('circle');closePopups()">‚óé Circle</div>
    <div class="popup-item" onclick="addCurve('helix');closePopups()">‚àø Helix</div>
  </div>
  <div class="popup-menu" id="empty-menu">
    <div class="popup-label">Empty Type</div>
    <div class="popup-item" onclick="addEmpty('axes');closePopups()">‚äï Axes</div>
    <div class="popup-item" onclick="addEmpty('sphere');closePopups()">‚äô Sphere</div>
    <div class="popup-item" onclick="addEmpty('cube');closePopups()">‚¨° Cube</div>
  </div>

  <div class="statusbar">
    <div class="sb-item">‚¨° <span class="sb-val" id="sb-mode">OBJECT MODE</span></div>
    <div class="sb-item"><span class="sb-val" id="sb-verts">0</span> verts</div>
    <div class="sb-item"><span class="sb-val" id="sb-objs">0</span> objects</div>
    <div class="sb-item" id="sb-selected-item" style="display:none">SEL: <span class="sb-val" id="sb-sel">‚Äî</span></div>
    <div class="sb-item" id="sb-tx-mode" style="display:none">TX: <span class="sb-val" id="sb-tx">MOVE</span></div>
    <div class="sb-item" style="margin-left:auto;gap:8px;">
      <span id="sb-fps-val" class="sb-val">60</span> fps
      <span style="color:var(--border2)">|</span>
      <div class="api-dot" id="api-dot2"></div>
      <span id="sb-api">offline</span>
    </div>
  </div>
  <div class="toast" id="toast"></div>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  B.L.I.T.Z. STUDIO v3 ‚Äî Purple Aesthetic + Free Movement
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const API = (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
      ? 'http://localhost:8000' : location.origin;

    // WEBSOCKET
    const WS_URL = API.replace(/^http/, 'ws') + '/ws/chat';
    let _ws = null, _wsBuf = '', _wsEl = null, _wsRes = null;
    (function wsConnect() {
      try {
        _ws = new WebSocket(WS_URL);
        _ws.onclose = () => { _ws = null; setTimeout(wsConnect, 4000); };
        _ws.onerror = () => { };
        _ws.onmessage = ev => {
          try {
            const m = JSON.parse(ev.data);
            if (m.type === 'token' && _wsEl) { _wsBuf += m.text; _wsEl.innerHTML = renderMD(_wsBuf); scroll_feed(); }
            else if (m.type === 'done' || m.type === 'error') { if (_wsEl) _wsEl.innerHTML = renderMD(_wsBuf); if (_wsRes) { _wsRes(); _wsRes = null; } }
          } catch { }
        };
      } catch { }
    })();

    // ‚îÄ‚îÄ APP STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let appMode = 'object';
    let txMode = 'select';
    let snapOn = false;
    let animating = true;
    let wireMode = false;
    let selectedObj = null;
    let sceneObjects = [];
    let addedLights = [];
    let lastSceneCode = '';
    let sceneTab = 'physics';
    let leftTab = 'add';

    // ‚îÄ‚îÄ MOVEMENT STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let movingObj = false;
    let moveAxis = 'free';
    let moveStartMouse = { x: 0, y: 0 };
    let moveCurrentMouse = { x: 0, y: 0 };
    let moveStartPos = new THREE.Vector3();
    let movePlane = new THREE.Plane();
    let moveType = 'grab';
    let moveStartScale = new THREE.Vector3();
    let moveStartRotation = new THREE.Euler();
    let mouseWorld = new THREE.Vector3();

    // ‚îÄ‚îÄ THREE.JS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const canvas3 = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas3, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x04010c, 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, 1, 0.05, 1000);

    // Scene lights
    const ambLight = new THREE.AmbientLight(0x2a1050, 0.8);
    scene.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xddaaff, 1.2);
    dirLight.position.set(6, 10, 6);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(1024, 1024);
    scene.add(dirLight);
    const rimLight = new THREE.PointLight(0x9933ff, 1.0, 35);
    rimLight.position.set(-5, 2, -5);
    scene.add(rimLight);

    // Grid
    const gridH = new THREE.GridHelper(24, 24, 0x2a0f55, 0x140828);
    scene.add(gridH);

    // Axes
    const axesH = new THREE.AxesHelper(4);
    axesH.visible = false;
    scene.add(axesH);

    // Object group
    const objGroup = new THREE.Group();
    scene.add(objGroup);

    // Selection highlight outline group
    const outlineGroup = new THREE.Group();
    scene.add(outlineGroup);

    // ‚îÄ‚îÄ ORBIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const orbit = { drag: false, panning: false, lx: 0, ly: 0, theta: 0.65, phi: 0.8, r: 12, target: new THREE.Vector3() };
    function updateOrbit() {
      camera.position.x = orbit.target.x + orbit.r * Math.sin(orbit.phi) * Math.sin(orbit.theta);
      camera.position.y = orbit.target.y + orbit.r * Math.cos(orbit.phi);
      camera.position.z = orbit.target.z + orbit.r * Math.sin(orbit.phi) * Math.cos(orbit.theta);
      camera.lookAt(orbit.target);
    }
    updateOrbit();

    canvas3.addEventListener('mousedown', e => {
      if (movingObj) {
        if (e.button === 0) { confirmMove(); e.stopPropagation(); }
        return;
      }
      if (e.button === 2) { orbit.drag = true; orbit.lx = e.clientX; orbit.ly = e.clientY; }
      if (e.button === 1) { orbit.panning = true; orbit.lx = e.clientX; orbit.ly = e.clientY; e.preventDefault(); }
      if (e.button === 0) {
        // If in Move/Rotate/Scale transform mode, start direct drag move
        if (txMode !== 'select' && selectedObj && !movingObj) {
          const typeMap = { move: 'grab', rotate: 'rotate', scale: 'scale' };
          moveStartMouse = { x: e.clientX, y: e.clientY };
          moveCurrentMouse = { x: e.clientX, y: e.clientY };
          startMove(typeMap[txMode] || 'grab');
          return;
        }
        // Shift+left = pan
        if (e.shiftKey) {
          orbit.panning = true; orbit.lx = e.clientX; orbit.ly = e.clientY;
          orbit._leftPan = true;
          return;
        }
        // Try to select; if nothing hit, start orbiting via left-click
        const m = getMouseNDC(e);
        mouse2d.x = m.x; mouse2d.y = m.y;
        raycaster.setFromCamera(mouse2d, camera);
        const meshes = sceneObjects.map(o => o.mesh).filter(Boolean);
        const hits = raycaster.intersectObjects(meshes, true);
        if (hits.length > 0) {
          doSelect(e);
        } else {
          // No object hit ‚Üí orbit with left mouse
          orbit.drag = true; orbit.lx = e.clientX; orbit.ly = e.clientY;
          orbit._leftOrbit = true;
          selectObject(null);
        }
      }
    });

    canvas3.addEventListener('contextmenu', e => e.preventDefault());

    document.addEventListener('mouseup', e => {
      if (e.button === 2) orbit.drag = false;
      if (e.button === 1) orbit.panning = false;
      if (e.button === 0) {
        // Release left-click orbit/pan
        if (orbit._leftOrbit) { orbit.drag = false; orbit._leftOrbit = false; }
        if (orbit._leftPan) { orbit.panning = false; orbit._leftPan = false; }
        // If direct-dragging in transform mode, confirm on release
        if (movingObj && txMode !== 'select') {
          confirmMove();
        }
      }
    });

    document.addEventListener('mousemove', e => {
      if (movingObj) {
        handleMoveMouseMove(e);
        return;
      }
      if (orbit.drag) {
        const dx = e.clientX - orbit.lx, dy = e.clientY - orbit.ly;
        orbit.theta -= dx * .007;
        orbit.phi = Math.max(0.01, Math.min(Math.PI - .01, orbit.phi + dy * .007));
        orbit.lx = e.clientX; orbit.ly = e.clientY;
        updateOrbit(); updateGizmo();
      }
      if (orbit.panning) {
        const dx = e.clientX - orbit.lx, dy = e.clientY - orbit.ly;
        const right = new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()), camera.up).normalize();
        const up = camera.up.clone();
        const panSpeed = orbit.r * 0.001;
        orbit.target.addScaledVector(right, -dx * panSpeed);
        orbit.target.addScaledVector(up, dy * panSpeed);
        orbit.lx = e.clientX; orbit.ly = e.clientY;
        updateOrbit();
      }
    });

    canvas3.addEventListener('wheel', e => {
      if (movingObj) return;
      // Dolly zoom: move closer/farther with adaptive speed
      const zoomFactor = orbit.r * 0.08;
      orbit.r = Math.max(0.3, Math.min(500, orbit.r + e.deltaY * zoomFactor * 0.01));
      updateOrbit(); e.preventDefault();
    }, { passive: false });

    // ‚îÄ‚îÄ TOUCH EVENTS (iPad / Mobile Support) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let touchState = { type: null, startX: 0, startY: 0, lastX: 0, lastY: 0, pinchDist: 0, moved: false };

    function getTouchDist(e) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    canvas3.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches;
      touchState.moved = false;

      if (movingObj && t.length === 1) {
        // Tap to confirm during move
        confirmMove();
        return;
      }

      if (t.length === 1) {
        touchState.type = 'orbit';
        touchState.startX = touchState.lastX = t[0].clientX;
        touchState.startY = touchState.lastY = t[0].clientY;
      } else if (t.length === 2) {
        touchState.type = 'pinch';
        touchState.pinchDist = getTouchDist(e);
        touchState.lastX = (t[0].clientX + t[1].clientX) / 2;
        touchState.lastY = (t[0].clientY + t[1].clientY) / 2;
      }
    }, { passive: false });

    canvas3.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.touches;
      touchState.moved = true;

      if (movingObj && t.length === 1) {
        // Drag to move object on touch
        handleMoveMouseMove({ clientX: t[0].clientX, clientY: t[0].clientY });
        return;
      }

      if (touchState.type === 'orbit' && t.length === 1) {
        const dx = t[0].clientX - touchState.lastX;
        const dy = t[0].clientY - touchState.lastY;
        orbit.theta -= dx * 0.007;
        orbit.phi = Math.max(0.01, Math.min(Math.PI - 0.01, orbit.phi + dy * 0.007));
        touchState.lastX = t[0].clientX;
        touchState.lastY = t[0].clientY;
        updateOrbit(); updateGizmo();
      } else if (touchState.type === 'pinch' && t.length === 2) {
        // Pinch zoom
        const newDist = getTouchDist(e);
        const scale = touchState.pinchDist / newDist;
        orbit.r = Math.max(0.3, Math.min(500, orbit.r * scale));
        touchState.pinchDist = newDist;
        updateOrbit();
        // Pan with 2-finger drag
        const cx = (t[0].clientX + t[1].clientX) / 2;
        const cy = (t[0].clientY + t[1].clientY) / 2;
        const dx = cx - touchState.lastX;
        const dy = cy - touchState.lastY;
        const right = new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()), camera.up).normalize();
        const up = camera.up.clone();
        const panSpeed = orbit.r * 0.001;
        orbit.target.addScaledVector(right, -dx * panSpeed);
        orbit.target.addScaledVector(up, dy * panSpeed);
        touchState.lastX = cx; touchState.lastY = cy;
        updateOrbit();
      }
    }, { passive: false });

    canvas3.addEventListener('touchend', e => {
      e.preventDefault();
      // Tap (no drag) = select
      if (!touchState.moved && touchState.type === 'orbit') {
        const te = { clientX: touchState.startX, clientY: touchState.startY };
        // If in transform mode and object selected, start move
        if (txMode !== 'select' && selectedObj) {
          const typeMap = { move: 'grab', rotate: 'rotate', scale: 'scale' };
          moveStartMouse = { x: te.clientX, y: te.clientY };
          moveCurrentMouse = { x: te.clientX, y: te.clientY };
          startMove(typeMap[txMode] || 'grab');
        } else {
          doSelect(te);
        }
      }
      touchState.type = null;
    }, { passive: false });

    // ‚îÄ‚îÄ RAYCASTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const raycaster = new THREE.Raycaster();
    const mouse2d = new THREE.Vector2();

    function getMouseNDC(e) {
      const rect = canvas3.getBoundingClientRect();
      return {
        x: ((e.clientX - rect.left) / rect.width) * 2 - 1,
        y: -((e.clientY - rect.top) / rect.height) * 2 + 1,
        cx: e.clientX, cy: e.clientY
      };
    }

    function doSelect(e) {
      const m = getMouseNDC(e);
      mouse2d.x = m.x; mouse2d.y = m.y;
      raycaster.setFromCamera(mouse2d, camera);
      const meshes = sceneObjects.map(o => o.mesh).filter(Boolean);
      const hits = raycaster.intersectObjects(meshes, true);
      if (hits.length > 0) {
        let obj = hits[0].object;
        // Walk up to find direct child of objGroup
        while (obj.parent && obj.parent !== objGroup && obj.parent !== scene) obj = obj.parent;
        const found = sceneObjects.find(o => o.mesh === obj || isDescendant(obj, o.mesh));
        selectObject(found || null);
      } else {
        selectObject(null);
      }
    }

    function isDescendant(child, parent) {
      let c = child;
      while (c) { if (c === parent) return true; c = c.parent; }
      return false;
    }

    // ‚îÄ‚îÄ FREE MOVEMENT SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Key insight: capture WHERE on the plane the ray hits at grab-start,
    // then every frame: newPos = planeHit - grabOffset + originalPos
    // This means the object moves WITH the mouse, not TO the mouse.

    let grabOffset = new THREE.Vector3(); // vector from object origin to initial ray hit on plane

    function startMove(type = 'grab') {
      if (!selectedObj) return;
      movingObj = true;
      moveType = type;
      moveAxis = 'free';

      // Snapshot the starting state
      moveStartPos.copy(selectedObj.mesh.position);
      moveStartScale.copy(selectedObj.mesh.scale);
      moveStartRotation.copy(selectedObj.mesh.rotation);

      // Record exactly where the mouse was when grab started
      moveStartMouse = { x: moveCurrentMouse.x, y: moveCurrentMouse.y };

      // Build move plane facing camera, passing through object center
      const camDir = new THREE.Vector3().subVectors(camera.position, orbit.target).normalize();
      movePlane.setFromNormalAndCoplanarPoint(camDir, selectedObj.mesh.position);

      // Compute grab offset: hit point on plane minus object position
      // This is the crucial piece that prevents teleporting
      const ndcStart = screenToNDC(moveStartMouse.x, moveStartMouse.y);
      mouse2d.set(ndcStart.x, ndcStart.y);
      raycaster.setFromCamera(mouse2d, camera);
      const hitStart = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(movePlane, hitStart)) {
        grabOffset.copy(hitStart).sub(selectedObj.mesh.position);
      } else {
        grabOffset.set(0, 0, 0);
      }

      document.getElementById('canvas-zone').classList.add('move-mode');
      document.getElementById('move-hint').classList.add('show');
      showTxBanner(type);
      updateAxisHud();
    }

    function screenToNDC(cx, cy) {
      const rect = canvas3.getBoundingClientRect();
      return {
        x: ((cx - rect.left) / rect.width) * 2 - 1,
        y: -((cy - rect.top) / rect.height) * 2 + 1
      };
    }

    function handleMoveMouseMove(e) {
      if (!selectedObj || !movingObj) return;
      const ndc = screenToNDC(e.clientX, e.clientY);
      mouse2d.set(ndc.x, ndc.y);
      raycaster.setFromCamera(mouse2d, camera);

      if (moveType === 'grab') {
        if (moveAxis === 'free') {
          // Intersect with the object's camera-facing plane
          const hit = new THREE.Vector3();
          if (raycaster.ray.intersectPlane(movePlane, hit)) {
            // new position = hit point - original grab offset
            selectedObj.mesh.position.copy(hit).sub(grabOffset);
            if (snapOn) snapPosition(selectedObj.mesh);
          }
        } else {
          // Constrained axis movement
          // Project mouse screen delta to world-space movement on the locked axis
          const dx = (e.clientX - moveStartMouse.x) / canvas3.getBoundingClientRect().width;
          const dy = (e.clientY - moveStartMouse.y) / canvas3.getBoundingClientRect().height;
          const speed = orbit.r * 2.5;
          const newPos = moveStartPos.clone();
          if (moveAxis === 'x') newPos.x += dx * speed;
          else if (moveAxis === 'y') newPos.y -= dy * speed;
          else if (moveAxis === 'z') newPos.z += dx * speed;
          selectedObj.mesh.position.copy(newPos);
          if (snapOn) snapPosition(selectedObj.mesh);
        }
      } else if (moveType === 'rotate') {
        const rect = canvas3.getBoundingClientRect();
        const dx = (e.clientX - moveStartMouse.x) / rect.width;
        const dy = (e.clientY - moveStartMouse.y) / rect.height;
        const speed = Math.PI * 3.5;
        if (moveAxis === 'x') selectedObj.mesh.rotation.x = moveStartRotation.x - dy * speed;
        else if (moveAxis === 'y') selectedObj.mesh.rotation.y = moveStartRotation.y + dx * speed;
        else if (moveAxis === 'z') selectedObj.mesh.rotation.z = moveStartRotation.z + dx * speed;
        else {
          selectedObj.mesh.rotation.x = moveStartRotation.x - dy * speed;
          selectedObj.mesh.rotation.y = moveStartRotation.y + dx * speed;
        }
      } else if (moveType === 'scale') {
        const rect = canvas3.getBoundingClientRect();
        const dx = (e.clientX - moveStartMouse.x) / rect.width;
        // Moving right = bigger, left = smaller. Centered at 1.
        const factor = Math.max(0.01, 1 + dx * 4);
        if (moveAxis === 'x') selectedObj.mesh.scale.x = Math.max(0.01, moveStartScale.x * factor);
        else if (moveAxis === 'y') selectedObj.mesh.scale.y = Math.max(0.01, moveStartScale.y * factor);
        else if (moveAxis === 'z') selectedObj.mesh.scale.z = Math.max(0.01, moveStartScale.z * factor);
        else selectedObj.mesh.scale.set(
          Math.max(0.01, moveStartScale.x * factor),
          Math.max(0.01, moveStartScale.y * factor),
          Math.max(0.01, moveStartScale.z * factor)
        );
      }

      updateTransformInputs();
    }

    function snapPosition(mesh) {
      const s = 0.5;
      mesh.position.x = Math.round(mesh.position.x / s) * s;
      mesh.position.y = Math.round(mesh.position.y / s) * s;
      mesh.position.z = Math.round(mesh.position.z / s) * s;
    }

    function confirmMove() {
      if (!movingObj) return;
      movingObj = false;
      document.getElementById('canvas-zone').classList.remove('move-mode', 'dragging-obj');
      document.getElementById('move-hint').classList.remove('show');
      document.getElementById('axis-hud').classList.remove('show');
      hideTxBanner();
      updateTransformInputs();
      toast('‚úì Transform applied', true);
    }

    function cancelMove() {
      if (!movingObj) return;
      selectedObj.mesh.position.copy(moveStartPos);
      selectedObj.mesh.scale.copy(moveStartScale);
      selectedObj.mesh.rotation.copy(moveStartRotation);
      movingObj = false;
      document.getElementById('canvas-zone').classList.remove('move-mode', 'dragging-obj');
      document.getElementById('move-hint').classList.remove('show');
      document.getElementById('axis-hud').classList.remove('show');
      hideTxBanner();
      updateTransformInputs();
      toast('Cancelled');
    }

    function setMoveAxis(ax) {
      moveAxis = ax;
      // When switching to constrained mode, re-anchor the start mouse to current position
      // so constrained movement starts from zero delta
      moveStartMouse = { x: moveCurrentMouse.x, y: moveCurrentMouse.y };
      moveStartPos.copy(selectedObj.mesh.position);
      moveStartScale.copy(selectedObj.mesh.scale);
      moveStartRotation.copy(selectedObj.mesh.rotation);
      updateAxisHud();
    }

    function updateAxisHud() {
      const hud = document.getElementById('axis-hud');
      hud.className = 'axis-hud show ax-' + (moveAxis === 'free' ? 'free' : moveAxis);
      hud.textContent = moveAxis === 'free' ? 'FREE' : 'LOCK ¬∑ ' + moveAxis.toUpperCase();
    }

    function showTxBanner(type) {
      const el = document.getElementById('tx-mode-banner');
      const labels = { grab: '‚äï GRAB ‚Äî move freely', rotate: '‚Üª ROTATE', scale: '‚üê SCALE' };
      el.textContent = labels[type] || type.toUpperCase();
      el.className = 'tx-mode-banner show ' + type;
    }
    function hideTxBanner() {
      document.getElementById('tx-mode-banner').classList.remove('show');
    }

    // ‚îÄ‚îÄ RESIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function resizeRenderer() {
      const z = document.getElementById('canvas-zone');
      const w = z.offsetWidth, h = z.offsetHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();

    // ‚îÄ‚îÄ GIZMO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const gizmoCanvas = document.getElementById('gizmo-canvas');
    const gCtx = gizmoCanvas.getContext('2d');
    function updateGizmo() {
      gCtx.clearRect(0, 0, 70, 70);
      const cx = 35, cy = 35, len = 24;
      const dirs = [
        { v: new THREE.Vector3(1, 0, 0), c: '#ff4466', l: 'X' },
        { v: new THREE.Vector3(0, 1, 0), c: '#66ff66', l: 'Y' },
        { v: new THREE.Vector3(0, 0, 1), c: '#4488ff', l: 'Z' }
      ];
      dirs.forEach(d => {
        const proj = d.v.clone().applyQuaternion(camera.quaternion.clone().invert());
        const sx = cx + proj.x * len, sy = cy - proj.y * len;
        gCtx.strokeStyle = d.c; gCtx.lineWidth = 2;
        gCtx.beginPath(); gCtx.moveTo(cx, cy); gCtx.lineTo(sx, sy); gCtx.stroke();
        gCtx.fillStyle = d.c; gCtx.font = 'bold 9px Share Tech Mono,monospace';
        gCtx.textAlign = 'center'; gCtx.textBaseline = 'middle';
        gCtx.fillText(d.l, sx + ((sx - cx) * .25), sy + ((sy - cy) * .25));
      });
      gCtx.beginPath(); gCtx.arc(cx, cy, 3, 0, Math.PI * 2); gCtx.fillStyle = 'rgba(160,80,255,.7)'; gCtx.fill();
    }
    updateGizmo();

    // ‚îÄ‚îÄ WASD / Arrow key state (must be declared before animate()) ‚îÄ‚îÄ
    const keysDown = {};
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      keysDown[e.key.toLowerCase()] = true;
    });
    document.addEventListener('keyup', e => {
      keysDown[e.key.toLowerCase()] = false;
    });

    // ‚îÄ‚îÄ ANIMATION LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const clock = new THREE.Clock();
    let animTime = 0;
    let frameCount = 0, fpsAcc = 0, fps = 60;

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      animTime += delta;

      frameCount++; fpsAcc += delta;
      if (fpsAcc >= 0.5) {
        fps = Math.round(frameCount / fpsAcc); frameCount = 0; fpsAcc = 0;
        document.getElementById('hud-fps').textContent = fps + ' FPS';
        document.getElementById('sb-fps-val').textContent = fps;
      }

      if (animating) {
        sceneObjects.forEach(o => { if (o.animFn) o.animFn(delta, animTime, o.mesh); });
      }

      const cp = camera.position;
      document.getElementById('sb-coords').textContent =
        `X:${cp.x.toFixed(2)} Y:${cp.y.toFixed(2)} Z:${cp.z.toFixed(2)}`;

      // Free camera movement (WASD / Arrows / Q / E)
      if (typeof updateCameraMovement === 'function') updateCameraMovement(delta);

      renderer.render(scene, camera);
    }
    animate();

    // ‚îÄ‚îÄ SELECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function selectObject(obj) {
      // Remove highlight from all
      sceneObjects.forEach(o => {
        if (o.mesh && o.mesh.traverse) {
          o.mesh.traverse(child => {
            if (child.isMesh && child.material && child.userData._origEmissive !== undefined) {
              if (child.material.emissiveIntensity !== undefined)
                child.material.emissiveIntensity = child.userData._origEmissive;
            }
          });
        }
      });
      // Clear outline group
      while (outlineGroup.children.length) outlineGroup.remove(outlineGroup.children[0]);

      selectedObj = obj;
      if (obj) {
        // Highlight - boost emissive strongly so you can see the selection
        obj.mesh.traverse(child => {
          if (child.isMesh && child.material) {
            if (child.userData._origEmissive === undefined)
              child.userData._origEmissive = child.material.emissiveIntensity || 0;
            child.material.emissiveIntensity = Math.min(2, (child.userData._origEmissive || 0) + 0.6);
          }
        });

        // Add bbox selection outline
        try {
          const box = new THREE.Box3().setFromObject(obj.mesh);
          const size = new THREE.Vector3(); box.getSize(size);
          const center = new THREE.Vector3(); box.getCenter(center);
          const helper = new THREE.Box3Helper(box, 0xdd99ff);
          helper.material.transparent = true;
          helper.material.opacity = 0.55;
          outlineGroup.add(helper);
        } catch (e) { }

        updateTransformInputs();
        document.getElementById('obj-info-panel').innerHTML =
          `<div style="font-family:var(--mono);font-size:8.5px;color:var(--muted);">Name: <span style="color:var(--accent);font-weight:700;">${obj.name}</span></div>
       <div style="font-family:var(--mono);font-size:8px;color:var(--muted);margin-top:3px;">Type: <span style="color:var(--text2)">${obj.type}</span></div>
       <div style="font-family:var(--mono);font-size:8px;color:var(--muted);margin-top:3px;">Pos: <span style="color:var(--text2)">${obj.mesh.position.x.toFixed(2)}, ${obj.mesh.position.y.toFixed(2)}, ${obj.mesh.position.z.toFixed(2)}</span></div>
       <div style="font-family:var(--mono);font-size:7.5px;color:var(--muted);margin-top:6px;padding:4px 6px;background:rgba(185,100,255,.08);border:1px solid var(--border);border-radius:3px;">
         G=move &nbsp;¬∑&nbsp; R=rotate &nbsp;¬∑&nbsp; S=scale
       </div>`;
        document.getElementById('sb-selected-item').style.display = 'flex';
        document.getElementById('sb-sel').textContent = obj.name;
        if (leftTab !== 'props') switchLTab('props');
      } else {
        document.getElementById('obj-info-panel').innerHTML = '<div style="font-family:var(--mono);font-size:8px;color:var(--muted);">No object selected</div>';
        document.getElementById('sb-selected-item').style.display = 'none';
      }
      updateOutliner();
    }

    function updateTransformInputs() {
      if (!selectedObj) return;
      const m = selectedObj.mesh;
      document.getElementById('px').value = m.position.x.toFixed(3);
      document.getElementById('py').value = m.position.y.toFixed(3);
      document.getElementById('pz').value = m.position.z.toFixed(3);
      document.getElementById('rx').value = (m.rotation.x * 180 / Math.PI).toFixed(1);
      document.getElementById('ry').value = (m.rotation.y * 180 / Math.PI).toFixed(1);
      document.getElementById('rz').value = (m.rotation.z * 180 / Math.PI).toFixed(1);
      document.getElementById('sx').value = m.scale.x.toFixed(3);
      document.getElementById('sy').value = m.scale.y.toFixed(3);
      document.getElementById('sz').value = m.scale.z.toFixed(3);
    }

    function applyTransform() {
      if (!selectedObj) return;
      const m = selectedObj.mesh;
      m.position.set(+document.getElementById('px').value, +document.getElementById('py').value, +document.getElementById('pz').value);
      m.rotation.set((+document.getElementById('rx').value) * Math.PI / 180, (+document.getElementById('ry').value) * Math.PI / 180, (+document.getElementById('rz').value) * Math.PI / 180);
      m.scale.set(+document.getElementById('sx').value, +document.getElementById('sy').value, +document.getElementById('sz').value);
    }

    function applyMaterial() {
      if (!selectedObj || !selectedObj.mesh) return;
      const setMat = (mat) => {
        if (!mat) return;
        const col = document.getElementById('mat-color').value;
        if (mat.color) mat.color.setStyle(col);
        if (mat.emissive) mat.emissive.setStyle(col);
        if (mat.metalness !== undefined) mat.metalness = +document.getElementById('mat-metal').value;
        if (mat.roughness !== undefined) mat.roughness = +document.getElementById('mat-rough').value;
        if (mat.emissiveIntensity !== undefined) mat.emissiveIntensity = +document.getElementById('mat-emissive').value;
        const op = +document.getElementById('mat-opacity').value;
        mat.transparent = op < 1; mat.opacity = op;
      };
      selectedObj.mesh.traverse(c => { if (c.isMesh && c.material) setMat(Array.isArray(c.material) ? c.material[0] : c.material); });
    }

    function applyMatPreset(preset, ev) {
      const presets = {
        metal: { color: '#aaaaaa', metal: 0.9, rough: 0.2, emissive: 0.05, opacity: 1 },
        holo: { color: '#00ffcc', metal: 0.1, rough: 0.1, emissive: 0.8, opacity: 0.75 },
        hot: { color: '#ff4466', metal: 0.2, rough: 0.5, emissive: 0.6, opacity: 1 },
        cool: { color: '#4488ff', metal: 0.1, rough: 0.3, emissive: 0.4, opacity: 1 },
        gold: { color: '#ffcc00', metal: 0.95, rough: 0.15, emissive: 0.1, opacity: 1 },
        glass: { color: '#ccbbff', metal: 0, rough: 0, emissive: 0, opacity: 0.3 },
        plasma: { color: '#cc88ff', metal: 0, rough: 0.5, emissive: 1.2, opacity: 0.85 },
        purple: { color: '#a050ff', metal: 0.3, rough: 0.4, emissive: 0.3, opacity: 1 },
        ember: { color: '#ff8800', metal: 0.2, rough: 0.6, emissive: 0.7, opacity: 1 },
        neon: { color: '#00ff88', metal: 0, rough: 0.3, emissive: 1.5, opacity: 0.9 },
      };
      const p = presets[preset]; if (!p) return;
      document.getElementById('mat-color').value = p.color;
      document.getElementById('mat-metal').value = p.metal;
      document.getElementById('mat-rough').value = p.rough;
      document.getElementById('mat-emissive').value = p.emissive;
      document.getElementById('mat-opacity').value = p.opacity;
      document.querySelectorAll('.mat-swatch').forEach(s => s.classList.remove('active'));
      if (ev && ev.target) ev.target.classList.add('active');
      applyMaterial();
    }

    function duplicateSelected() {
      if (!selectedObj) return;
      const src = selectedObj;
      const clone = src.mesh.clone();
      clone.position.x += 0.6;
      objGroup.add(clone);
      const obj = { mesh: clone, name: src.name + '.copy', type: src.type, animFn: src.animFn };
      sceneObjects.push(obj);
      updateObjectCount(); updateOutliner();
      selectObject(obj);
      toast('Duplicated: ' + obj.name, true);
    }

    function deleteSelected() {
      if (!selectedObj) return;
      const i = sceneObjects.indexOf(selectedObj);
      if (i >= 0) deleteObj(i);
    }

    // ‚îÄ‚îÄ PRIMITIVES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function makeMat(overrides = {}) {
      const cfg = Object.assign({ color: 0xa050ff, emissive: 0x330066, emissiveIntensity: 0.25, metalness: 0.3, roughness: 0.4 }, overrides);
      return new THREE.MeshStandardMaterial({
        color: cfg.color, emissive: cfg.emissive || cfg.color, emissiveIntensity: cfg.emissiveIntensity,
        metalness: cfg.metalness, roughness: cfg.roughness,
        transparent: cfg.opacity !== undefined && cfg.opacity < 1, opacity: cfg.opacity || 1
      });
    }

    function addToScene(mesh, name, type, animFn = null) {
      objGroup.add(mesh);
      const obj = { mesh, name, type, animFn };
      sceneObjects.push(obj);
      updateObjectCount(); updateOutliner();
      selectObject(obj);
      showRenderTag('ADDED');
      toast('+ ' + name, true);
      return obj;
    }

    function addPrimitive(type) {
      let geo, name = 'Object';
      switch (type) {
        case 'box': geo = new THREE.BoxGeometry(1, 1, 1); name = 'Cube'; break;
        case 'sphere': geo = new THREE.SphereGeometry(0.7, 32, 32); name = 'Sphere'; break;
        case 'cylinder': geo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32); name = 'Cylinder'; break;
        case 'cone': geo = new THREE.ConeGeometry(0.6, 1.4, 32); name = 'Cone'; break;
        case 'torus': geo = new THREE.TorusGeometry(0.7, 0.25, 20, 40); name = 'Torus'; break;
        case 'plane': geo = new THREE.PlaneGeometry(2, 2, 4, 4); name = 'Plane'; break;
        case 'knot': geo = new THREE.TorusKnotGeometry(0.7, 0.2, 128, 16, 2, 3); name = 'TorusKnot'; break;
        case 'ico': geo = new THREE.IcosahedronGeometry(0.8, 1); name = 'Icosphere'; break;
        default: geo = new THREE.BoxGeometry(1, 1, 1); name = 'Cube';
      }
      const mesh = new THREE.Mesh(geo, makeMat());
      mesh.position.set((Math.random() - .5) * 2, 0, (Math.random() - .5) * 2);
      mesh.castShadow = true; mesh.receiveShadow = true;
      if (wireMode && mesh.material) mesh.material.wireframe = true;
      addToScene(mesh, name, 'Primitive');
    }

    function addLight(type) {
      let light, name = 'Light';
      switch (type) {
        case 'point':
          light = new THREE.PointLight(0xa050ff, 1.5, 15);
          light.position.set(0, 3, 0);
          name = 'PointLight'; break;
        case 'spot':
          light = new THREE.SpotLight(0xcc88ff, 2, 20, Math.PI / 4, 0.3);
          light.position.set(2, 5, 2);
          name = 'SpotLight'; break;
        case 'dir':
          light = new THREE.DirectionalLight(0xffffff, 1);
          light.position.set(3, 5, 3);
          name = 'DirLight'; break;
        case 'ambient':
          light = new THREE.AmbientLight(0x330055, 0.8);
          name = 'AmbientLight'; break;
        default:
          light = new THREE.PointLight(0xa050ff, 1.5, 15);
          light.position.set(0, 3, 0);
          name = 'PointLight';
      }
      scene.add(light);
      addedLights.push(light);
      // Visible representative mesh
      const geo = new THREE.OctahedronGeometry(0.18, 0);
      const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: true });
      const rep = new THREE.Mesh(geo, mat);
      if (light.position) rep.position.copy(light.position);
      addToScene(rep, name, 'Light');
      toast('+ ' + name, true);
    }

    function addCurve(type) {
      let geo, name = 'Curve';
      if (type === 'bezier' || type === 'circle') {
        const pts = [];
        const n = type === 'circle' ? 32 : 8;
        for (let i = 0; i <= n; i++) {
          const a = (i / n) * Math.PI * 2;
          pts.push(new THREE.Vector3(Math.cos(a) * 1.5, 0, Math.sin(a) * 1.5));
        }
        const curve = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),
          new THREE.LineBasicMaterial({ color: 0xa050ff }));
        name = type === 'circle' ? 'Circle' : 'BezierCurve';
        addToScene(curve, name, 'Curve');
      } else if (type === 'helix') {
        const pts = [];
        for (let i = 0; i <= 100; i++) {
          const t = (i / 100) * Math.PI * 6;
          pts.push(new THREE.Vector3(Math.cos(t), t * .15 - 1.5, Math.sin(t)));
        }
        const h = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),
          new THREE.LineBasicMaterial({ color: 0xcc88ff }));
        addToScene(h, 'Helix', 'Curve');
      }
    }

    function addEmpty(type) {
      let rep, name = 'Empty';
      if (type === 'axes') {
        rep = new THREE.AxesHelper(1);
        name = 'Empty.Axes';
      } else if (type === 'sphere') {
        rep = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12),
          new THREE.MeshBasicMaterial({ color: 0xa050ff, wireframe: true }));
        name = 'Empty.Sphere';
      } else {
        rep = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshBasicMaterial({ color: 0xa050ff, wireframe: true }));
        name = 'Empty.Cube';
      }
      addToScene(rep, name, 'Empty');
    }

    // ‚îÄ‚îÄ ECE COMPONENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function addECE(type) {
      switch (type) {
        case 'resistor': buildResistor(); break;
        case 'capacitor': buildCapacitor(); break;
        case 'inductor': buildInductor(); break;
        case 'transistor': buildTransistor(); break;
        case 'opamp': buildOpAmp(); break;
        case 'gate_and': buildGate('AND'); break;
        case 'gate_or': buildGate('OR'); break;
        case 'gate_not': buildGate('NOT'); break;
        case 'atom': buildAtom(); break;
        case 'wave': buildSineWave(); break;
        case 'em_field': buildEMField(); break;
        case 'vector_field': buildVectorField(); break;
        case 'fft': buildFFT(); break;
        case 'phasor': buildPhasor(); break;
      }
    }

    function buildResistor() {
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(.12, .12, .6, 16),
        new THREE.MeshStandardMaterial({ color: 0xcc8844, metalness: .1, roughness: .7 }));
      body.rotation.z = Math.PI / 2; g.add(body);
      [-.18, -.04, .04, .18].forEach((x, i) => {
        const stripe = new THREE.Mesh(new THREE.CylinderGeometry(.125, .125, .04, 16),
          new THREE.MeshStandardMaterial({ color: [0xff0000, 0xff8800, 0xffff00, 0xaaaaaa][i] }));
        stripe.rotation.z = Math.PI / 2; stripe.position.x = x; g.add(stripe);
      });
      [-1, 1].forEach(side => {
        const lead = new THREE.Mesh(new THREE.CylinderGeometry(.02, .02, .35, 8),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: .9 }));
        lead.rotation.z = Math.PI / 2; lead.position.x = side * .47; g.add(lead);
      });
      addToScene(g, 'Resistor', 'ECE');
    }

    function buildCapacitor() {
      const g = new THREE.Group();
      [-0.18, 0.18].forEach((x, i) => {
        const plate = new THREE.Mesh(new THREE.CylinderGeometry(.35, .35, .04, 32),
          new THREE.MeshStandardMaterial({ color: i === 0 ? 0x4488ff : 0xff4466, metalness: .8, roughness: .2, emissive: i === 0 ? 0x001144 : 0x220011, emissiveIntensity: .3 }));
        plate.rotation.z = Math.PI / 2; plate.position.x = x; g.add(plate);
      });
      const die = new THREE.Mesh(new THREE.CylinderGeometry(.33, .33, .34, 32),
        new THREE.MeshStandardMaterial({ color: 0xaa88ff, transparent: true, opacity: .3 }));
      die.rotation.z = Math.PI / 2; g.add(die);
      [-1, 1].forEach(side => {
        const lead = new THREE.Mesh(new THREE.CylinderGeometry(.02, .02, .3, 8),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: .9 }));
        lead.rotation.z = Math.PI / 2; lead.position.x = side * .5; g.add(lead);
      });
      const eMat = new THREE.LineBasicMaterial({ color: 0x8888ff, transparent: true, opacity: .4 });
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        const pts = [new THREE.Vector3(-.17, Math.cos(a) * .2, Math.sin(a) * .2), new THREE.Vector3(.17, Math.cos(a) * .2, Math.sin(a) * .2)];
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), eMat));
      }
      addToScene(g, 'Capacitor', 'ECE');
    }

    function buildInductor() {
      const g = new THREE.Group();
      const coilMat = new THREE.MeshStandardMaterial({ color: 0xcc9944, metalness: .9, roughness: .1 });
      const turns = 8;
      for (let i = 0; i < turns; i++) {
        const t = new THREE.Mesh(new THREE.TorusGeometry(.22, .04, 12, 32), coilMat);
        t.position.x = (i / (turns - 1)) * .9 - .45; t.rotation.y = Math.PI / 2; g.add(t);
      }
      const core = new THREE.Mesh(new THREE.CylinderGeometry(.14, .14, .9, 16),
        new THREE.MeshStandardMaterial({ color: 0x4444aa, metalness: .5, roughness: .5 }));
      core.rotation.z = Math.PI / 2; g.add(core);
      [-1, 1].forEach(side => {
        const lead = new THREE.Mesh(new THREE.CylinderGeometry(.02, .02, .25, 8),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: .9 }));
        lead.rotation.z = Math.PI / 2; lead.position.x = side * .55; g.add(lead);
      });
      const bMat = new THREE.LineBasicMaterial({ color: 0x88aaff, transparent: true, opacity: .35 });
      for (let i = 0; i < 6; i++) {
        const r = .3 + i * .08;
        const pts = [];
        for (let t = 0; t <= 40; t++) {
          const theta = (t / 40) * Math.PI * 2;
          pts.push(new THREE.Vector3(Math.cos(theta) * 1.1, Math.cos(theta) * r, Math.sin(theta) * r));
        }
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), bMat));
      }
      addToScene(g, 'Inductor', 'ECE');
    }

    function buildTransistor() {
      const g = new THREE.Group();
      const pkg = new THREE.Mesh(new THREE.CylinderGeometry(.3, .3, .6, 3),
        new THREE.MeshStandardMaterial({ color: 0x222233, metalness: .3, roughness: .7 }));
      g.add(pkg);
      [-.25, 0, .25].forEach((x, i) => {
        const lead = new THREE.Mesh(new THREE.CylinderGeometry(.025, .025, .5, 8),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: .9 }));
        lead.position.set(x, -.55, 0); g.add(lead);
      });
      const e_flow = new THREE.Mesh(new THREE.SphereGeometry(.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xa050ff }));
      e_flow.position.set(0, .35, 0); g.add(e_flow);
      const ef2 = e_flow.clone(); ef2.position.set(0, -.1, 0); g.add(ef2);
      const obj = addToScene(g, 'Transistor', 'ECE');
      obj.animFn = (dt, t, mesh) => {
        e_flow.position.y = .3 + Math.sin(t * 3) * .15;
        ef2.position.y = -.2 + Math.cos(t * 3 + 1) * .15;
      };
    }

    function buildOpAmp() {
      const g = new THREE.Group();
      const verts = new Float32Array([-.6, .5, 0, -.6, -.5, 0, .6, 0, 0]);
      const idxs = new Uint16Array([0, 1, 2]);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
      geo.setIndex(new THREE.BufferAttribute(idxs, 1));
      geo.computeVertexNormals();
      const body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x220044, emissive: 0x110022, emissiveIntensity: .35, metalness: .2, side: THREE.DoubleSide }));
      g.add(body);
      g.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0xa050ff })));
      const pMat = new THREE.MeshBasicMaterial({ color: 0x44ff88 });
      const mMat = new THREE.MeshBasicMaterial({ color: 0xff4466 });
      const dot = new THREE.SphereGeometry(.04, 6, 6);
      const plus = new THREE.Mesh(dot, pMat); plus.position.set(-.5, .25, 0);
      const minus = new THREE.Mesh(dot, mMat); minus.position.set(-.5, -.25, 0);
      g.add(plus, minus);
      const sig = new THREE.Mesh(new THREE.SphereGeometry(.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
      g.add(sig);
      const obj = addToScene(g, 'Op-Amp', 'ECE');
      obj.animFn = (dt, t, mesh) => {
        const tt = (t * .8) % 1;
        sig.position.set(-0.6 + tt * 1.4, 0.25 * (1 - tt * 2) * (tt < .5 ? 1 : -1), 0);
        sig.material.color.setHSL(tt * .3 + .1, 1, .5);
      };
    }

    function buildGate(type) {
      const g = new THREE.Group();
      const colors = { AND: 0x1a2255, OR: 0x1a3322, NOT: 0x440022 };
      const geo = new THREE.BoxGeometry(.8, .6, .15);
      const body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: colors[type] || 0x1a2255, emissive: 0x110033, emissiveIntensity: .3, metalness: .2 }));
      g.add(body);
      g.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0xa050ff })));
      const pinMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: .9 });
      const pinGeo = new THREE.CylinderGeometry(.015, .015, .3, 6);
      const inputs = type === 'NOT' ? [0] : [-.15, .15];
      inputs.forEach(y => {
        const p = new THREE.Mesh(pinGeo, pinMat); p.rotation.z = Math.PI / 2; p.position.set(-.55, y, 0); g.add(p);
      });
      const out = new THREE.Mesh(pinGeo, pinMat); out.rotation.z = Math.PI / 2; out.position.set(.55, 0, 0); g.add(out);
      const sigs = inputs.map(() => new THREE.Mesh(new THREE.SphereGeometry(.04, 6, 6), new THREE.MeshBasicMaterial({ color: 0xa050ff })));
      sigs.forEach(s => g.add(s));
      const obj = addToScene(g, `${type} Gate`, 'Logic');
      obj.animFn = (dt, t, mesh) => {
        sigs.forEach((s, i) => {
          const tt = ((t * .6 + i * .5) % 1);
          s.position.set(-.55 + tt * 1.1, inputs[i] || 0, 0);
          s.material.color.setHSL(.7 + tt * .2, 1, .55);
        });
      };
    }

    function buildAtom() {
      const g = new THREE.Group();
      g.add(new THREE.Mesh(new THREE.SphereGeometry(.22, 20, 20),
        new THREE.MeshStandardMaterial({ color: 0xff6644, emissive: 0x441100, emissiveIntensity: .5, metalness: .2 })));
      const shells = [{ r: .8, speed: 1.2, n: 2, tilt: 0 }, { r: 1.3, speed: .7, n: 4, tilt: Math.PI / 3 }, { r: 1.9, speed: .4, n: 6, tilt: Math.PI / 1.8 }];
      const eGeo = new THREE.SphereGeometry(.06, 10, 10);
      const electrons = [];
      shells.forEach(sh => {
        const ring = new THREE.Mesh(new THREE.TorusGeometry(sh.r, .012, 8, 80), new THREE.MeshBasicMaterial({ color: 0x330066, transparent: true, opacity: .5 }));
        ring.rotation.x = sh.tilt; ring.rotation.y = sh.tilt * .5; g.add(ring);
        for (let i = 0; i < sh.n; i++) {
          const e = new THREE.Mesh(eGeo, new THREE.MeshStandardMaterial({ color: 0xa050ff, emissive: 0x330066, emissiveIntensity: .8 }));
          g.add(e);
          electrons.push({ mesh: e, r: sh.r, speed: sh.speed, phase: (i / sh.n) * Math.PI * 2, tilt: sh.tilt });
        }
      });
      const obj = addToScene(g, 'Atom', 'Physics');
      obj.animFn = (dt, t, mesh) => {
        electrons.forEach(e => {
          const angle = t * e.speed + e.phase;
          e.mesh.position.set(Math.cos(angle) * e.r, Math.sin(angle) * Math.sin(e.tilt) * e.r, Math.sin(angle) * Math.cos(e.tilt) * e.r);
        });
      };
    }

    function buildSineWave() {
      const g = new THREE.Group();
      const N = 120, L = 6;
      const waves = [{ color: 0xa050ff, freq: 1, amp: 0.6, phase: 0 }, { color: 0x44ccff, freq: 2, amp: 0.35, phase: Math.PI / 4 }, { color: 0xff4488, freq: 3, amp: 0.2, phase: Math.PI / 2 }];
      const linePts = [];
      waves.forEach(w => {
        const pts = [];
        for (let i = 0; i <= N; i++) { const x = (i / N) * L - L / 2; pts.push(new THREE.Vector3(x, w.amp * Math.sin(w.freq * x * 2 + w.phase), w.freq * .4)); }
        const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color: w.color, transparent: true, opacity: .85 }));
        g.add(line); linePts.push({ line, pts, w });
      });
      const axMat = new THREE.LineBasicMaterial({ color: 0x221133 });
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-3.5, 0, 0), new THREE.Vector3(3.5, 0, 0)]), axMat));
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -1.2, 0), new THREE.Vector3(0, 1.2, 0)]), axMat));
      const obj = addToScene(g, 'Sine Wave', 'Signal');
      obj.animFn = (dt, t, mesh) => {
        linePts.forEach(({ line, pts, w }) => {
          const pos = line.geometry.attributes.position;
          for (let i = 0; i <= N; i++) { const x = (i / N) * L - L / 2; pos.setY(i, w.amp * Math.sin(w.freq * x * 2 + w.phase + t * 2)); }
          pos.needsUpdate = true;
        });
      };
    }

    function buildEMField() {
      const g = new THREE.Group();
      const posCharge = new THREE.Mesh(new THREE.SphereGeometry(.18, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff4466, emissive: 0x880022, emissiveIntensity: .6 }));
      posCharge.position.x = -1.5;
      const negCharge = new THREE.Mesh(new THREE.SphereGeometry(.18, 16, 16), new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x002288, emissiveIntensity: .6 }));
      negCharge.position.x = 1.5;
      g.add(posCharge, negCharge);
      const lMat = new THREE.LineBasicMaterial({ color: 0x8866ff, transparent: true, opacity: .5 });
      for (let i = 0; i < 16; i++) {
        const ang = (i / 16) * Math.PI * 2;
        const pts = [];
        for (let t = 0; t <= 60; t++) { const th = (t / 60) * Math.PI, r = 1.6 * Math.sin(th) ** 2; pts.push(new THREE.Vector3(r * Math.cos(ang) * 1.2, r * 2 * Math.cos(th), r * Math.sin(ang))); }
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lMat));
      }
      const partN = 600, pPos = new Float32Array(partN * 3);
      const pVel = [];
      for (let i = 0; i < partN; i++) { pPos[i * 3] = (Math.random() - .5) * 5; pPos[i * 3 + 1] = (Math.random() - .5) * 4; pPos[i * 3 + 2] = (Math.random() - .5) * 2; pVel.push(new THREE.Vector3()); }
      const partGeo = new THREE.BufferGeometry();
      partGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
      g.add(new THREE.Points(partGeo, new THREE.PointsMaterial({ color: 0x9966ff, size: .06, transparent: true, opacity: .6 })));
      const obj = addToScene(g, 'EM Field', 'EM');
      obj.animFn = (dt, t, mesh) => {
        const pos = partGeo.attributes.position;
        for (let i = 0; i < partN; i++) {
          const px = pos.getX(i), py = pos.getY(i), pz = pos.getZ(i);
          const r1 = new THREE.Vector3(px + 1.5, py, pz).normalize().multiplyScalar(.04);
          const r2 = new THREE.Vector3(px - 1.5, py, pz).normalize().multiplyScalar(-.04);
          pVel[i].add(r1).add(r2).multiplyScalar(.98);
          pos.setXYZ(i, Math.max(-3, Math.min(3, px + pVel[i].x)), Math.max(-2.5, Math.min(2.5, py + pVel[i].y)), Math.max(-1.5, Math.min(1.5, pz + pVel[i].z)));
        }
        pos.needsUpdate = true;
      };
    }

    function buildVectorField() {
      const g = new THREE.Group();
      const N = 6;
      const arrowMat = new THREE.LineBasicMaterial({ color: 0xcc88ff, transparent: true, opacity: .7 });
      for (let x = -N / 2; x < N / 2; x++) for (let y = -N / 2; y < N / 2; y++) {
        const px = (x / (N / 2)) * 3, py = (y / (N / 2)) * 3;
        const vx = -py * .4, vy = px * .4;
        const len = Math.sqrt(vx * vx + vy * vy) || 1;
        const nx = vx / len * .4, ny = vy / len * .4;
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(px, py, 0), new THREE.Vector3(px + nx, py + ny, 0)]), arrowMat));
        const apts = [new THREE.Vector3(px + nx, py + ny, 0), new THREE.Vector3(px + nx - .08, py + ny + .06, 0), new THREE.Vector3(px + nx, py + ny, 0), new THREE.Vector3(px + nx - .08, py + ny - .06, 0)];
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(apts), arrowMat));
      }
      addToScene(g, 'Vector Field', 'Math');
    }

    function buildFFT() {
      const g = new THREE.Group();
      const N = 32;
      const bars = [];
      const freqs = Array.from({ length: N }, (_, i) => { const f = Math.abs(Math.sin(i * .8)) * 2 + Math.random() * .5; return f * (1 - i / N * .7); });
      freqs.forEach((h, i) => {
        const hue = i / N;
        const col = new THREE.Color().setHSL(hue * .4 + .6, 1, .55);
        const bar = new THREE.Mesh(new THREE.BoxGeometry(.15, h, .15), new THREE.MeshStandardMaterial({ color: col, emissive: col, emissiveIntensity: .4, metalness: .1 }));
        bar.position.set((i - N / 2) * .22, h / 2, 0); g.add(bar); bars.push({ mesh: bar, baseH: h });
      });
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-4, 0, 0), new THREE.Vector3(4, 0, 0)]), new THREE.LineBasicMaterial({ color: 0x221133 })));
      const obj = addToScene(g, 'FFT Spectrum', 'Signal');
      obj.animFn = (dt, t, mesh) => {
        bars.forEach((b, i) => { const h = b.baseH * (0.85 + 0.15 * Math.sin(t * 2 + i * .3)); b.mesh.scale.y = h / b.baseH; b.mesh.position.y = h / 2; });
      };
    }

    function buildPhasor() {
      const g = new THREE.Group();
      const arrowMat = new THREE.MeshStandardMaterial({ color: 0xa050ff, emissive: 0x330066, emissiveIntensity: .5, metalness: .3 });
      const shaft = new THREE.Mesh(new THREE.CylinderGeometry(.04, .04, 1.5, 12), arrowMat);
      shaft.position.y = .75;
      const head = new THREE.Mesh(new THREE.ConeGeometry(.1, .25, 12), arrowMat);
      head.position.y = 1.62;
      const arm = new THREE.Group(); arm.add(shaft, head); g.add(arm);
      const circPts = [];
      for (let i = 0; i <= 64; i++) circPts.push(new THREE.Vector3(Math.cos(i / 64 * Math.PI * 2) * 1.75, Math.sin(i / 64 * Math.PI * 2) * 1.75, 0));
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(circPts), new THREE.LineBasicMaterial({ color: 0x221133, transparent: true, opacity: .6 })));
      const traceN = 80, tracePts = new Float32Array(traceN * 3);
      const traceGeo = new THREE.BufferGeometry(); traceGeo.setAttribute('position', new THREE.BufferAttribute(tracePts, 3));
      g.add(new THREE.Line(traceGeo, new THREE.LineBasicMaterial({ color: 0xcc88ff, transparent: true, opacity: .8 })));
      const obj = addToScene(g, 'Phasor', 'AC Circuit');
      obj.animFn = (dt, t, mesh) => {
        arm.rotation.z = -t * 2;
        const pos = traceGeo.attributes.position;
        for (let i = 0; i < traceN; i++) { const tt = t * 2 - (i / traceN) * Math.PI * 4; pos.setXYZ(i, 2.2 + (i / traceN) * 3, Math.sin(tt) * 1.75, 0); }
        pos.needsUpdate = true;
      };
    }

    // ‚îÄ‚îÄ PRESET SCENES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const SCENE_TABS = {
      physics: [
        { id: 'magnetic', icon: 'üß≤', name: 'Magnetic Dipole', cat: 'EM' },
        { id: 'solar', icon: '‚òÄÔ∏è', name: 'Solar System', cat: 'Orbital' },
        { id: 'crystal', icon: 'üíé', name: 'Crystal Lattice', cat: 'Solid State' },
        { id: 'wave_fn', icon: '„Ä∞Ô∏è', name: 'Wave Function', cat: 'QM' },
        { id: 'dna', icon: 'üß¨', name: 'DNA Helix', cat: 'Bio' },
        { id: 'torus_knot', icon: '‚¨°', name: 'Torus Knot', cat: 'Topology' },
      ],
      ece: [
        { id: 'rc_circuit', icon: '‚üä', name: 'RC Circuit', cat: 'Passive' },
        { id: 'opamp_inv', icon: '‚ñ∑', name: 'Inverting Amp', cat: 'Active' },
        { id: 'logic_full', icon: '‚äì', name: 'Full Adder', cat: 'Digital' },
        { id: 'transmission', icon: '„Ä∞', name: 'Transmission Line', cat: 'RF' },
        { id: 'power_triangle', icon: '‚ñ≥', name: 'Power Triangle', cat: 'AC' },
        { id: 'bode', icon: 'üìà', name: 'Bode Plot', cat: 'Control' },
      ],
      math: [
        { id: 'fourier', icon: '‚äû', name: 'Fourier Series', cat: 'Analysis' },
        { id: 'riemann', icon: '‚àë', name: 'Riemann Surface', cat: 'Complex' },
        { id: 'laplace', icon: '‚àá', name: 'Laplace Field', cat: 'PDE' },
        { id: 'eigenvalue', icon: 'Œª', name: 'Eigenvalue Vis', cat: 'Linear Alg' },
        { id: 'bezier', icon: '‚àø', name: 'B√©zier Curves', cat: 'Geometry' },
        { id: 'mandelbrot3d', icon: '‚àû', name: 'Mandelbrot 3D', cat: 'Fractal' },
      ],
      cs: [
        { id: 'binary_tree', icon: 'üå≤', name: 'Binary Tree', cat: 'DS' },
        { id: 'neural_net', icon: 'üß†', name: 'Neural Net', cat: 'ML' },
        { id: 'hash_table', icon: '‚äû', name: 'Hash Table', cat: 'DS' },
        { id: 'sorting', icon: '‚Üï', name: 'Sorting Vis', cat: 'Algo' },
        { id: 'network_graph', icon: '‚óé', name: 'Network Graph', cat: 'Networks' },
        { id: 'stack_queue', icon: '‚ä£', name: 'Stack & Queue', cat: 'DS' },
      ],
    };

    const PRESET_FNS = {
      magnetic: buildMagneticPreset, solar: buildSolarPreset, crystal: buildCrystalPreset,
      wave_fn: buildWaveFunctionPreset, dna: buildDNAPreset, torus_knot: buildTorusKnotPreset,
      rc_circuit: buildRCCircuit, opamp_inv: buildOpAmpPreset, logic_full: buildFullAdder,
      fourier: buildFourierSeries, neural_net: buildNeuralNet, binary_tree: buildBinaryTree,
      bode: buildBodePlot, sorting: buildSortingVis, network_graph: buildNetworkGraph,
    };

    function renderSceneGrid(tab) {
      const grid = document.getElementById('scene-grid');
      grid.innerHTML = SCENE_TABS[tab].map(s =>
        `<div class="scene-card" id="sc-${s.id}" onclick="loadScene('${s.id}')">
      <span class="scene-icon">${s.icon}</span>
      <div class="scene-info"><span class="scene-name">${s.name}</span><span class="scene-cat">${s.cat}</span></div>
    </div>`).join('');
    }

    function switchSceneTab(tab) {
      sceneTab = tab;
      ['physics', 'ece', 'math', 'cs'].forEach(t => document.getElementById('stab-' + t).classList.toggle('active', t === tab));
      renderSceneGrid(tab);
    }

    function loadScene(id) {
      clearScene();
      document.querySelectorAll('.scene-card').forEach(c => c.classList.remove('active'));
      document.getElementById('sc-' + id)?.classList.add('active');
      if (PRESET_FNS[id]) PRESET_FNS[id]();
      else toast(`Scene "${id}" ‚Äî Ask Blitz to build it!`);
      updateObjectCount();
    }

    // ‚îÄ‚îÄ PRESET IMPLEMENTATIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function buildMagneticPreset() {
      const g = new THREE.Group();
      const pM = new THREE.MeshStandardMaterial({ color: 0xff4466, emissive: 0x880022, emissiveIntensity: .5 });
      const nM = new THREE.MeshStandardMaterial({ color: 0x4488ff, emissive: 0x002288, emissiveIntensity: .5 });
      const north = new THREE.Mesh(new THREE.SphereGeometry(.2, 16, 16), pM); north.position.y = 1.2;
      const south = new THREE.Mesh(new THREE.SphereGeometry(.2, 16, 16), nM); south.position.y = -1.2;
      const core = new THREE.Mesh(new THREE.CylinderGeometry(.08, .08, 2.4, 12), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: .9 }));
      g.add(north, south, core);
      const lM = new THREE.LineBasicMaterial({ color: 0x9966ff, transparent: true, opacity: .4 });
      for (let i = 0; i < 12; i++) {
        const a = (i / 12) * Math.PI * 2, pts = [];
        for (let t = 0; t <= 60; t++) { const th = (t / 60) * Math.PI, r = 2 * Math.sin(th) ** 2; pts.push(new THREE.Vector3(r * Math.cos(a), r * 2.6 * Math.cos(th), r * Math.sin(a))); }
        g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lM));
      }
      objGroup.add(g);
      sceneObjects.push({ mesh: g, name: 'Magnetic Field', type: 'Physics', animFn: (dt, t, m) => { m.rotation.y += dt * .2; } });
      document.getElementById('scene-name').textContent = 'Magnetic Field';
      updateObjectCount();
    }

    function buildSolarPreset() {
      const sun = new THREE.Mesh(new THREE.SphereGeometry(.7, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffcc44, emissive: 0xff8800, emissiveIntensity: .9 }));
      objGroup.add(sun);
      objGroup.add(new THREE.PointLight(0xffaa22, 2.5, 40));
      const planets = [{ r: .12, orb: 1.4, sp: 2.1, c: 0xaa8866, n: 'Mercury' }, { r: .22, orb: 2.1, sp: 1.3, c: 0xffcc88, n: 'Venus' },
      { r: .23, orb: 3.0, sp: 1.0, c: 0x2266cc, n: 'Earth' }, { r: .16, orb: 3.9, sp: .7, c: 0xcc4422, n: 'Mars' },
      { r: .42, orb: 5.8, sp: .35, c: 0xddbb88, n: 'Jupiter' }];
      const orbs = [];
      planets.forEach((p, i) => {
        const ring = new THREE.Mesh(new THREE.RingGeometry(p.orb - .01, p.orb + .01, 64), new THREE.MeshBasicMaterial({ color: 0x1a0033, side: THREE.DoubleSide, transparent: true, opacity: .5 }));
        ring.rotation.x = Math.PI / 2; objGroup.add(ring);
        const planet = new THREE.Mesh(new THREE.SphereGeometry(p.r, 20, 20), new THREE.MeshStandardMaterial({ color: p.c, roughness: .7 }));
        const a0 = i * 1.3; planet.position.set(Math.cos(a0) * p.orb, 0, Math.sin(a0) * p.orb);
        planet.userData = { orb: p.orb, sp: p.sp, ang: a0 }; objGroup.add(planet); orbs.push(planet);
      });
      sceneObjects.push({
        mesh: objGroup, name: 'Solar System', type: 'Physics', animFn: (dt, t, m) => {
          orbs.forEach(p => { p.userData.ang += p.userData.sp * dt; p.position.set(Math.cos(p.userData.ang) * p.userData.orb, 0, Math.sin(p.userData.ang) * p.userData.orb); });
        }
      });
      document.getElementById('scene-name').textContent = 'Solar System';
    }

    function buildCrystalPreset() {
      const aM = new THREE.MeshStandardMaterial({ color: 0xaa88ff, emissive: 0x330066, emissiveIntensity: .35, metalness: .1, roughness: .4 });
      const bM = new THREE.MeshStandardMaterial({ color: 0x440066, transparent: true, opacity: .4 });
      const aG = new THREE.SphereGeometry(.11, 12, 12);
      for (let x = -2; x <= 2; x++)for (let y = -2; y <= 2; y++)for (let z = -2; z <= 2; z++) {
        const a = new THREE.Mesh(aG, aM); a.position.set(x * .75, y * .75, z * .75); objGroup.add(a);
        [[1, 0, 0], [0, 1, 0], [0, 0, 1]].forEach(([dx, dy, dz]) => {
          if (x + dx <= 2 && y + dy <= 2 && z + dz <= 2) {
            const b = new THREE.Mesh(new THREE.CylinderGeometry(.022, .022, .75, 6), bM);
            b.position.set((x + dx / 2) * .75, (y + dy / 2) * .75, (z + dz / 2) * .75);
            if (dx) b.rotation.z = Math.PI / 2; if (dz) b.rotation.x = Math.PI / 2;
            objGroup.add(b);
          }
        });
      }
      document.getElementById('scene-name').textContent = 'Crystal Lattice';
    }

    function buildWaveFunctionPreset() {
      const geo = new THREE.PlaneGeometry(10, 4, 120, 50);
      const mat = new THREE.MeshStandardMaterial({ color: 0xcc88ff, emissive: 0x330055, emissiveIntensity: .3, transparent: true, opacity: .8, side: THREE.DoubleSide });
      const wave = new THREE.Mesh(geo, mat); wave.rotation.x = -Math.PI / 5;
      wave.userData.t = 0;
      wave.onBeforeRender = () => {
        if (!animating) return;
        wave.userData.t += .018;
        const p = geo.attributes.position;
        for (let i = 0; i < p.count; i++) {
          const x = p.getX(i), y = p.getY(i);
          p.setZ(i, .7 * Math.sin(x * 1.2 + wave.userData.t) * Math.exp(-x * x * .05) * Math.cos(y * .8 + wave.userData.t * .5));
        }
        p.needsUpdate = true; geo.computeVertexNormals();
      };
      objGroup.add(wave);
      const N = 600, pP = new Float32Array(N * 3);
      for (let i = 0; i < N; i++) { pP[i * 3] = (Math.random() - .5) * 8; pP[i * 3 + 1] = (Math.random() - .5) * 2; pP[i * 3 + 2] = (Math.random() - .5) * 2; }
      const pG = new THREE.BufferGeometry(); pG.setAttribute('position', new THREE.BufferAttribute(pP, 3));
      objGroup.add(new THREE.Points(pG, new THREE.PointsMaterial({ color: 0xcc88ff, size: .05, transparent: true, opacity: .6 })));
      document.getElementById('scene-name').textContent = 'Wave Function';
    }

    function buildDNAPreset() {
      const m1 = new THREE.MeshStandardMaterial({ color: 0xff4488, emissive: 0x880033, emissiveIntensity: .3 });
      const m2 = new THREE.MeshStandardMaterial({ color: 0x8844ff, emissive: 0x220088, emissiveIntensity: .3 });
      const g = new THREE.SphereGeometry(.09, 10, 10);
      for (let i = 0; i < 50; i++) {
        const t = (i / 50) * Math.PI * 8 - Math.PI * 4, y = (i / 50) * 8 - 4, r = 1.1;
        const a1 = new THREE.Mesh(g, m1); a1.position.set(Math.cos(t) * r, y, Math.sin(t) * r); objGroup.add(a1);
        const a2 = new THREE.Mesh(g, m2); a2.position.set(Math.cos(t + Math.PI) * r, y, Math.sin(t + Math.PI) * r); objGroup.add(a2);
        if (i % 4 === 0) objGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([a1.position.clone(), a2.position.clone()]), new THREE.LineBasicMaterial({ color: 0x88ff88, transparent: true, opacity: .45 })));
      }
      document.getElementById('scene-name').textContent = 'DNA Helix';
    }

    function buildTorusKnotPreset() {
      const geo = new THREE.TorusKnotGeometry(1.6, .35, 200, 20, 2, 3);
      const mat = new THREE.MeshStandardMaterial({ color: 0x8833ff, emissive: 0x220044, emissiveIntensity: .45, metalness: .4, roughness: .3 });
      objGroup.add(new THREE.Mesh(geo, mat));
      const N = 3000, pP = new Float32Array(N * 3);
      for (let i = 0; i < N; i++) {
        const th = (i / N) * Math.PI * 4, ph = th * 3, r = 1.6 + .35 * Math.cos(ph);
        pP[i * 3] = r * Math.cos(th) + (Math.random() - .5) * .3;
        pP[i * 3 + 1] = r * Math.sin(th) + (Math.random() - .5) * .3;
        pP[i * 3 + 2] = .35 * Math.sin(ph) + (Math.random() - .5) * .3;
      }
      const pG = new THREE.BufferGeometry(); pG.setAttribute('position', new THREE.BufferAttribute(pP, 3));
      objGroup.add(new THREE.Points(pG, new THREE.PointsMaterial({ color: 0xcc88ff, size: .025, transparent: true, opacity: .5 })));
      document.getElementById('scene-name').textContent = 'Torus Knot';
    }

    function buildRCCircuit() {
      const g = new THREE.Group();
      const wireMat = new THREE.MeshStandardMaterial({ color: 0xddcc88, metalness: .8, roughness: .2 });
      const wire = new THREE.Mesh(new THREE.CylinderGeometry(.025, .025, 6, 8), wireMat); wire.rotation.z = Math.PI / 2; g.add(wire);
      const rBody = new THREE.Mesh(new THREE.CylinderGeometry(.12, .12, .5, 16), new THREE.MeshStandardMaterial({ color: 0xcc8844 }));
      rBody.rotation.z = Math.PI / 2; rBody.position.x = -1; g.add(rBody);
      [-0.4, 0.4].forEach((x, i) => {
        const pl = new THREE.Mesh(new THREE.BoxGeometry(.04, .5, .5), new THREE.MeshStandardMaterial({ color: i ? 0xff4466 : 0x4488ff, metalness: .7 }));
        pl.position.x = 1.5 + x; g.add(pl);
      });
      const sig = new THREE.Mesh(new THREE.SphereGeometry(.07, 10, 10), new THREE.MeshBasicMaterial({ color: 0xa050ff }));
      g.add(sig);
      objGroup.add(g);
      const obj = {
        mesh: g, name: 'RC Circuit', type: 'ECE', animFn: (dt, t, m) => {
          const tt = (t * .8) % 1; sig.position.set(-3 + tt * 6, 0, 0); sig.material.color.setHSL(.7 * (1 - tt), 1, .55);
        }
      };
      sceneObjects.push(obj);
      document.getElementById('scene-name').textContent = 'RC Circuit';
      updateObjectCount();
    }

    function buildOpAmpPreset() { buildOpAmp(); document.getElementById('scene-name').textContent = 'Op-Amp Inverter'; }

    function buildFullAdder() {
      const layout = [{ type: 'AND', x: -2, y: 1.2 }, { type: 'AND', x: -2, y: -1.2 }, { type: 'OR', x: 0, y: 0 }, { type: 'OR', x: 2, y: 1 }];
      layout.forEach(({ type, x, y }) => {
        buildGate(type);
        const last = sceneObjects[sceneObjects.length - 1];
        last.mesh.position.set(x, y, 0);
      });
      document.getElementById('scene-name').textContent = 'Full Adder';
    }

    function buildFourierSeries() {
      const g = new THREE.Group();
      const N = 8, arms = [];
      for (let i = 0; i < N; i++) {
        const r = 1 / (2 * i + 1);
        const ring = new THREE.Mesh(new THREE.TorusGeometry(r, .012, 8, 80), new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(i / N * .4 + .6, 1, .6), transparent: true, opacity: .5 }));
        ring.rotation.x = Math.PI / 2;
        const arm = new THREE.Mesh(new THREE.CylinderGeometry(.015, .015, r * 2, 8), new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(i / N * .4 + .6, 1, .7) }));
        const grp = new THREE.Group(); grp.add(ring, arm); arm.position.y = r; g.add(grp); arms.push({ grp, r, n: 2 * i + 1 });
      }
      const traceN = 300, traceP = new Float32Array(traceN * 3);
      const tGeo = new THREE.BufferGeometry(); tGeo.setAttribute('position', new THREE.BufferAttribute(traceP, 3));
      g.add(new THREE.Line(tGeo, new THREE.LineBasicMaterial({ color: 0xcc88ff, transparent: true, opacity: .8 })));
      objGroup.add(g);
      const obj = {
        mesh: g, name: 'Fourier Series', type: 'Math', animFn: (dt, t, mesh) => {
          arms.reduce((acc, { grp, r, n }) => { grp.rotation.z = t * n; const angle = t * n; const nx = acc.x + r * Math.cos(angle), ny = acc.y + r * Math.sin(angle); grp.position.set(acc.x, acc.y, 0); return { x: nx, y: ny }; }, { x: 0, y: 0 });
          const pos = tGeo.attributes.position; let lx = 0, ly = 0;
          arms.forEach(({ r, n }) => { lx += r * Math.cos(t * n); ly += r * Math.sin(t * n); });
          for (let i = traceN - 1; i > 0; i--) pos.setXYZ(i, pos.getX(i - 1), pos.getY(i - 1), pos.getZ(i - 1));
          pos.setXYZ(0, lx, ly, 0); pos.needsUpdate = true;
        }
      };
      sceneObjects.push(obj);
      document.getElementById('scene-name').textContent = 'Fourier Series';
      updateObjectCount();
    }

    function buildNeuralNet() {
      const g = new THREE.Group();
      const layers = [3, 5, 4, 5, 2];
      const nodePositions = [];
      layers.forEach((n, li) => {
        const lx = (li / (layers.length - 1)) * 5 - 2.5;
        const nodes = [];
        for (let ni = 0; ni < n; ni++) {
          const ny = (ni / (n - 1) - .5) * 3;
          const node = new THREE.Mesh(new THREE.SphereGeometry(.15, 12, 12), new THREE.MeshStandardMaterial({ color: 0xa050ff, emissive: 0x220044, emissiveIntensity: .4, metalness: .2 }));
          node.position.set(lx, ny, 0); g.add(node); nodes.push(node);
        }
        nodePositions.push(nodes);
      });
      nodePositions.forEach((layer, li) => {
        if (li === nodePositions.length - 1) return;
        layer.forEach(a => nodePositions[li + 1].forEach(b => {
          g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([a.position, b.position]), new THREE.LineBasicMaterial({ color: 0x220044, transparent: true, opacity: .5 })));
        }));
      });
      objGroup.add(g);
      const allNodes = nodePositions.flat();
      const obj = {
        mesh: g, name: 'Neural Network', type: 'CS/ML', animFn: (dt, t, m) => {
          allNodes.forEach((n, i) => { const v = .5 + .5 * Math.sin(t * 2 + i * .7); n.material.emissiveIntensity = v * .8; n.material.color.setHSL(.75, v * .8, v * .5 + .2); });
        }
      };
      sceneObjects.push(obj);
      document.getElementById('scene-name').textContent = 'Neural Network';
      updateObjectCount();
    }

    function buildBinaryTree() {
      const g = new THREE.Group();
      function addNode(x, y, depth, maxDepth) {
        if (depth > maxDepth) return;
        const n = new THREE.Mesh(new THREE.SphereGeometry(.18, 12, 12), new THREE.MeshStandardMaterial({ color: 0xa050ff, emissive: 0x220044, emissiveIntensity: .4 }));
        n.position.set(x, y, 0); g.add(n);
        if (depth < maxDepth) {
          const spread = Math.pow(2, maxDepth - depth - 1) * .7, childY = y - 1.2;
          [[x - spread], [x + spread]].forEach(([cx]) => {
            g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, y, 0), new THREE.Vector3(cx, childY, 0)]), new THREE.LineBasicMaterial({ color: 0x330055 })));
            addNode(cx, childY, depth + 1, maxDepth);
          });
        }
      }
      addNode(0, 2.5, 0, 3);
      objGroup.add(g);
      sceneObjects.push({ mesh: g, name: 'Binary Tree', type: 'Data Structure' });
      document.getElementById('scene-name').textContent = 'Binary Tree';
      updateObjectCount();
    }

    function buildBodePlot() {
      const g = new THREE.Group();
      const axMat = new THREE.LineBasicMaterial({ color: 0x221133 });
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-4, 0, 0), new THREE.Vector3(4, 0, 0)]), axMat));
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-4, -2, 0), new THREE.Vector3(-4, 2, 0)]), axMat));
      const magPts = [], phasePts = [];
      for (let i = 0; i <= 100; i++) {
        const logf = (i / 100) * 6 - 3, omega = Math.pow(10, logf);
        magPts.push(new THREE.Vector3(logf * (4 / 3), 20 * Math.log10(1 / Math.sqrt(1 + omega * omega)) * .06, 0));
        phasePts.push(new THREE.Vector3(logf * (4 / 3), -Math.atan(omega) * 180 / Math.PI * .01, -0.1));
      }
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(magPts), new THREE.LineBasicMaterial({ color: 0xa050ff })));
      g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(phasePts), new THREE.LineBasicMaterial({ color: 0xff8844, transparent: true, opacity: .8 })));
      const mark = new THREE.Mesh(new THREE.SphereGeometry(.06, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
      mark.position.set(0, -3 * .06, 0); g.add(mark);
      objGroup.add(g);
      sceneObjects.push({ mesh: g, name: 'Bode Plot', type: 'Control' });
      document.getElementById('scene-name').textContent = 'Bode Plot';
      updateObjectCount();
    }

    function buildSortingVis() {
      const g = new THREE.Group();
      const N = 20;
      const vals = Array.from({ length: N }, () => Math.random());
      const bars = [];
      vals.forEach((v, i) => {
        const h = v * 3 + .3, col = new THREE.Color().setHSL(v * .5 + .6, 1, .55);
        const bar = new THREE.Mesh(new THREE.BoxGeometry(.25, h, .25), new THREE.MeshStandardMaterial({ color: col, emissive: col, emissiveIntensity: .3 }));
        bar.position.set((i - N / 2) * .3, h / 2, 0); g.add(bar); bars.push({ mesh: bar, val: v });
      });
      objGroup.add(g);
      let step = 0, sorted = false;
      const obj = {
        mesh: g, name: 'Bubble Sort', type: 'Algorithm', animFn: (dt, t, m) => {
          if (sorted || Math.floor(t * 5) <= step) return;
          step = Math.floor(t * 5);
          for (let i = 0; i < bars.length - 1; i++) {
            if (bars[i].val > bars[i + 1].val) {
              [bars[i], bars[i + 1]] = [bars[i + 1], bars[i]];
              bars.forEach((b, j) => { b.mesh.position.x = (j - N / 2) * .3; const col = new THREE.Color().setHSL(b.val * .5 + .6, 1, .55); b.mesh.material.color = col; b.mesh.material.emissive = col; });
              break;
            }
            if (i === bars.length - 2) sorted = true;
          }
        }
      };
      sceneObjects.push(obj);
      document.getElementById('scene-name').textContent = 'Bubble Sort';
      updateObjectCount();
    }

    function buildNetworkGraph() {
      const g = new THREE.Group();
      const N = 12, nodes = [];
      for (let i = 0; i < N; i++) {
        const th = (i / N) * Math.PI * 2, r = 2 + Math.random() * .8;
        const n = new THREE.Mesh(new THREE.SphereGeometry(.15, 12, 12), new THREE.MeshStandardMaterial({ color: 0xa050ff, emissive: 0x220044, emissiveIntensity: .4 }).clone());
        n.position.set(Math.cos(th) * r, Math.sin(th) * r, (Math.random() - .5) * .5);
        g.add(n); nodes.push(n);
      }
      const eMat = new THREE.LineBasicMaterial({ color: 0x220044, transparent: true, opacity: .7 });
      for (let i = 0; i < N * 2; i++) {
        const a = nodes[Math.floor(Math.random() * N)], b = nodes[Math.floor(Math.random() * N)];
        if (a !== b) g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([a.position, b.position]), eMat));
      }
      objGroup.add(g);
      const obj = {
        mesh: g, name: 'Network Graph', type: 'CS', animFn: (dt, t, m) => {
          nodes.forEach((n, i) => { const v = .4 + .6 * Math.abs(Math.sin(t + i * .8)); n.material.emissiveIntensity = v * .7; n.material.color.setHSL(.75 + Math.sin(t + i) * .05, 1, v * .35 + .2); });
        }
      };
      sceneObjects.push(obj);
      document.getElementById('scene-name').textContent = 'Network Graph';
      updateObjectCount();
    }

    // ‚îÄ‚îÄ SCENE CONTROLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function clearScene() {
      while (objGroup.children.length) objGroup.remove(objGroup.children[0]);
      // Also remove user-added lights
      addedLights.forEach(l => scene.remove(l));
      addedLights = [];
      sceneObjects = []; selectedObj = null;
      updateObjectCount(); updateOutliner();
      document.getElementById('scene-name').textContent = 'Empty Scene';
      document.getElementById('sb-selected-item').style.display = 'none';
      toast('Scene cleared');
    }

    function toggleFog(on) { scene.fog = on ? new THREE.FogExp2(0x04010c, .04) : null; }
    function toggleWireframe() {
      wireMode = !wireMode;
      document.getElementById('chip-wire').classList.toggle('active', wireMode);
      objGroup.traverse(o => { if (o.isMesh && o.material) { (Array.isArray(o.material) ? o.material : [o.material]).forEach(m => m.wireframe = wireMode); } });
      toast(wireMode ? 'Wireframe ON' : 'Wireframe OFF');
    }
    function toggleGrid() { gridH.visible = !gridH.visible; document.getElementById('chip-grid').classList.toggle('active', gridH.visible); }
    function toggleAxes() { axesH.visible = !axesH.visible; document.getElementById('chip-axes').classList.toggle('active', axesH.visible); }
    function toggleAnimation() { animating = !animating; document.getElementById('chip-anim').textContent = animating ? '‚ñ∂ Anim' : '‚è∏ Pause'; }
    function toggleSnap() { snapOn = !snapOn; document.getElementById('snap-btn').classList.toggle('active', snapOn); toast('Snap ' + (snapOn ? 'ON' : 'OFF')); }
    function toggleBlitz() { document.getElementById('right-panel').classList.toggle('collapsed'); resizeRenderer(); }
    function toggleLeftPanel() { document.getElementById('left-panel').classList.toggle('collapsed'); resizeRenderer(); }

    function setCameraPreset(p) {
      if (p === 'front') { orbit.theta = 0; orbit.phi = Math.PI / 2; }
      else if (p === 'top') { orbit.phi = 0.08; orbit.theta = 0; }
      else if (p === 'side') { orbit.theta = Math.PI / 2; orbit.phi = Math.PI / 2; }
      else if (p === 'persp' || p === 'perspective') { orbit.theta = 0.65; orbit.phi = 0.8; }
      else if (p === 'ortho') { camera.fov = 4; camera.updateProjectionMatrix(); return; }
      if (p !== 'ortho') { camera.fov = 55; camera.updateProjectionMatrix(); }
      updateOrbit(); updateGizmo();
    }
    function resetCamera() { orbit.r = 12; orbit.theta = 0.65; orbit.phi = 0.8; orbit.target.set(0, 0, 0); updateOrbit(); updateGizmo(); }

    function setMode(m) {
      appMode = m;
      ['object', 'edit', 'sim', 'render'].forEach(x => document.getElementById('mode-' + x).classList.toggle('active', x === m));
      document.getElementById('sb-mode').textContent = m.toUpperCase() + ' MODE';
    }

    function setTxMode(m) {
      txMode = m;
      ['select', 'move', 'rotate', 'scale'].forEach(x => document.getElementById('tx-' + x)?.classList.toggle('active', x === m));
      document.getElementById('mode-hud').textContent =
        { select: '‚óà SELECT', move: '‚äï MOVE', rotate: '‚Üª ROTATE', scale: '‚üê SCALE' }[m] || m.toUpperCase();
      document.getElementById('sb-tx').textContent = m.toUpperCase();
      document.getElementById('sb-tx-mode').style.display = m !== 'select' ? 'flex' : 'none';
      // Update cursor for direct-drag workflow
      const zone = document.getElementById('canvas-zone');
      zone.style.cursor = m === 'move' ? 'grab' : m === 'rotate' ? 'ew-resize' : m === 'scale' ? 'nwse-resize' : '';
    }

    function updateObjectCount() {
      let c = 0, v = 0;
      objGroup.traverse(o => { if (o.isMesh) { c++; v += o.geometry?.attributes?.position?.count || 0; } });
      document.getElementById('hud-obj').textContent = c + ' objects';
      document.getElementById('sb-objs').textContent = c;
      document.getElementById('sb-verts').textContent = v.toLocaleString();
      const hud = document.getElementById('poly-hud');
      hud.style.display = c ? 'flex' : 'none';
      hud.textContent = v.toLocaleString() + ' verts';
    }

    function updateOutliner() {
      const el = document.getElementById('outliner-list');
      if (!sceneObjects.length) { el.innerHTML = '<div style="font-family:var(--mono);font-size:8px;color:var(--muted);padding:4px 0;">Scene is empty</div>'; return; }
      el.innerHTML = sceneObjects.map((o, i) => `
    <div class="obj-item${o === selectedObj ? ' selected' : ''}" onclick="selectObject(sceneObjects[${i}])">
      <span style="color:var(--muted);font-size:10px;">‚¨°</span>
      <span>${o.name}</span>
      <span style="font-family:var(--mono);font-size:7px;color:var(--muted);margin-left:2px;">${o.type}</span>
      <span class="obj-eye" onclick="event.stopPropagation();sceneObjects[${i}].mesh.visible=!sceneObjects[${i}].mesh.visible">üëÅ</span>
      <span class="obj-del" onclick="event.stopPropagation();deleteObj(${i})">‚úï</span>
    </div>`).join('');
    }

    function deleteObj(i) {
      if (!sceneObjects[i]) return;
      objGroup.remove(sceneObjects[i].mesh);
      if (selectedObj === sceneObjects[i]) selectObject(null);
      sceneObjects.splice(i, 1);
      updateObjectCount(); updateOutliner();
      toast('Object deleted');
    }

    function showRenderTag(txt) {
      const t = document.getElementById('render-tag');
      t.textContent = '‚¨° ' + txt; t.classList.add('show', 'pulse');
      setTimeout(() => { t.classList.remove('pulse'); setTimeout(() => t.classList.remove('show'), 2500); }, 900);
    }

    // ‚îÄ‚îÄ LEFT PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function switchLTab(tab) {
      leftTab = tab;
      ['add', 'props', 'scene'].forEach(t => {
        document.getElementById('lt-' + t).classList.toggle('active', t === tab);
        document.getElementById('ltab-' + t).style.display = t === tab ? 'block' : 'none';
      });
    }
    function togglePS(head) { head.classList.toggle('open'); head.nextElementSibling.classList.toggle('open'); }

    // ‚îÄ‚îÄ POPUP MENUS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function openPopup(id, event) {
      closePopups();
      const menu = document.getElementById(id);
      if (!menu) return;
      menu.classList.add('open');
      const rect = event.target.getBoundingClientRect();
      menu.style.left = rect.left + 'px';
      menu.style.top = rect.bottom + 4 + 'px';
      event.stopPropagation();
    }
    function closePopups() {
      document.querySelectorAll('.popup-menu').forEach(m => m.classList.remove('open'));
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('.popup-menu') && !e.target.closest('.mb-btn')) closePopups();
    });

    // ‚îÄ‚îÄ KEYBOARD SHORTCUTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    document.addEventListener('keydown', e => {
      // Ignore when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      const key = e.key.toLowerCase();

      // Movement shortcuts (Blender-style)
      if (!movingObj) {
        if (key === 'g' && selectedObj) {
          startMove('grab'); return;
        }
        if (key === 'r' && selectedObj) {
          moveStartMouse = { x: moveCurrentMouse.x, y: moveCurrentMouse.y };
          startMove('rotate'); return;
        }
        if (key === 's' && selectedObj) {
          moveStartMouse = { x: moveCurrentMouse.x, y: moveCurrentMouse.y };
          startMove('scale'); return;
        }
        if (key === 'delete' && selectedObj) { deleteSelected(); return; }
        if (key === 'd' && selectedObj && e.shiftKey) { duplicateSelected(); return; }
        if (key === 'a' && !e.ctrlKey) { selectObject(null); return; }
        if (key === 'escape') selectObject(null);
      } else {
        // In move mode: axis constraints
        if (key === 'x') { setMoveAxis(moveAxis === 'x' ? 'free' : 'x'); return; }
        if (key === 'y') { setMoveAxis(moveAxis === 'y' ? 'free' : 'y'); return; }
        if (key === 'z') { setMoveAxis(moveAxis === 'z' ? 'free' : 'z'); return; }
        if (key === 'enter') { confirmMove(); return; }
        if (key === 'escape') { cancelMove(); return; }
      }

      // Other shortcuts
      if (key === 'delete' && selectedObj && !movingObj) deleteSelected();
    });

    // Continuous movement in animation loop
    function updateCameraMovement(dt) {
      const speed = orbit.r * 1.5 * dt; // scale to zoom level
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      const right = new THREE.Vector3().crossVectors(camDir, camera.up).normalize();
      const forward = new THREE.Vector3(camDir.x, 0, camDir.z).normalize();
      let moved = false;

      // WASD
      if (keysDown['w'] || keysDown['arrowup']) { orbit.target.addScaledVector(forward, speed); moved = true; }
      if (keysDown['s'] && !selectedObj || keysDown['arrowdown']) { orbit.target.addScaledVector(forward, -speed); moved = true; }
      if (keysDown['a'] && !selectedObj || keysDown['arrowleft']) { orbit.target.addScaledVector(right, -speed); moved = true; }
      if (keysDown['d'] && !selectedObj || keysDown['arrowright']) { orbit.target.addScaledVector(right, speed); moved = true; }
      // Q/E for vertical
      if (keysDown['q']) { orbit.target.y -= speed; moved = true; }
      if (keysDown['e']) { orbit.target.y += speed; moved = true; }

      if (moved) { updateOrbit(); updateGizmo(); }
    }

    // Track mouse position always (for keyboard-initiated moves to know where mouse is)
    document.addEventListener('mousemove', e => {
      moveCurrentMouse = { x: e.clientX, y: e.clientY };
      if (!movingObj && selectedObj) {
        moveStartMouse = { x: e.clientX, y: e.clientY };
      }
    });

    // ‚îÄ‚îÄ API CHECK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function checkAPI() {
      try {
        const r = await fetch(`${API}/`, { signal: AbortSignal.timeout(3000) });
        if (r.ok) {
          ['api-dot', 'api-dot2'].forEach(id => { document.getElementById(id).className = 'api-dot on'; });
          document.getElementById('api-lbl').textContent = 'online';
          document.getElementById('sb-api').textContent = 'API online';
        }
      } catch {
        ['api-dot', 'api-dot2'].forEach(id => { document.getElementById(id).className = 'api-dot off'; });
        document.getElementById('api-lbl').textContent = 'offline';
        document.getElementById('sb-api').textContent = 'offline';
      }
    }
    checkAPI(); setInterval(checkAPI, 12000);

    // ‚îÄ‚îÄ BLITZ CHAT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function sendStudio() {
      const inp = document.getElementById('b-inp');
      const text = inp.value.trim(); if (!text) return;
      inp.value = ''; addMsg('u', text); showTyping();
      if (_ws && _ws.readyState === WebSocket.OPEN) {
        _wsBuf = ''; _wsRes = null;
        await new Promise(resolve => {
          _wsRes = resolve;
          setTimeout(() => { hideTyping(); _wsEl = createStreamBubble(); }, 100);
          _ws.send(JSON.stringify({ text, active_modules: ['vision'] }));
        });
        const resp = _wsBuf; _wsEl = null; _wsBuf = '';
        processBlitzResponse(resp); return;
      }
      let resp = '';
      try {
        const r = await fetch(`${API}/api/command`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, active_modules: ['vision'] }), signal: AbortSignal.timeout(20000)
        });
        const d = await r.json(); resp = d.response;
      } catch { resp = simulateStudio(text); }
      hideTyping(); addMsg('b', resp, extractCode(resp)); processBlitzResponse(resp);
    }

    function processBlitzResponse(resp) {
      const code = extractCode(resp);
      if (code) { lastSceneCode = code; setTimeout(() => executeCode(code), 300); }
    }
    function extractCode(resp) { const m = resp.match(/```(?:javascript|js)?\n?([\s\S]+?)```/); return m ? m[1].trim() : null; }
    function quickP(text) { document.getElementById('b-inp').value = text; sendStudio(); }
    function renderFromChat() { if (lastSceneCode) executeCode(lastSceneCode); else toast('Ask Blitz to generate a scene first'); }

    function executeCode(code) {
      try {
        clearScene();
        const fn = new Function('THREE', 'objectGroup', 'scene', code);
        fn(THREE, objGroup, scene);
        updateObjectCount(); updateOutliner();
        showRenderTag('RENDERED');
        toast('‚¨° Scene rendered!', true);
        document.getElementById('scene-name').textContent = 'Custom Scene';
      } catch (err) {
        toast('Error: ' + err.message);
        addMsg('b', '**Render error:** `' + err.message + '`\n\nUse `objectGroup` to add objects, `THREE` for all classes.');
      }
    }

    function simulateStudio(p) {
      const q = p.toLowerCase();
      if (q.includes('rc') || q.includes('resistor') || q.includes('circuit')) {
        return `RC low-pass filter:\n\n\`\`\`javascript\nconst g=new THREE.Group();\nconst wire=new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,6,8),new THREE.MeshStandardMaterial({color:0xddcc88,metalness:.8}));\nwire.rotation.z=Math.PI/2; g.add(wire);\nconst rBody=new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,.5,16),new THREE.MeshStandardMaterial({color:0xcc8844}));\nrBody.rotation.z=Math.PI/2; rBody.position.x=-1; g.add(rBody);\n[-0.15,0.15].forEach((x,i)=>{\n  const pl=new THREE.Mesh(new THREE.BoxGeometry(.04,.5,.5),new THREE.MeshStandardMaterial({color:i?0xff4466:0x4488ff,metalness:.7}));\n  pl.position.x=1.5+x; g.add(pl);\n});\nobjectGroup.add(g);\n\`\`\`\n\nRC filter with resistor + capacitor. Start backend for full AI scenes.`;
      }
      if (q.includes('neural') || q.includes('network')) {
        return `Neural network visualization:\n\n\`\`\`javascript\nconst layers=[4,6,6,3];\nconst nodePos=[];\nlayers.forEach((n,li)=>{\n  const lx=(li/(layers.length-1))*5-2.5,nodes=[];\n  for(let ni=0;ni<n;ni++){\n    const ny=(ni/(n-1)-.5)*3;\n    const nd=new THREE.Mesh(new THREE.SphereGeometry(.15,12,12),new THREE.MeshStandardMaterial({color:0xa050ff,emissive:0x220044,emissiveIntensity:.4}));\n    nd.position.set(lx,ny,0); objectGroup.add(nd); nodes.push(nd);\n  }\n  nodePos.push(nodes);\n});\nnodePos.forEach((layer,li)=>{\n  if(li===nodePos.length-1)return;\n  layer.forEach(a=>nodePos[li+1].forEach(b=>{\n    objectGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([a.position,b.position]),new THREE.LineBasicMaterial({color:0x330055,transparent:true,opacity:.5})));\n  }));\n});\n\`\`\``;
      }
      return `I can generate 3D Three.js scenes. Start backend for AI generation.\n\n\`\`\`javascript\n// Holographic purple sphere\nconst geo=new THREE.SphereGeometry(1,32,32);\nconst mat=new THREE.MeshStandardMaterial({color:0xa050ff,emissive:0x330066,emissiveIntensity:.6,wireframe:false,transparent:true,opacity:.85,metalness:.2,roughness:.2});\nconst sphere=new THREE.Mesh(geo,mat); objectGroup.add(sphere);\nconst ring=new THREE.Mesh(new THREE.TorusGeometry(1.8,.03,8,80),new THREE.MeshBasicMaterial({color:0xcc88ff,transparent:true,opacity:.4}));\nring.rotation.x=Math.PI/3; objectGroup.add(ring);\nconst pl=new THREE.PointLight(0xa050ff,2,10); pl.position.set(0,2,0); objectGroup.add(pl);\n\`\`\`\n\nTry: "Build an op-amp circuit" or "Show a Fourier series"`;
    }

    function addMsg(role, text, code = null) {
      const feed = document.getElementById('blitz-feed');
      const t = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const div = document.createElement('div'); div.className = 'b-msg ' + role;
      div.innerHTML = `<div class="b-who">${role === 'u' ? 'YOU' : 'BLITZ'}</div><div class="b-bubble">${role === 'b' ? renderMD(text) : esc(text)}</div><div class="b-ts">${t}</div>`;
      if (code && role === 'b') {
        const btn = document.createElement('button'); btn.className = 'inject-btn';
        btn.textContent = '‚¨° Re-render'; btn.onclick = () => executeCode(code);
        div.appendChild(btn);
      }
      feed.appendChild(div); scroll_feed();
    }
    function createStreamBubble() {
      const feed = document.getElementById('blitz-feed');
      const div = document.createElement('div'); div.className = 'b-msg b';
      const t = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      div.innerHTML = '<div class="b-who">BLITZ</div><div class="b-bubble" style="min-height:1em"></div><div class="b-ts">' + t + '</div>';
      feed.appendChild(div); scroll_feed();
      return div.querySelector('.b-bubble');
    }
    function showTyping() { const f = document.getElementById('blitz-feed'), e = document.createElement('div'); e.className = 'b-typing'; e.id = 'b-typing'; e.innerHTML = '<div class="tdot"></div><div class="tdot"></div><div class="tdot"></div>'; f.appendChild(e); scroll_feed(); }
    function hideTyping() { document.getElementById('b-typing')?.remove(); }
    function scroll_feed() { document.getElementById('blitz-feed').scrollTop = 99999; }
    function renderMD(t) { let s = t.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); s = s.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, l, c) => `<pre>${c.trim()}</pre>`); s = s.replace(/`([^`]+)`/g, '<code>$1</code>'); s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>'); s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>'); s = s.replace(/\n/g, '<br>'); return s; }
    function esc(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
    let toastTimerFn;
    function toast(msg, c = false) { const t = document.getElementById('toast'); t.textContent = msg; t.className = 'toast show' + (c ? ' purple' : ''); clearTimeout(toastTimerFn); toastTimerFn = setTimeout(() => t.classList.remove('show'), 2600); }

    document.getElementById('b-inp').addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendStudio(); } });

    // Init
    switchSceneTab('physics');

    setTimeout(() => {
      addMsg('b', '**B.L.I.T.Z. Studio v3** ‚Äî Purple Edition\n\n**üñ± Click** an object to select it, then:\n\n**G** ‚Äî Grab & move freely\n**R** ‚Äî Rotate ¬∑ **S** ‚Äî Scale\n**X / Y / Z** ‚Äî Lock to axis while transforming\n**Enter or Click** ‚Äî Confirm ¬∑ **Esc** ‚Äî Cancel\n\n**Shift+D** ‚Äî Duplicate ¬∑ **Del** ‚Äî Delete\n**Right-drag** ‚Äî Orbit ¬∑ **Middle-drag** ‚Äî Pan ¬∑ **Scroll** ‚Äî Zoom\n\n> Add objects from the left panel. Lights, curves and empties in the modebar.');
    }, 400);
  </script>
</body>

</html>
